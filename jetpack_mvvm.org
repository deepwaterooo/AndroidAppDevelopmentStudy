#+latex_class: cn-article
#+title: Jetpack MVVM
#+author: deepwaterooo

* Jetpack library
- https://blog.csdn.net/Alexwll/article/details/83302173
- Android Jetpack组件的优势：
  - 轻松管理应用程序的生命周期
  - 构建可观察的数据对象，以便在基础数据库更改时通知视图
  - 存储在应用程序轮换中未销毁的UI相关数据，在界面重建后恢复数据
  - 轻松的实现SQLite数据库
  - 系统自动调度后台任务的执行，优化使用性能
  - Android Jetpack组件推荐的使用项目架构
    
[[./pic/jetpack.png]]

- 上面架构组件的功能如下：
  - Activity和Fragment负责产品与用户的交互
  - ViewModel作为数据的存储和驱动
  - Resposity负责调度数据的获取
  - Room储存本地序列化的数据
  - Retrofit获取远程数据的数据

* MVVM
** 关于MVC/MVP/MVVM的一些错误认识
- https://juejin.cn/post/6844903938873901064


* LifeCycle
- LifeCycle 是 Jetpack 提供的一个可感知 Activity 或 Fragment 的生命周期 变化的组件。这个组件方便业务针对生命周期的变化做出相应管理和改变，也可以防止业务内存泄漏。首先了解下与 LifeCycle 相关的概念：
- LifeCycle：抽象类，定义了添加和删除观察者（LifecycleObserver）的抽象方法，也定义了生命周期事件Lifecycle.Event ，以及生命周期状态Lifecycle.State；
- Lifecycle.Event ：LifeCycle的内部枚举类，定义了 LifecycleOwner（也就是Activity 或 Fragment ）的生命周期事件，从 ON_CREATE 到 ON_DESTROY；
- Lifecycle.State：LifeCycle的内部枚举类，定义了生命周期状态。
- LifecycleRegistry： LifeCycle 的实现类，管理LifecycleObserver，维护生命周期状态Lifecycle.State，并负责分发 Activity 或 Fragment 的生命周期事件Lifecycle.Event；
- LifecycleObserver：接口，生命周期观察者，它没有任何方法，依赖注解 OnLifecycleEvent；
- FullLifecycleObserver：接口，继承自LifecycleObserver接口，以生命周期方法（onCreate…onDestroy）的形式观察 Activity 或 Fragment 的生命周期；
- LifecycleEventObserver：接口，继承自LifecycleObserver接口，以生命周期事件（ON_CREATE…ON_DESTROY）的形式观察 Activity 或 Fragment 的生命周期；
- LifecycleOwner：接口，关联 Activity 或 Fragment 相关生命周期事件；
- OnLifecycleEvent：注解，主要是声明方法监听 Lifecycle.Event 事件；
- Lifecycling：辅助类，将 LifecycleObserver 转换为适配器 LifecycleEventObserver（FullLifecycleObserverAdapter、SingleGeneratedAdapterObserver、CompositeGeneratedAdaptersObserver、ReflectiveGenericLifecycleObserver），其中ReflectiveGenericLifecycleObserver 处理 以注解OnLifecycleEvent 声明的LifecycleObserver。
- 通常情况下，业务定义的 LifecycleObserver，一般是通过注解 OnLifecycleEvent 来观察 Activity 或 Fragment 相关生命周期，当 ReportFragment 或 Fragment 的生命周期发生变化时候，ReflectiveGenericLifecycleObserver 通过反射的方式调用 LifecycleObserver 的相关含有OnLifecycleEvent 注解的方法。
- 这里 Activity 的生命周期的监听是通过 ReportFragment 实现的，Fragment 的生命周期的监听是通过 它自身生命周期回调实现的。另外，定义在 LifecycleObserver 中声明的生命周期事件，都是在 Activity 或 Fragment 的自身生命周期方法调用之后再调用的。由于 LifecycleRegistry 在 addObserver 的时候，会以一个链表结构的 Map 来存储 LifecycleObserver，所以注册的相关 LifecycleObserver，最后接受处理生命周期事件时，也是按照添加顺序依次触发的。
** Activity 中的 LifeCycle 的流程是：
- 在 Activity 中实现 LifecycleOwner 接口，并创建 LifecycleRegistry 对象；
- 在 ReportFragment 中，当前版本SDK 大于等于 29（也就是安卓10）时，会创建 Activity 的生命周期监听器，否则就使用 ReportFragment 的生命周期作为监听；
- 当 ReportFragment的生命周期发生变化时，通过 ReportFragment 中的 activity 对象，获取 LifecycleOwner对象 ，然后获取 Lifecycle 的实现类 LifecycleRegistry 对象，然后调用它的 handleLifecycleEvent 方法；
- 添加生命周期观察者LifecycleObserver，通过 Activity 获取 Lifecycle的实现类 LifecycleRegistry 对象，调用 addObserver 方法，移除生命周期观察者LifecycleObserver，调用 removeObserver ；
- addObserver 方法会创建一个 ObserverWithState 对象，并将LifecycleObserver对象传递给 ObserverWithState 的构造函数，在这个方法中，通过 Lifecycling 创建一个 实现了 LifecycleEventObserver 的适配器对象，LifecycleObserver对象被包装在LifecycleEventObserver 的适配器对象中；
- LifecycleRegistry 会用一个 链表的 Map 去维护 LifecycleObserver对象 和 ObserverWithState 对象，也会维护 生命周期状态 Lifecycle.State；
- LifecycleRegistry 对象 接受 handleLifecycleEvent 时，就会触发添加的 LifecycleEventObserver 的 onStateChanged方法；然后适配者（FullLifecycleObserverAdapter、SingleGeneratedAdapterObserver、CompositeGeneratedAdaptersObserver、ReflectiveGenericLifecycleObserver）通知LifecycleObserver观察者。
- Fragment 中的 LifeCycle 的流程，除了 生命周期的监听方式不一样以外，其它的和 Activity 一样。Fragment 是在自身的生命周期方法回调中做的处理。
** 使用
- 定义生命周期观察者，使用注解 OnLifecycleEvent 定义生命周期事件：
#+BEGIN_SRC kotlin
open class BizObserver : LifecycleObserver {
    @OnLifecycleEvent(value = Lifecycle.Event.ON_CREATE)
    fun onCreate() {
        Log.d("LogUtils", "onCreate() "); // 可是为什么我打印不出来呢？
    }
    @OnLifecycleEvent(value = Lifecycle.Event.ON_START)
    fun onStart() {
        Log.d("LogUtils", "onStart() "); 
    }
    @OnLifecycleEvent(value = Lifecycle.Event.ON_RESUME)
    fun onResume() {
        Log.d("LogUtils", "onResume() "); 
    }
    @OnLifecycleEvent(value = Lifecycle.Event.ON_PAUSE)
    fun onPause() {
        Log.d("LogUtils", "onPause() "); 
    }
    @OnLifecycleEvent(value = Lifecycle.Event.ON_STOP)
    fun onStop() {
        Log.d("LogUtils", "onStop() "); 
    }
    @OnLifecycleEvent(value = Lifecycle.Event.ON_DESTROY)
    fun onDestroy() {
        Log.d("LogUtils", "onDestroy() "); 
    }
}
#+END_SRC
- 或者 使用 DefaultLifecycleObserver 观察生命周期：
#+BEGIN_SRC kotlin
open class BizObserver : DefaultLifecycleObserver {

    override fun onCreate(owner: LifecycleOwner) {
        Log.d("LogUtils", "onCreate() ");
    }
    override fun onStart(owner: LifecycleOwner) {
        Log.d("LogUtils", "onStart() "); 
    }
    override fun onResume(owner: LifecycleOwner) {
        Log.d("LogUtils", "onResume() "); 
    }
    override fun onPause(owner: LifecycleOwner) {
        Log.d("LogUtils", "onPause() "); 
    }
    override fun onStop(owner: LifecycleOwner) {
        Log.d("LogUtils", "onStop() "); 
    }
    override fun onDestroy(owner: LifecycleOwner) {
        Log.d("LogUtils", "onDestroy() "); 
    }
}
#+END_SRC
- 在 Activity 中添加：
#+BEGIN_SRC kotlin
class YourActivity : BaseAppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        this.lifecycle.addObserver(BizXXX())
    }
}
#+END_SRC
- 在 Fragment 中添加：
#+BEGIN_SRC kotlin
class YourFragment : Fragment() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        this.lifecycle.addObserver(BizXXX())
    }
}
#+END_SRC
- 当不能直接使用 LifeCycle 的时候，也可以间接使用 LifeCycle，比如 数据层也要监听生命周期的变化，那么可以将 Presenter 层定义 为一个 LifeOwner：
#+BEGIN_SRC kotlin
open class BizPresenter : LifecycleObserver, LifecycleOwner {

    private val lifecycleRegistry: LifecycleRegistry = LifecycleRegistry(this)
    override fun getLifecycle(): Lifecycle {
        return lifecycleRegistry
    }

    @OnLifecycleEvent(value = Lifecycle.Event.ON_CREATE)
    fun onCreate() {
        lifecycle.addObserver(BizModel())
        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE)
    }

    @OnLifecycleEvent(value = Lifecycle.Event.ON_START)
    fun onStart() {
        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START)
    }

    @OnLifecycleEvent(value = Lifecycle.Event.ON_RESUME)
    fun onResume() {
        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME)
    }

    @OnLifecycleEvent(value = Lifecycle.Event.ON_PAUSE)
    fun onPause() {
        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    }

    @OnLifecycleEvent(value = Lifecycle.Event.ON_STOP)
    fun onStop() {
        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP)
    }

    @OnLifecycleEvent(value = Lifecycle.Event.ON_DESTROY)
    fun onDestroy() {
        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    }
}
class BizModel : LifecycleObserver {
    @OnLifecycleEvent(value = Lifecycle.Event.ON_CREATE)
    fun onCreate() {
    }
    @OnLifecycleEvent(value = Lifecycle.Event.ON_DESTROY)
    fun onDestroy() {
    }
}
#+END_SRC
- 这种嵌套也是很实用的。其实上面的我自己没有试通，ktl试通了


* Android Jetpack组件Lifecycle基本使用和原理分析
** Lifecycle简介
- 什么是Lifecycle
- Lifecycle提供了可用于构建生命周期感知型组件的类和接口，可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。
- 一句话：可以感知 Activity、Fragment 的生命周期并且可以在相应的回调事件中处理，非常方便
- 这样 Lifecycle 库能有效的避免内存泄漏和解决常见的 Android 生命周期难题！
** Lifecycle基本用法
- 假设我们有一这样的需求：我们想提供一个接口可以感知Activity的生命周期，并且实现回调！用 Lifecycle 是怎么实现的？
*** 定义ILifecycleObserver接口
- 首先我们定义一个接口去实现 LifecycleObserver，然后定义方法，用上OnLifecycleEvent注解。
#+BEGIN_SRC kotlin
interface ILifecycleObserver : LifecycleObserver {
    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    fun onCreate(owner: LifecycleOwner)

    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    fun onStart(owner: LifecycleOwner)
    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    fun onResume(owner: LifecycleOwner)
    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    fun onPause(owner: LifecycleOwner)
    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    fun onStop(owner: LifecycleOwner)
    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    fun onDestroy(owner: LifecycleOwner)
    @OnLifecycleEvent(Lifecycle.Event.ON_ANY)
    fun onLifecycleChanged(owner: LifecycleOwner, event: Lifecycle.Event)
}
#+END_SRC
- 当然你也可以不实现LifecycleObserver而是实现 DefaultLifecycleObserver 接口，Google官方更推荐我们使用 DefaultLifecycleObserver 接口
- 你可以在build.gradle 中依赖，然后就能使用了(在现在新版的2.4.0上运行不通)
#+BEGIN_SRC groovy
def lifecycle_version = "2.2.0"
implementation "androidx.lifecycle:lifecycle-common-java8:$lifecycle_version"
class BaseLifecycle : DefaultLifecycleObserver {
		//处理生命周期回调
}
#+END_SRC
*** 定义ActivityLifecycleObserver类
- 定义ActivityLifecycleObserver类去实现我们定义好的ILifecycleObserver接口
#+BEGIN_SRC kotlin
class ActivityLifecycleObserver : ILifecycleObserver {
    // private val TAG = ActivityLifecycleObserver::class.java.simpleName
    private var TAG = javaClass.simpleName
    
    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    override fun onCreate(owner: LifecycleOwner) {
        Log.d(TAG, "onCreate()")
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    override fun onStart(owner: LifecycleOwner) {
        Log.d(TAG, "onStart()")
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    override fun onResume(owner: LifecycleOwner) {
        Log.d(TAG, "onResume()")
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    override fun onPause(owner: LifecycleOwner) {
        Log.d(TAG, "onPause()")
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    override fun onStop(owner: LifecycleOwner) {
        Log.d(TAG, "onStop()")
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    override fun onDestroy(owner: LifecycleOwner) {
        Log.d(TAG, "onDestroy()")
    }
    override fun onLifecycleChanged(owner: LifecycleOwner, event: Lifecycle.Event) { // <<<<==== 这个方法不能省，会报错
        Log.d(TAG, "onLifecycleChanged(owner = $owner, event = $event)"); 
    }
}
#+END_SRC
- 这个类中，我们在对应的生命周期方法中，打印一句Log，方便测试！这个类就是我们将要使用的类，它是一个观察者，可以观察Activity、Fragment的生命周期
*** 定义BaseActivity
- 在我们的BaseActivity中通过getLifecycle()获取一个Lifecycle，然后把我们的ActivityLifecycleObserver添加进来
#+BEGIN_SRC kotlin
open class BaseActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(ActivityLifecycleObserver())//1
    }
}
#+END_SRC
- Lifecycle是被观察者，通过Add的方式把LifecycleObserver这个观察者添加进来，然后在Activity 执行到对应生命周期的时候通知观察者
- 此时ActivityLifecycleObserver就可以感知Activity的生命周期了，就是这么的神奇
*** 定义LifecycleActivity类
- 让LifecycleActivity**继承 **BaseActivity，然后运行代码，看日志
#+BEGIN_SRC kotlin
class LifecycleActivity : BaseActivity()
#+END_SRC
- LifecycleActivity来作为我们默认启动的Activity，启动LifecycleActivity然后关闭页面，来查看生命周期的日志！
*** 结果日志
    #+BEGIN_SRC kotlin
D/ActivityLifecycleObserver: onCreate()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_CREATE)
D/ActivityLifecycleObserver: onStart()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_START)
D/ActivityLifecycleObserver: onResume()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_RESUME)
D/ActivityLifecycleObserver: onPause()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_PAUSE)
D/ActivityLifecycleObserver: onStop()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_STOP)
D/ActivityLifecycleObserver: onDestroy()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_DESTROY)
D/ActivityLifecycleObserver: onCreate()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_CREATE)
D/ActivityLifecycleObserver: onStart()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_START)
D/ActivityLifecycleObserver: onResume()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_RESUME)
    #+END_SRC
- 每当LifecycleActivity发生了对应的生命周期改变，ActivityLifecycleObserver就会执行对应事件注解的方法，其中onLifecycleChanged的注解是**@OnLifecycleEvent(Lifecycle.Event.ON_ANY)**所以每次都会调用
- 总结上面的现象：
- 我们声明了一个ILifecycleObserver接口，并在方法中加入了 @OnLifecycleEvent(Lifecycle.Event.XXX)注解，在BaseActivity的onCreate方法中通过lifecycle.addObserver(ActivityLifecycleObserver())这行代码，然后就可以在 ActivityLifecycleObserver 对应的方法中实现对具体Activity的生命周期回调了，好神奇！为什么会是这样呢？
** 抛出问题
- Lifecycle是怎样感知生命周期的？
- Lifecycle是如何处理生命周期的？
- LifecycleObserver的方法是怎么回调的呢？
- 为什么LifecycleObserver可以感知到Activity的生命周期
- 下面就一步一步的具体分析，阅读源码，从源码中寻找答案
** Lifecycle的原理分析的前置准备
- 在分析 Lifecycle 源码之前，我们必须先对几个重要的类有感性的认识，方便下面看源码！
*** LifecycleOwner
    #+BEGIN_SRC java
public interface LifecycleOwner {
    /**
     * @return The lifecycle of the provider.
     */
    @NonNull
    Lifecycle getLifecycle();
}
    #+END_SRC
- 生命周期持有者，返回一个Lifecycle对象，如果你使用的是 AndroidX（也属于 Jetpack 一部分）在这Activity 、Fragment 两个类中，默认实现了 LifecycleOwner 接口
#+BEGIN_SRC java
public class ComponentActivity extends androidx.core.app.ComponentActivity implements LifecycleOwner,XXX {
	private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);
    public Lifecycle getLifecycle() {
        return mLifecycleRegistry;
    }
}
public class Fragment implements LifecycleOwner,XXX {
	private final LifecycleRegistry mLifecycleRegistry;
    public Fragment() {
        initLifecycle();
    }
    private void initLifecycle() {
        mLifecycleRegistry = new LifecycleRegistry(this);
        //....
    }
    public Lifecycle getLifecycle() {
        return mLifecycleRegistry;
    }
}
#+END_SRC
- 可以看到我们 Activity 和 Fragment 中默认实现了
- 可以看到在 ComponentActivity 和 Fragment类默认实现了 LifecycleOwner 接口，并在中 getLifecycle()方法返回的是LifecycleRegistry对象，此时 Activity 和 Fragment类中分别持有了 Lifecycle
- 我们先看下 Lifecycle 类是什么
*** Lifecycle
    #+BEGIN_SRC java
public abstract class Lifecycle {
    @MainThread
    public abstract void addObserver(@NonNull LifecycleObserver observer);
    @MainThread
    public abstract void removeObserver(@NonNull LifecycleObserver observer);
    @MainThread
    @NonNull
    public abstract State getCurrentState();
    public enum Event {
    }
    public enum State {
    }
}
    #+END_SRC
- 在Lifecycle类中定义了添加观察者和移除观察者的方法，并定义了两个枚举类，这两个类等一下再具体说
- LifecycleRegistry类是对Lifecycle这个抽象类的具体实现，可以处理多个观察者，如果你自定义 LifecycleOwner可以直接使用它。
- 说完了被观察者，接下来看下观察者LifecycleObserver
*** LifecycleObserver
    #+BEGIN_SRC java
public interface LifecycleObserver {
}
    #+END_SRC
- 就是一个简单的接口，这个接口只是来标志这个是对Lifecycle的观察者，内部没有任何方法，全部都依赖于OnLifecycleEvent注解
#+BEGIN_SRC java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface OnLifecycleEvent {
    Lifecycle.Event value();
}
#+END_SRC
- 注解的值是一个 Lifecycle.Event 也就是 4.2小节没有看的那两个枚举中的一个，接下来去看下Lifecycle中的两个枚举类。
*** Lifecycle.Event和Lifecycle.State
    #+BEGIN_SRC java
public abstract class Lifecycle {
    public enum Event {
        ON_CREATE,
        ON_START,
        ON_RESUME,
        ON_PAUSE,
        ON_STOP,
        ON_DESTROY,
        ON_ANY
    }
    public enum State {
        DESTROYED,
        INITIALIZED,
        CREATED,
        STARTED,
        RESUMED;
        public boolean isAtLeast(@NonNull State state) {
            return compareTo(state) >= 0;
        }
    }
}
    #+END_SRC
- Event：定一个一些枚举常量，和 Activity、Fragment 的生命周期是一一对应的，可以响应其生命周期，其中多了一个ON_ANY，它是可以匹配任何事件的，Event 的使用是和 LifecycleObserver 配合使用的，
#+BEGIN_SRC java
class TestObserver implements LifecycleObserver {
  @OnLifecycleEvent(ON_STOP)
  void onStopped() {}
}
#+END_SRC
- State：当前Lifecycle的自己的目前的状态，它是和Event配合使用的
- Event和State之间的关系
  
[[./pic/stateEvent.jpg]]

*** 总结
- LifecycleOwner：可获取Lifecycle的接口，可以再 Activity、Fragment生命周期改变时，通过LifecycleRegistry类处理对应的生命周期事件，并通知 LifecycleObserver这个观察者
- Lifecycle：是被观察者，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。
- LifecycleObserver：观察者，可以通过被LifecycleRegistry类通过 addObserver(LifecycleObserver o)方法注册,被注册后，LifecycleObserver便可以观察到LifecycleOwner对应的生命周期事件
- Lifecycle.Event：分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。
- Lifecycle.State：Lifecycle组件的当前状态。
- 了解上面的基本内容，就进行具体的源码分析，通过看源码，就能知道整个流程了。
** Lifecycle的源码解析
*** 分析的入口BaseActivity
- 在基类BaseActivity中的一行代码就能实现对应生命周期的回调
    #+BEGIN_SRC kotlin
open class BaseActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(ActivityLifecycleObserver())//1
    }
}
    #+END_SRC
- 我们先看下getLifecycle() 方法，然后在看addObserver(ActivityLifecycleObserver())的内容，注意这时候分成两步了，我们先看getLifecycle()
- 我们点进去这个getLifecycle()方法
*** ComponentActivity 类
- 然后我们来到了ComponentActivity中，代码如下
#+BEGIN_SRC java
public class ComponentActivity extends xxx implements LifecycleOwner,xxx {//1
	private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);//2
	@Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ReportFragment.injectIfNeededIn(this);//4
    }
    public Lifecycle getLifecycle() {
        return mLifecycleRegistry;//3
    }
}
#+END_SRC
- 是不是很熟悉因为，之前我们在 4.1 小节已经看到过了，这里看下重点，在onCreate方法中有一行代码ReportFragment.injectIfNeededIn(this);
- **注释4：**在onCreate方法中，看到初始化了一个ReportFragment，接下来看一下ReportFragment的源码
*** ReportFragment 类
    #+BEGIN_SRC java
public class ReportFragment extends Fragment {
    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        dispatchCreate(mProcessListener);
        dispatch(Lifecycle.Event.ON_CREATE);·
    }
    @Override
    public void onStart() {
        super.onStart();
        dispatchStart(mProcessListener);
        dispatch(Lifecycle.Event.ON_START);
    }
    @Override
    public void onResume() {
        super.onResume();
        dispatchResume(mProcessListener);
        dispatch(Lifecycle.Event.ON_RESUME);
    }
    @Override
    public void onPause() {
        super.onPause();
        dispatch(Lifecycle.Event.ON_PAUSE);
    }
    @Override
    public void onStop() {
        super.onStop();
        dispatch(Lifecycle.Event.ON_STOP);
    }
    @Override
    public void onDestroy() {
        super.onDestroy();
        dispatch(Lifecycle.Event.ON_DESTROY);
        // just want to be sure that we won't leak reference to an activity
        mProcessListener = null;
    }
    private void dispatch(Lifecycle.Event event) {
        Activity activity = getActivity();
        if (activity instanceof LifecycleRegistryOwner) { // 1
            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);
            return;
        }
        if (activity instanceof LifecycleOwner) { // 2
            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();
            if (lifecycle instanceof LifecycleRegistry) 
                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);
        }
    }
}
    #+END_SRC
- 可以看到在 ReportFragment 中的各个生命周期都调用了dispatch(Lifecycle.Event event) 方法，传递了不同的Event的值，这个就是在Activity、Fragment的各个生命周期回调时，Lifecycle 所要处理的生命周期方法。
- 在**dispatch(Lifecycle.Event event)**方法中最终调用了((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);方法
- 看到这儿，还记得咱们在第 3 节的疑问吗？到这儿就可以解答前两个问题了
  - 1.Lifecycle是怎样感知生命周期的？
    - 就是在ReportFragment中的各个生命周期都调用了dispatch(Lifecycle.Event event) 方法，传递了不同的Event的值
  - 2.Lifecycle是如何处理生命周期的？
    - 通过调用了((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);方法，也就是LifecycleRegistry 类来处理这些生命周期。
- 此时，就应该看 LifecycleRegistry 的 handleLifecycleEvent 方法中的代码了
*** LifecycleRegistry 的 handleLifecycleEvent 方法
    #+BEGIN_SRC java
//LifecycleRegistry.java
public void handleLifecycleEvent(@NonNull Lifecycle.Event event) {
    State next = getStateAfter(event);
    moveToState(next);
}
    #+END_SRC
- 根据当前Lifecycle.Event的值，其实也就是 Activity、Fragment 生命周期回调的值，来获取下一个 Lifecycle.State 的状态，也就是 Lifecycle 将要到什么状态
#+BEGIN_SRC java
//LifecycleRegistry.java
static State getStateAfter(Event event) {
    switch (event) {
        case ON_CREATE:
        case ON_STOP:
            return CREATED;
        case ON_START:
        case ON_PAUSE:
            return STARTED;
        case ON_RESUME:
            return RESUMED;
        case ON_DESTROY:
            return DESTROYED;
        case ON_ANY:
            break;
    }
    throw new IllegalArgumentException("Unexpected event value " + event);
}
#+END_SRC
- 上面代码结合这个图看，使用效果更加
  
[[./pic/stateEvent.jpg]]

- 不同的 Lifecycle.Event 的生命周期状态对 Lifecycle.State 的当前状态的取值。
- 继续跟代码，看下当到下一个状态时，要发生什么事情
#+BEGIN_SRC java
//LifecycleRegistry.java
private void moveToState(State next) {
    if (mState == next) 
        return;
    mState = next;
    if (mHandlingEvent || mAddingObserverCounter != 0) {
        mNewEventOccurred = true;
        return;
    }
    mHandlingEvent = true;
    sync(); // 1 <<<<<======
    mHandlingEvent = false;
}
#+END_SRC
***** 注释1： sync()方法
- 然后看 LifecycleRegistry 的 sync 方法
#+BEGIN_SRC java
//LifecycleRegistry.java
private void sync() {
    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();
    if (lifecycleOwner == null) {
        throw new IllegalStateException("LifecycleOwner of this LifecycleRegistry is already"
                + "garbage collected. It is too late to change lifecycle state.");
    }
    while (!isSynced()) {
        mNewEventOccurred = false;
        // no need to check eldest for nullability, because isSynced does it for us.
        if (mState.compareTo(mObserverMap.eldest().getValue().mState) < 0) 
            backwardPass(lifecycleOwner); // 1
        Entry<LifecycleObserver, ObserverWithState> newest = mObserverMap.newest();
        if (!mNewEventOccurred && newest != null && mState.compareTo(newest.getValue().mState) > 0) 
            forwardPass(lifecycleOwner);  // 2
    }
    mNewEventOccurred = false;
}
#+END_SRC
- 如果没有同步过，会比较mState当前的状态和mObserverMap中的eldest和newest的状态做对比，看是往前还是往后；比如mState由STARTED到RESUMED是状态向前，反过来就是状态向后。这个是和 Lifecycle 生命周期有关系，但不是一个东西，具体的看上面贴的图，一目了然！
***** 注释2：往后这里看下往后的代码forwardPass(lifecycleOwner);
- 然后看 LifecycleRegistry 的 forwardPass 方法
#+BEGIN_SRC java
//LifecycleRegistry.java
private void forwardPass(LifecycleOwner lifecycleOwner) {
    Iterator<Entry<LifecycleObserver, ObserverWithState>> ascendingIterator = 
            mObserverMap.iteratorWithAdditions();
    while (ascendingIterator.hasNext() && !mNewEventOccurred) {
        Entry<LifecycleObserver, ObserverWithState> entry = ascendingIterator.next();
        ObserverWithState observer = entry.getValue()； // 1: 获取 ObserverWithState 实例
        while ((observer.mState.compareTo(mState) < 0 && !mNewEventOccurred
                && mObserverMap.contains(entry.getKey()))) {
            pushParentState(observer.mState);
            observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState)); // 2: 调用 ObserverWithState 的 dispatchEvent 方法
            popParentState();
        }
    }
}
#+END_SRC
- 注释1：获取 ObserverWithState 实例
- 注释2：调用 ObserverWithState 的 dispatchEvent 方法

** ObserverWithState
- 这个类名很直接，观察者并且带着 State，
#+BEGIN_SRC java
//ObserverWithState.java
static class ObserverWithState {
    State mState;
    LifecycleEventObserver mLifecycleObserver;
    ObserverWithState(LifecycleObserver observer, State initialState) {
        mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);//1
        mState = initialState;
    }
    void dispatchEvent(LifecycleOwner owner, Event event) {
        State newState = getStateAfter(event);
        mState = min(mState, newState);
        mLifecycleObserver.onStateChanged(owner, event);//2
        mState = newState;
    }
}
#+END_SRC
- 在看dispatchEvent方法之前，先看下构造，ObserverWithState 是怎么初始化的？这里提一句，是在Lifecycle.addObserver(@NonNull LifecycleObserver observer);方法时候初始化的。
- 也就是 lifecycle.addObserver(ActivityLifecycleObserver())
#+BEGIN_SRC kotlin
open class BaseActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(ActivityLifecycleObserver())
    }
}
#+END_SRC
- 在这里初始化的。
- ObserverWithState 内部包括了 State 和 LifecycleEventObserver，LifecycleEventObserver 是一个接口，它继承了 LifecycleObserver 接口。
  - 注释1：mLifecycleObserver这个的获取的实例其实是ReflectiveGenericLifecycleObserver，具体的点进去看一眼就明白了，我就不贴代码了，但是得注意在实例化 ReflectiveGenericLifecycleObserver(object);时候把LifecycleObserver，传入ReflectiveGenericLifecycleObserver的构造中了，此时ReflectiveGenericLifecycleObserver持有LifecycleObserver的实例
  - 注释2：关键代码 mLifecycleObserver.onStateChanged(owner, event)，这里其实调用的是ReflectiveGenericLifecycleObserver的onStateChanged方法
- 接下来看下 ReflectiveGenericLifecycleObserver 的 onStateChanged 方法

** ReflectiveGenericLifecycleObserver
   #+BEGIN_SRC java
//ReflectiveGenericLifecycleObserver.java
class ReflectiveGenericLifecycleObserver implements LifecycleEventObserver {
    private final Object mWrapped;
    private final CallbackInfo mInfo;
    ReflectiveGenericLifecycleObserver(Object wrapped) {
        mWrapped = wrapped;//LifecycleObserver的实例
        mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());//1
    }
    @Override
    public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Event event) {
        mInfo.invokeCallbacks(source, event, mWrapped);//2
    }
}
   #+END_SRC
- mWrapped其实是LifecycleObserver的实例
- 注释 1：接下来看mInfo的初始化过程，这个是最关键的代码了
- 注意注意注意，此时我们要兵分两路先看注释 1 的代码，此时注释 2 的代码是被回调的代码

** ClassesInfoCache 的 getInfo 方法
   #+BEGIN_SRC java
//ClassesInfoCache.java
CallbackInfo getInfo(Class<?> klass) {
    CallbackInfo existing = mCallbackMap.get(klass);
    if (existing != null) {
        return existing;
    }
    existing = createInfo(klass, null);//1
    return existing;
}
   #+END_SRC
- 这个klass是LifecycleObserver的字节码文件对象（LifecycleObserver.class）字节码？反射的味道，没错继续看下去马上就有结果了。
#+BEGIN_SRC java
private CallbackInfo createInfo(Class<?> klass, @Nullable Method[] declaredMethods) {
    // 1: 获取LifecycleObserver.class 声明的方法，也即是我们例子中ILifecycleObserver接口中声明的方法
    Method[] methods = declaredMethods != null ? declaredMethods : getDeclaredMethods(klass);
    boolean hasLifecycleMethods = false;
    for (Method method : methods) {
        // 2: 遍历方法，获取方法上声明的OnLifecycleEvent注解
        OnLifecycleEvent annotation = method.getAnnotation(OnLifecycleEvent.class);
        if (annotation == null) continue;
        hasLifecycleMethods = true;
      
        Class<?>[] params = method.getParameterTypes();
        int callType = CALL_TYPE_NO_ARG;
        if (params.length > 0) {
            callType = CALL_TYPE_PROVIDER;
            if (!params[0].isAssignableFrom(LifecycleOwner.class)) 
                throw new IllegalArgumentException("invalid parameter type. Must be one and instanceof LifecycleOwner");
        }
        // 3: 获取OnLifecycleEvent注解上的value
        Lifecycle.Event event = annotation.value();
        // 4: 给callType = CALL_TYPE_PROVIDER_WITH_EVENT 赋值
        if (params.length > 1) {
            callType = CALL_TYPE_PROVIDER_WITH_EVENT;
            if (!params[1].isAssignableFrom(Lifecycle.Event.class)) 
                throw new IllegalArgumentException("invalid parameter type. second arg must be an event");
            if (event != Lifecycle.Event.ON_ANY) 
                throw new IllegalArgumentException("Second arg is supported only for ON_ANY value");
        }
        if (params.length > 2) 
            throw new IllegalArgumentException("cannot have more than 2 params");
        // 5: 把callType和当前的method 存储到 MethodReference 中，方便接下来取用
        MethodReference methodReference = new MethodReference(callType, method);
        verifyAndPutHandler(handlerToEvent, methodReference, event, klass);
    }
    CallbackInfo info = new CallbackInfo(handlerToEvent);
    mCallbackMap.put(klass, info);
    mHasLifecycleMethods.put(klass, hasLifecycleMethods);
    return info;
}
#+END_SRC
- 上面代码比较长，但都有用其实就是反射获取方法获取注解值的过程，我们挨个看
- 注释1：获取LifecycleObserver.class 声明的方法，也即是我们例子中ILifecycleObserver接口中声明的方法
- 注释2：遍历方法，获取方法上声明的OnLifecycleEvent注解
- 注释3：获取OnLifecycleEvent注解上的value
- 注释4：给callType = CALL_TYPE_PROVIDER_WITH_EVENT 赋值
- 注释5：把callType和当前的method 存储到 MethodReference 中，方便接下来取用
- 看一下MethodReference中的代码
#+BEGIN_SRC java
//MethodReference.java
static class MethodReference {
    final int mCallType;
    final Method mMethod;
    MethodReference(int callType, Method method) {
        mCallType = callType;
        mMethod = method;
        mMethod.setAccessible(true);
    }
}
#+END_SRC
- 好的，以上的mInfo 赋值的问题就看完了
- 当初在第 7 节在看注释 1 的代码是兵分两路了，现在继续看第 7 节注释 2 的代码吧
- 也即是就是mInfo的invokeCallbacks方法
- 继续看ClassesInfoCache的invokeCallbacks方法
- 点进去来到了 ClassesInfoCache 的 invokeCallbacks方法中
#+BEGIN_SRC java
//ClassesInfoCache.java
void invokeCallbacks(LifecycleOwner source, Lifecycle.Event event, Object target) {
    invokeMethodsForEvent(mEventToHandlers.get(event), source, event, target);
    invokeMethodsForEvent(mEventToHandlers.get(Lifecycle.Event.ON_ANY), source, event,
            target);//ON_ANY也会调用
}
private static void invokeMethodsForEvent(List<MethodReference> handlers,
        LifecycleOwner source, Lifecycle.Event event, Object mWrapped) {
    if (handlers != null) {
        for (int i = handlers.size() - 1; i >= 0; i--) {
            handlers.get(i).invokeCallback(source, event, mWrapped);//1
        }
    }
}
#+END_SRC
- 注释 1：继续看MethodReference 的invokeCallback方法
#+BEGIN_SRC java
//MethodReference.java
void invokeCallback(LifecycleOwner source, Lifecycle.Event event, Object target) {
    //noinspection TryWithIdenticalCatches
    try {
        switch (mCallType) {
            case CALL_TYPE_NO_ARG:
                mMethod.invoke(target);
                break;
            case CALL_TYPE_PROVIDER:
                mMethod.invoke(target, source);
                break;
            case CALL_TYPE_PROVIDER_WITH_EVENT: // 1
                mMethod.invoke(target, source, event);
                break;
        }
    } catch (InvocationTargetException e) {
        throw new RuntimeException("Failed to call observer method", e.getCause());
    } catch (IllegalAccessException e) {
        throw new RuntimeException(e);
    }
}
#+END_SRC
- 看到最后是用反射调用了mMethod.invoke(target);这里的target就是LifecycleObserver之前解释过了
- mCallType和mMethod的值分别是什么呢？就是在前面初始化mInfo存的值，再看下源码
#+BEGIN_SRC java
static class MethodReference {
    final int mCallType;
    final Method mMethod;
    MethodReference(int callType, Method method) {
        mCallType = callType;
        mMethod = method;
        mMethod.setAccessible(true);
    }
    void invokeCallback(LifecycleOwner source, Lifecycle.Event event, Object target) {
        // noinspection TryWithIdenticalCatches
        try {
            switch (mCallType) {
                case CALL_TYPE_NO_ARG:
                    mMethod.invoke(target);
                    break;
                case CALL_TYPE_PROVIDER:
                    mMethod.invoke(target, source);
                    break;
                case CALL_TYPE_PROVIDER_WITH_EVENT:
                    mMethod.invoke(target, source, event);
                    break;
            }
        } catch (InvocationTargetException e) {
            throw new RuntimeException("Failed to call observer method", e.getCause());
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
}
#+END_SRC
由前面分析可以知道mCallType = CALL_TYPE_PROVIDER_WITH_EVENT，mMethod就是当时遍历时当前的方法
由于之前通过Map存储过，所以invokeCallback会被遍历调用，最终会反射调用对方法和注解。
当然其他mCallType的值也会被反射调用
** 总结:在来回顾当初抛出的问题
- 1.Lifecycle是怎样感知生命周期的？
  - 就是在ReportFragment中的各个生命周期都调用了dispatch(Lifecycle.Event event) 方法，传递了不同的Event的值
- 2.Lifecycle是如何处理生命周期的？
  - 通过调用了((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);方法，也就是LifecycleRegistry 类来处理这些生命周期。
- 3.LifecycleObserver的方法是怎么回调是的呢？
  - LifecycleRegistry 的 handleLifecycleEvent方法，然后会通过层层调用最后通过反射到LifecycleObserver方法上的@OnLifecycleEvent(Lifecycle.Event.XXX)注解值，来调用对应的方法
- 4.为什么LifecycleObserver可以感知到Activity的生命周期
  - LifecycleRegistry调用handleLifecycleEvent方法时会传递Event类型，然后会通过层层调用，最后是通过反射获取注解的值，到LifecycleObserver方法上的@OnLifecycleEvent(Lifecycle.Event.XXX)注解上对应的Event的值，注意这个值是和Activity/Fragment的生命周期的一一对应的，所以就可以感知Activity、Fragment的生命周期了。

* Android Jetpack组件LiveData基本使用和原理分析
- LiveData一般是和 ViewModel 配合使用的，但是本文就以单独使用 LiveData 作为例子单独使用，这样可以只关注 LiveData 而不被其他所干扰。
- 本文整体流程：首先要知道什么是 LiveData，然后演示一个例子，来看看 LiveData 是怎么使用的，接着提出问题为什么是这样的，最后读源码来解释原因！
- LiveData 的源码比较简单，底层依赖了 Lifecycle，所以懂 Lifecycle 的源码是关键，我之前写过一篇
- Android Jetpack组件Lifecycle基本使用和原理分析 最好是先看这篇文章，才能更好的理解 LiveData。
- 什么是 LiveData
  - LiveData是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。
- LiveData基础使用的例子
  - 这个例子，是点击按钮通过 LiveData 来更新 TextView 的内容
#+BEGIN_SRC kotlin
class MainActivity : BaseActivity() {
    private lateinit var binding: ActivityMainBinding

    private val mContent = MutableLiveData<String>()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
       
        binding.btnUpdate.setOnClickListener {
            mContent.value = "最新值是:Update"
        }
        mContent.observe(this, Observer { content -> binding.tvContent.text = content })
    }
}
#+END_SRC
- 布局也很简单，一个文本框，一个按钮
#+BEGIN_SRC xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <TextView
        android:id="@+id/tvContent"
        android:layout_width="0dp"
        android:text="Hello World"
        android:layout_height="wrap_content"
        android:textColor="#f00"
        android:gravity="center"
        android:textSize="24sp"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <Button
        android:id="@+id/btnUpdate"
        android:layout_width="wrap_content"
        android:text="Update"
        android:padding="5dp"
        android:layout_height="wrap_content"
        android:textColor="#000"
        android:textSize="18sp"
        android:layout_marginTop="20dp"
        android:textAllCaps="false"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/tvContent" />
</androidx.constraintlayout.widget.ConstraintLayout>
#+END_SRC
- 默认TextView展示的是： Hello World，点击按钮后展示的是：“最新值是:Update” 。这个就是LiveData 的简单使用。
** 抛出问题
- 为什么LiveData的工作机制是这样的
- LiveData 是怎么回调的？
- LiveData 为什么可以感知生命周期？
- LiveData 可以感知生命周期，有什么用，或者说有什么优势？
- LiveData 为什么只会将更新通知给活跃的观察者。非活跃观察者不会收到更改通知？
- LiveData此外还提供了observerForever()方法，所有生命周期事件都能通知到，怎么做到的？
- 解析来通过分析源码，来寻找答案。文章最后我会解释这些问题的，做一个统一的总结。
** 源码分析前的准备工作
- 我需要了解几个类，来对接下来的源码分析做一个铺垫。
- 先看之前例子中的代码
#+BEGIN_SRC kotlin
class LiveDataActivity : BaseActivity() {
    private val mContent = MutableLiveData<String>()
  	
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
				
        mContent.observe(this, Observer { content ->
            tvContent.text = content
        })
    }
}
#+END_SRC
- 只贴出了主要代码，我们来看下主要的类以及方法，方法参数
- 声明了一个MutableLiveData对象
- 调用了MutableLiveData的observe方法
- observe方法中 传入 this 和 Observer
- this 指的是LiveDataActivity对象，其实一个是一个LifecycleOwner。Observer是一个接口
- 来分别看下具体内容。
*** MutableLiveData类
    #+BEGIN_SRC java
public class MutableLiveData<T> extends LiveData<T> {
    public MutableLiveData(T value) {
        super(value);
    }
    public MutableLiveData() {
        super();
    }
    @Override
    public void postValue(T value) {
        super.postValue(value);
    }
    @Override
    public void setValue(T value) {
        super.setValue(value);
    }
}
    #+END_SRC
- 继承了LiveData是一个可变的LiveData
- 是一个被观察者，是一个数据持有者
- 提供了 setValue 和 postValue方法，其中postValue可以在子线程调用
- postValue方法，我们下面会具体分析
*** MutableLiveData的observe方法参数中的 this
- 当前 Activity 的对象，本质上是一个LifecycleOwner 我在这篇 Android Jetpack组件Lifecycle基本使用和原理分析中有分析过，它的源码。
#+BEGIN_SRC java
public interface LifecycleOwner {
    @NonNull
    Lifecycle getLifecycle();
}
#+END_SRC
*** MutableLiveData的observe方法参数中的 Observer
    #+BEGIN_SRC java
public interface Observer<T> {
    /**
     * Called when the data is changed.
     * @param t  The new data
     */
    void onChanged(T t);
}
    #+END_SRC
- Observer是一个观察者
- Observer中有一个回调方法，在 LiveData 数据改变时会回调此方法
- 通过以上简单分析，我们大概了解了这个几个类的作用，接下来我们一步一步看源码，来从源码中解决我们在第 3 节提出的问题。
** 源码分析
- 首先我们上面示例中的 LiveData.observe()方法开始。
#+BEGIN_SRC kotlin
//LiveDataActivity.kt
private val mContent = MutableLiveData<String>()
mContent.observe(this, Observer { content ->
    tvContent.text = content
})
#+END_SRC
- 我们点进observe方法中去它的源码。
** LiveData类
- 在LiveData的observe方法中
#+BEGIN_SRC kotlin
//LiveData.java
@MainThread
public void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {
    assertMainThread("observe");
  	// 1
    if (owner.getLifecycle().getCurrentState() == DESTROYED) 
        //  ignore
        return;
  	// 2
    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);
  	// 3
    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);
  	// 4
    if (existing != null && !existing.isAttachedTo(owner)) 
        throw new IllegalArgumentException("Cannot add the same observer" + " with different lifecycles");
    if (existing != null) return;
  	// 5
    owner.getLifecycle().addObserver(wrapper);
}
#+END_SRC
- 注释 1：首先会通过LifecycleOwner获取Lifecycle对象然后获取Lifecycle 的State，如果是DESTROYED直接 return 了。忽略这次订阅
- 注释 2 ：把LifecycleOwner和Observer包装成LifecycleBoundObserver对象，至于为什么包装成这个对象，我们下面具体讲，而且这个是重点。
- 注释 3：把观察者存到 Map 中
- 注释 4：之前添加过LifecycleBoundObserver，并且LifecycleOwner不是同一个，就抛异常
- 注释 5：通过Lifecycle和添加 LifecycleBoundObserver观察者，形成订阅关系
- 总结：
  - 到现在，我们知道了LiveData的observe方法中会判断 Lifecycle 的生命周期，会把LifecycleOwner和Observer包装成LifecycleBoundObserver对象，然后 Lifecycle().addObserver(wrapper) Lifecycle 这个被观察者会在合适的实际通知观察者的回调方法。
- 等等，什么时候通知，咋通知的呢？这个具体流程是啥呢？
- 回个神，我再贴下开始的示例代码。
#+BEGIN_SRC kotlin
class LiveDataActivity : BaseActivity() {
    private val mContent = MutableLiveData<String>()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_live_data)
				// 1
        btnUpdate.setOnClickListener {
            mContent.value = "最新值是:Update"
        }
        mContent.observe(this, Observer { content ->
            tvContent.text = content
        })
    }
}
#+END_SRC
- 在点击按钮的时候 LiveData会调用setValue方法，来更新最新的值，这时候我们的观察者Observer就会收到回调，来更新 TextView。
- 所以接下来我们先看下 LiveData的setValue方法做了什么，LiveData还有一个postValue方法，我们也一并分析一下。
** LiveData的setValue方法和postValue方法
*** 先看setValue方法
    #+BEGIN_SRC java
// LiveData.java
@MainThread
protected void setValue(T value) {
    assertMainThread("setValue");
    mVersion++;
    mData = value;
    dispatchingValue(null);// 1
}
    #+END_SRC
- 调用了dispatchingValue方法，继续跟代码
#+BEGIN_SRC java
// LiveData.java
void dispatchingValue(@Nullable ObserverWrapper initiator) {
    if (mDispatchingValue) {
        mDispatchInvalidated = true;
        return;
    }
    mDispatchingValue = true;
    do {
        mDispatchInvalidated = false;
        if (initiator != null) {
          	// 1
            considerNotify(initiator);
            initiator = null;
        } else {
            for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =
                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {
              	// 2
                considerNotify(iterator.next().getValue());
                if (mDispatchInvalidated) break;
            }
        }
    } while (mDispatchInvalidated);
    mDispatchingValue = false;
}
#+END_SRC
- 不管如何判断，都是调用了considerNotify()方法
#+BEGIN_SRC java
// LiveData.java
private void considerNotify(ObserverWrapper observer) {
    if (!observer.mActive) return;
    if (!observer.shouldBeActive()) {
        observer.activeStateChanged(false);
        return;
    }
    if (observer.mLastVersion >= mVersion) return;
    observer.mLastVersion = mVersion;
    observer.mObserver.onChanged((T) mData);// 1
}
#+END_SRC
- 最终调用了observer.mObserver.onChanged((T) mData)方法，这个observer.mObserver就是我们的 Observer接口，然后调用它的onChanged方法。
- 到现在整个被观察者数据更新通知观察者这个流程就通了。
*** 然后再看下postValue方法
- 子线程发送消息通知更新 UI，嗯？Handler 的味道，我们具体看下代码
#+BEGIN_SRC java
// LiveData.java
protected void postValue(T value) {
    boolean postTask;
    synchronized (mDataLock) {
        postTask = mPendingData == NOT_SET;
        mPendingData = value;
    }
    if (!postTask) return;
    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);// 1
}
#+END_SRC
- 可以看到一行关键代码ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);
- 点 **postToMainThread **方法进去看下
#+BEGIN_SRC java
// ArchTaskExecutor.java
private TaskExecutor mDelegate;
@Override
public void postToMainThread(Runnable runnable) {
    mDelegate.postToMainThread(runnable);// 1
}
#+END_SRC
- 看到 mDelegate 是 TaskExecutor对象，现在目标是看下 mDelegate 的具体实例对象是谁
#+BEGIN_SRC java
// ArchTaskExecutor.java
private ArchTaskExecutor() {
    mDefaultTaskExecutor = new DefaultTaskExecutor();
    mDelegate = mDefaultTaskExecutor;// 1
}
#+END_SRC
- 好的，目前的重点是看下DefaultTaskExecutor是个啥，然后看它的postToMainThread方法
#+BEGIN_SRC java
// DefaultTaskExecutor.java
private volatile Handler mMainHandler;
@Override
public void postToMainThread(Runnable runnable) {
    if (mMainHandler == null)
        synchronized (mLock) 
            if (mMainHandler == null) 
                mMainHandler = createAsync(Looper.getMainLooper());// 1
    mMainHandler.post(runnable);// 2
}
#+END_SRC
- 注释 1：实例了一个 Handler 对象，注意构造参数 **Looper.getMainLooper()**是主线的 Looper。那么就可做到线程切换了。
- 注释 2：调用post 方法。
- 下面看下这个 Runnable
#+BEGIN_SRC java
ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);
#+END_SRC
- 这里面的方法参数是mPostValueRunnable是个 Runnable，我们看下代码
#+BEGIN_SRC java
// LiveData.java
private final Runnable mPostValueRunnable = new Runnable() {
    @SuppressWarnings("unchecked")
    @Override
    public void run() {
        Object newValue;
        synchronized (mDataLock) {
            newValue = mPendingData;
            mPendingData = NOT_SET;
        }
        setValue((T) newValue);// 1
    }
};
#+END_SRC
- **注意：**postValue方法其实最终调用也是setValue方法，然后和setValue方法走的流程就是一样的了，这个上面已经分析过了。详情请看 7.1 小节
- 但是我们还不知道ObserverWrapper是啥，好那么接下来，我们的重点来了
- 我们要详细看一下LifecycleBoundObserver类了，它包装了LifecycleOwner和Observer，这就是接下来的重点内容了。
** LifecycleBoundObserver类
- 再贴下一下代码，当LiveData调用observe方法时
#+BEGIN_SRC java
// LiveData.java
@MainThread
public void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {
    assertMainThread("observe");
    if (owner.getLifecycle().getCurrentState() == DESTROYED) 
        return; //  ignore
  	// 1
    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);
    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);
    if (existing != null && !existing.isAttachedTo(owner)) 
        throw new IllegalArgumentException("Cannot add the same observer" + " with different lifecycles");
    if (existing != null) return;
    owner.getLifecycle().addObserver(wrapper);
}
#+END_SRC
- 注释 1 ：用LifecycleBoundObserver对LifecycleOwner 和 Observer进行了包装
*** 来看下LifecycleBoundObserver类，它是LiveData的内部类
    #+BEGIN_SRC java
// LiveData.java
class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver {
    @NonNull
    final LifecycleOwner mOwner;
    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<? super T> observer) {
        super(observer);
        mOwner = owner;
    }
}
    #+END_SRC
- 两个参数，一个 owner被成员变量mOwner存储，observer参数被ObserverWrapper的 mObserver存储。
- LifecycleEventObserver是LifecycleObserver的子接口里面有一个onStateChanged方法，这个方法会在 Activity、Fragment 生命周期回调时调用，如果这么说不明看下这篇文章Android Jetpack组件Lifecycle基本使用和原理分析
- ObserverWrapper 是Observer包装类
- 我们接下来看下ObserverWrapper类
*** ObserverWrapper类
    #+BEGIN_SRC java
private abstract class ObserverWrapper {
    final Observer<? super T> mObserver;
    boolean mActive;
    int mLastVersion = START_VERSION;
    // 1
    ObserverWrapper(Observer<? super T> observer) {
        mObserver = observer;
    }
    // 2
    abstract boolean shouldBeActive();
    boolean isAttachedTo(LifecycleOwner owner) {
        return false;
    }
    void detachObserver() { }
    void activeStateChanged(boolean newActive) {
        if (newActive == mActive) return;

        //  immediately set active state, so we'd never dispatch anything to inactive owner
        mActive = newActive;
        boolean wasInactive = LiveData.this.mActiveCount == 0;
        LiveData.this.mActiveCount += mActive ? 1 : -1;
        if (wasInactive && mActive) 
            onActive(); // 3
        if (LiveData.this.mActiveCount == 0 && !mActive) 
            onInactive(); // 4
        if (mActive) 
            dispatchingValue(this); // 5
    }
}
    #+END_SRC
- 注：活跃状态指的是 Activity、Fragment 等生命周期处于活跃状态
- 注释 1：获取了我们的 Observer 对象，存储在 成员变量mObserver身上
- 注释 2：抽象方法，当前是否是活跃的状态
- 注释 3：可以继承 LiveData 来达到扩展 LiveData 的目标，并且是在活跃的状态调用
- 注释 4：可以继承 LiveData 来达到扩展 LiveData 的目标，并且是在非活跃的状态调用
- 注释 5：活跃状态，发送最新的值，来达到通知的作用， dispatchingValue(this)方法咋这么眼熟，对之前在 LiveData 调用 setValue 方法时，最终也会调用到此方法。那ObserverWrapper类中的dispatchingValue这个方法是在activeStateChanged方法中调用，那activeStateChanged啥时候调用呢？
- 我来看下ObserverWrapper的子类也就是最重要的那个类LifecycleBoundObserver，现在看它的完整代码
*** LifecycleBoundObserver完整代码
- 这里是关键代码了
#+BEGIN_SRC java
// LiveData.java
class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver {
    @NonNull final LifecycleOwner mOwner;
    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<? super T> observer) {
        super(observer);
        mOwner = owner;
    }
    @Override boolean shouldBeActive() {
        return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); // 1
    }
    @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) {
        if (mOwner.getLifecycle().getCurrentState() == DESTROYED) { // 2
            removeObserver(mObserver);
            return;
        }
        activeStateChanged(shouldBeActive()); // 3
    }
    @Override boolean isAttachedTo(LifecycleOwner owner) {
        return mOwner == owner;
    }
    @Override void detachObserver() {
        mOwner.getLifecycle().removeObserver(this); // 4
    }
}
#+END_SRC
- 注释 1：判断当前的 Lifecycle 的生命周期是否是活跃状态，会在回调观察则 Observer 的时候进行判断，只有在活跃状态，才会回调观察者Observer的onChanged方法。
- 直接就回答了我们上面的这个问题LiveData 为什么只会将更新通知给活跃的观察者。非活跃观察者不会收到更改通知？ 首先会通过LifecycleOwner获取Lifecycle对象然后获取Lifecycle 的State，并且状态大于STARTED。这里的State是和 Activity、Fragment 的生命周期是对应的，具体看这篇文章 Android Jetpack组件Lifecycle基本使用和原理分析 的第4.4小节，有详细的解释。
- 注释 2：onStateChanged每次 Activity、Fragment的生命周期回调的时候，都会走这个方法。
- 获取Lifecycle对象然后获取Lifecycle 的State如果为DESTROYED则移除观察者，在 Activity、Fragment的生命周期走到 onDestroy 的时候，就会取消订阅，避免内存泄漏。
- 注释 3：调用父类ObserverWrapper 的activeStateChanged方法，层层调用到观察者Observer的onChanged方法。（自己看下源码一目了然）
- 重点来了：在LiveData 调用setValue方法时，会回调观察者Observer的onChanged方法，Activity、Fragment的生命周期变化的时候且为活跃也会回调观察者Observer的onChanged方法。这就是为什么你在ActivityB页面，调用setValue方法，更新了value，在ActivityA 重新获取焦点时也同样会收到这个最新的值。
- 注释 4：移除观察者Observer，解除订阅关系。
- 到这个时候,LiveData 的 observer方法、setValue方法，整个流程就分析完了。
- 如果我们想不管生命周期，而是想在setValue的值发生改变的时候就能接受到通知，LiveData 还提供了一个observeForever方法
#+BEGIN_SRC kotlin
class LiveDataActivity : BaseActivity() {
    private val mContent = MutableLiveData<String>()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_live_data)
        btnUpdate.setOnClickListener {
            mContent.value = "最新值是:Update"
        }
        // 只要在值发生改变时,就能接收到
        mContent.observeForever { content -> // .observeForever { -> }
            tvContent.text = content
        }
    }
}
#+END_SRC
*** LiveData 的observeForever方法
- 这个方法比observe方法少一个LifecycleOwner参数，为啥呢？因为这个方法不需要感知生命周期，需要在setValue 值更新时立马收到回调。
- 来看下具体代码
#+BEGIN_SRC java
// LiveData.java
@MainThread
public void observeForever(@NonNull Observer<? super T> observer) {
    assertMainThread("observeForever");
  	// 1
    AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);
    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);
    if (existing instanceof LiveData.LifecycleBoundObserver) {
        throw new IllegalArgumentException("Cannot add the same observer"
                + " with different lifecycles");
    }
    if (existing != null) 
        return;
    wrapper.activeStateChanged(true);
}
#+END_SRC
- 注释 1 ：这里用到的是AlwaysActiveObserver而 observe方法用到是LifecycleBoundObserver
- 看一下这个AlwaysActiveObserver
#+BEGIN_SRC java
// LiveData.java
private class AlwaysActiveObserver extends ObserverWrapper {
    AlwaysActiveObserver(Observer<? super T> observer) {
        super(observer);
    }
    @Override
    boolean shouldBeActive() {
        return true;
    }
}
#+END_SRC
- 代码非常的简洁，在shouldBeActive方法中，直接 return true，这也太秀了吧
- 为啥直接返回 true 呢？因为这里不用管生命周期，永远都是活跃状态，所以这个方法叫observeForever
- LiveData 的源码非常值得读，而且量不是很大，里面有许多值得学习的地方。
** 使用 LiveData 的优势: 这个是Google官方总结的:使用 LiveData 具有以下优势：
- 确保界面符合数据状态
- LiveData 遵循观察者模式。当生命周期状态发生变化时，LiveData 会通知 Observer 对象。您可以整合代码以在这些 Observer 对象中更新界面。观察者可以在每次发生更改时更新界面，而不是在每次应用数据发生更改时更新界面。
- 不会发生内存泄漏
- 观察者会绑定到 Lifecycle 对象，并在其关联的生命周期遭到销毁后进行自我清理。
- 不会因 Activity 停止而导致崩溃
- 如果观察者的生命周期处于非活跃状态（如返回栈中的 Activity），则它不会接收任何 LiveData 事件。
- 不再需要手动处理生命周期
- 界面组件只是观察相关数据，不会停止或恢复观察。LiveData 将自动管理所有这些操作，因为它在观察时可以感知相关的生命周期状态变化。
- 数据始终保持最新状态
- 如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据。例如，曾经在后台的 Activity 会在返回前台后立即接收最新的数据。
- 适当的配置更改
- 如果由于配置更改（如设备旋转）而重新创建了 Activity 或 Fragment，它会立即接收最新的可用数据。
- 共享资源
- 您可以使用单一实例模式扩展 LiveData 对象以封装系统服务，以便在应用中共享它们。LiveData 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 LiveData 对象。如需了解详情，请参阅扩展 LiveData。
** 总结
- LiveData 是怎么回调的？
  - LiveData通过observe或者observeForever方法订阅了一个观察者
  - LiveData 通过调用setValue或postValue方法时，会取出观察者，调用它的onChanged方法
  - 当然，当 Activity、Fragment 生命周期由非活跃变化为活跃状态，也会收到最新的值回调onChanged方法，注意这个对应的是LiveData的observe方法。
- LiveData 为什么可以感知生命周期？
  - 是因为LifecycleBoundObserver类
  - 以及在observe方法中调用了 owner.getLifecycle().addObserver(wrapper);这行代码，具体的看下上面的源码分析吧
- LiveData 可以感知生命周期，有什么用，或者说有什么优势？
  - 可以自动取消订阅
  - 防止内存泄漏
- LiveData 为什么只会将更新通知给活跃的观察者。非活跃观察者不会收到更改通知？
  - 在每次调用setValue方法时，最走到LifecycleBoundObserver的shouldBeActive这个方法的判断上
  - 这个方法返回的是状态为STARTED之后的状态才会走通知观察者回调的逻辑，否则就不执行，具体的看下上面的源码
- LiveData此外还提供了observerForever()方法，所有生命周期事件都能通知到，怎么做到的？
  - 主要AlwaysActiveObserver的shouldBeActive这个方法直接返回的 true


* Android Jetpack组件ViewModel基本使用和原理分析
- 本文整体流程：首先要知道什么是 ViewModel，然后演示一个例子，来看看 ViewModel 是怎么使用的，接着提出问题为什么是这样的，最后读源码来解释原因！
- 什么是ViewModel
- ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。在对应的作用域内，保正只生产出对应的唯一实例，保证UI组件间的通信。
- ViewModel 一般要配合 LiveData、DataBinding一起使用
- 特点
  - 通过定义我们可以得出
  - ViewModel不会随着Activity的屏幕旋转而销毁；
  - 在对应的作用域内，保正只生产出对应的唯一实例，保证UI组件间的通信
  - 重点说一下ViewModel和onSaveInstanceState的关系
  - 对于简单的数据，Activity 可以使用 onSaveInstanceState() 方法从 onCreate() 中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。
  - ViewModel存储大量数据，不用序列化与反序列化
  - onSaveInstanceState存储少量数据
  - 相辅相成，不是替代
  - 进程关闭是onSaveInstanceState的数据会保留，而ViewModel销毁
** ViewModel的基础使用
- 这个例子，主要是在 打印 User 的信息，并且点击按钮的时候更新 User 的信息并打印
*** 首先看一下 UserViewModel这个文件
    #+BEGIN_SRC kotlin
// UserViewModel.kt
// 自定义 User 数据类
data class User(var userId: String = UUID.randomUUID().toString(), var userName: String)
class UserViewModel : ViewModel() {
    private val userBean = User(userName = "刀锋之影")
    // 私有的 user LiveData
    private val _user = MutableLiveData<User>().apply {
        value = userBean
    }
    // 对外暴露的,不可更改 value 值的LiveData
    var userLiveData: LiveData<User> = _user
    // 更新 User 信息
    fun updateUser() {
        // 重新给 _user 赋值
        _user.value = userBean.apply {
            userId = UUID.randomUUID().toString()
            userName = "更新后: userName = 泰隆"
        }
    }
}
    #+END_SRC
- 自定义 User 数据类
- 继承ViewModel，初始化 User
- 声明私有的 user LIveData 用来更新数据
- 对外暴露的，不可更改 value 值的LiveData
- updateUser() 更新 User 信息的方法
*** 再看下ViewModelActivity的内容
    #+BEGIN_SRC kotlin
class ViewModelActivity : AppCompatActivity() {
    // private lateinit var binding: ActivityMainBinding
    private val TAG = javaClass.simpleName

    // 初始化 UserViewModel 通过 ViewModelProvider
    private val userViewModel by lazy { ViewModelProvider(this)[UserViewModel::class.java] }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val button = Button(this) // 动态设置了一个占据整个屏幕的大button
        setContentView(button)
        // 观察 User 数据,并打印
        userViewModel.userLiveData.observe(this, Observer { user ->
                                                                Log.d(TAG, "observe() User = $user")
        })
        // 点击按钮更新 User 信息
        button.setOnClickListener {
            userViewModel.updateUser()
        }
    }
}
#+END_SRC
- 初始化 UserViewModel
- 观察 User 数据,并打印结果
- 点击按钮时，更新 User 信息
*** 结果日志
    #+BEGIN_SRC kotlin
// log 日志
User = User(userId=34c1a1a4-967e-439c-91e8-795b8c162997, userName=刀锋之影)
User = User(userId=a6d0f09c-9c01-412a-ab4f-44bef700d298, userName=更新后: userName = 泰隆)
    #+END_SRC
*** 总结：
- 以上就是 ViewModel 的简单使用，是配合 LiveData 的，具体 LiveData 的使用以及与原理分析，请看这篇文章
- Android Jetpack组件LiveData基本使用和原理分析
- 通过上文可以 ViewModel 的定义以及特点，可以知道 ViewModel在对应的作用域内，保正只生产出对应的唯一实例，保证UI组件间的通信
- 我们来验证一下这个特点，我再写个例子，证明一下这个特点

** 验证ViewModel在对应的作用域内，保正只生产出对应的唯一实例
*** ViewModelActivity2类
- 在ViewModelActivity2中通过supportFragmentManager添加两个 Fragment
#+BEGIN_SRC kotlin
class ViewModelActivity2 : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_view_model)
        supportFragmentManager.beginTransaction()
            .add(R.id.flContainer, FirstFragment())
            .add(R.id.flContainer, SecondFragment())
            .commit()
    }
}
#+END_SRC
*** 两个 Fragment
    #+BEGIN_SRC kotlin
class FirstFragment : Fragment() {
    private val TAG = javaClass.simpleName
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        val userViewModel = ViewModelProvider(activity as ViewModelStoreOwner)[UserViewModel::class.java]
        "userViewModel = $userViewModel".logWithTag(TAG)
        return super.onCreateView(inflater, container, savedInstanceState)
    }
}
class SecondFragment : Fragment() {
    private val TAG = javaClass.simpleName
    
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        val userViewModel = ViewModelProvider(activity as ViewModelStoreOwner)[UserViewModel::class.java]
        "userViewModel = $userViewModel".logWithTag(TAG)
        return super.onCreateView(inflater, container, savedInstanceState)
    }
}
#+END_SRC
- 在 FirstFragment和SecondFragment的onCreateView方法中实例化UserViewModel对象
- 其中的参数都为activity as ViewModelStoreOwner其实也就是ViewModelActivity2
- 打印UserViewModel对象的地址值，来看日志
*** 结果日志
    #+BEGIN_SRC kotlin
 com.me.ktl D/FirstFragment: userViewModel = com.me.ktl.UserViewModel@c35f635
com.me.ktl D/SecondFragment: userViewModel = com.me.ktl.UserViewModel@c35f635 
    #+END_SRC
- 可以看到两个 Fragment 中 UserViewModel是同一个对象。
- 可以这两个 Fragment 可以使用其 Activity 范围共享 ViewModel 来处理此类通信
** 抛出问题
- ViewModel为什么不会随着Activity的屏幕旋转而销毁；
- 为什么在对应的作用域内，保正只生产出对应的唯一实例，保证UI组件间的通信
- onCleared方法在什么调用
** 分析源码前的准备工作
*** ViewModel 的生命周期
*** 几个类的感性认识
- ViewModelStoreOwner：是一个接口，用来获取一个ViewModelStore对象
- ViewModelStore：存储多个ViewModel，一个ViewModelStore的拥有者( Activity )在配置改变， 重建的时候，依然会有这个实例
- ViewModel：一个对 Activity、Fragment 的数据管理类，通常配合 LiveData 使用
- ViewModelProvider：创建一个 ViewModel 的实例，并且在给定的ViewModelStoreOwner中存储 ViewModel
** 源码分析
- 再看上面第一个例子中的代码
#+BEGIN_SRC kotlin
class ViewModelActivity : AppCompatActivity() {
    // 初始化 UserViewModel 通过 ViewModelProvider
    private val userViewModel by lazy { ViewModelProvider(this)[UserViewModel::class.java] }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val button = Button(this)
        setContentView(button)
        // 观察 User 数据,并打印
        userViewModel.userLiveData.observe(this, Observer { user ->
            "User = $user".log()
        })
        // 点击按钮更新 User 信息
        button.setOnClickListener {
            userViewModel.updateUser()
        }
    }
}
#+END_SRC
- 首先看下UserViewModel的初始化过程。
- private val userViewModel by lazy { ViewModelProvider(this)[UserViewModel::class.java] }
- 注：上面代码类似数组的写法是 Kotlin 的写法，其实是 ViewModelProvider 的get方法
** ViewModelProvider的构造方法，以及 get 方法
*** ViewModelProvider构造方法
- 先看ViewModelProvider构造方法，传入的参数为当前的 AppCompatActivity
#+BEGIN_SRC java
// ViewModelProvider.java
private final Factory mFactory;
private final ViewModelStore mViewModelStore;
public ViewModelProvider(@NonNull ViewModelStoreOwner owner) {
    this(owner.getViewModelStore(), owner instanceof HasDefaultViewModelProviderFactory
            ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()
            : NewInstanceFactory.getInstance());
}
public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) {
    mFactory = factory;
    mViewModelStore = store;
}
#+END_SRC 
- 通过 ViewModelStoreOwner获取ViewModelStore对象并给 mViewModelStore赋值
- 给mFactory赋值，这里赋值的是NewInstanceFactory这个对象
*** ViewModelProvider的 get 方法
    #+BEGIN_SRC java
// ViewModelProvider.java
private static final String DEFAULT_KEY = "androidx.lifecycle.ViewModelProvider.DefaultKey";
public <T extends ViewModel> T get(@NonNull Class<T> modelClass) {
    String canonicalName = modelClass.getCanonicalName();
    if (canonicalName == null) {
        throw new IllegalArgumentException("Local and anonymous classes can not be ViewModels");
    }
    // 1
    return get(DEFAULT_KEY + ":" + canonicalName, modelClass);
}
    #+END_SRC 
- 注释1：
  - 调用了两个参数的 get 方法
  - 第一个参数是字符串的拼接，用来以后获取对应 ViewModel 实例的，保证了同一个 Key 取出是同一个 ViewModel
  - 第二参数是 UserViewModel 的字节码文件对象
- 看下两个参数的get方法
#+BEGIN_SRC java
// ViewModelProvider.java
public <T extends ViewModel> T get(@NonNull String key, @NonNull Class<T> modelClass) {
    ViewModel viewModel = mViewModelStore.get(key);// 1
    // 2
    if (modelClass.isInstance(viewModel)) {
        if (mFactory instanceof OnRequeryFactory) {
            ((OnRequeryFactory) mFactory).onRequery(viewModel);
        }
        return (T) viewModel;
    } else {
        // noinspection StatementWithEmptyBody
        if (viewModel != null) {
            // TODO: log a warning.
        }
    }
    // 3
    if (mFactory instanceof KeyedFactory) {
        viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass);
    } else {
        viewModel = (mFactory).create(modelClass);
    }
    // 4
    mViewModelStore.put(key, viewModel);
    return (T) viewModel;
}
#+END_SRC 
- 注释 1：从ViewModelStore中，根据 key，取一个 ViewModel，ViewModelStore源码下文分析
- 注释 2：判断取出来的 ViewModel 实例和传进来的是否是一个，是同一个，直接返回此缓存中实例
- 注释 3：通过Factory创建一个ViewModel
- 注释 4：把新创建的ViewModel用ViewModelStore存储起来，以备下次使用，最后返回新创建的ViewModelStore
- 这里看一下ViewModel是怎么通过Factory创建出来的
- 这个Factory的实例是NewInstanceFactory
*** NewInstanceFactory的create方法
    #+BEGIN_SRC java
// ViewModelProvider.java 中的 AndroidViewModelFactory.java
public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {
    // noinspection TryWithIdenticalCatches
    try {
        return modelClass.newInstance();
    } catch (InstantiationException e) {
        throw new RuntimeException("Cannot create an instance of " + modelClass, e);
    } catch (IllegalAccessException e) {
        throw new RuntimeException("Cannot create an instance of " + modelClass, e);
    }
}
    #+END_SRC 
- 简单粗暴，通过反射，直接创建了ViewModel对象。
- 这里扩展一个，在实例UserViewModel的时候
#+BEGIN_SRC java
private val userViewModel by lazy { ViewModelProvider(this,ViewModelProvider.AndroidViewModelFactory.getInstance(application))[UserViewModel::class.java] }
#+END_SRC 
- 也可以通过两个参数的构造方法，来实例化，其中第二个参数就是Factory类型。然后就会用 AndroidViewModelFactory来实例化UserViewModel，我们来具体看下代码
- AndroidViewModelFactory是NewInstanceFactory的子类
#+BEGIN_SRC java
// ViewModelProvider.java 中的 AndroidViewModelFactory
public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {
    if (AndroidViewModel.class.isAssignableFrom(modelClass)) {
        // noinspection TryWithIdenticalCatches
        try {
            return modelClass.getConstructor(Application.class).newInstance(mApplication);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException("Cannot create an instance of " + modelClass, e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException("Cannot create an instance of " + modelClass, e);
        } catch (InstantiationException e) {
            throw new RuntimeException("Cannot create an instance of " + modelClass, e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException("Cannot create an instance of " + modelClass, e);
        }
    }
    return super.create(modelClass);
}
#+END_SRC 
- 如果我们创建的UserViewModel当初继承的是AndroidViewModel类就走modelClass.getConstructor(Application.class).newInstance(mApplication);实例化方法，否则就走父类的实例化方法，也就是NewInstanceFactory的create方法
- 在开发中建议使用AndroidViewModel类，它会提供给一个Application级别的 Context。
- 接下来看一下ViewModelStoreOwner是什么，以及它的具体实现
** ViewModelStoreOwner
   #+BEGIN_SRC java
public interface ViewModelStoreOwner {
    /**
     * Returns owned {@link ViewModelStore}
     *
     * @return a {@code ViewModelStore}
     */
    @NonNull
    ViewModelStore getViewModelStore();
}
   #+END_SRC 
- 一个接口，里面一个方法返回了ViewModelStore对象
- 它的实现类在 AndroidX 中ComponentActivity和 Fragment
- ComponentActivity的关键代码
#+BEGIN_SRC java
// ComponentActivity.java
public class ComponentActivity extends androidx.core.app.ComponentActivity implements ViewModelStoreOwner,XXX{
   
    private ViewModelStore mViewModelStore;
    @NonNull
    @Override
    public ViewModelStore getViewModelStore() {
        if (getApplication() == null) {
            throw new IllegalStateException("Your activity is not yet attached to the "
                    + "Application instance. You can't request ViewModel before onCreate call.");
        }
        if (mViewModelStore == null) {
            NonConfigurationInstances nc =
                    (NonConfigurationInstances) getLastNonConfigurationInstance();
            if (nc != null) {
                // Restore the ViewModelStore from NonConfigurationInstances
                mViewModelStore = nc.viewModelStore;
            }
            if (mViewModelStore == null) {
                mViewModelStore = new ViewModelStore();
            }
        }
        return mViewModelStore;
    } 
}
#+END_SRC 
- 创建了一个ViewModelStore并返回了
- 来看下这个ViewModelStore类
** ViewModelStore
*** ViewModelStore的源码
- 我下面贴的是完整代码，对你没看错。
#+BEGIN_SRC java
public class ViewModelStore {
		// 1
    private final HashMap<String, ViewModel> mMap = new HashMap<>();
		// 2
    final void put(String key, ViewModel viewModel) {
        ViewModel oldViewModel = mMap.put(key, viewModel);
        if (oldViewModel != null) {
            oldViewModel.onCleared();
        }
    }
		// 3
    final ViewModel get(String key) {
        return mMap.get(key);
    }
    Set<String> keys() {
        return new HashSet<>(mMap.keySet());
    }
    // 4
    public final void clear() {
        for (ViewModel vm : mMap.values()) {
            vm.clear();
        }
        mMap.clear();
    }
}
#+END_SRC 
- 注释 1 ：声明一个 Map 来存储ViewModel
- 注释 2：存储ViewModel，这个方法我们在7.2 小节ViewModelProvider的 get 方法中用到过
- 注释 3：取出 ViewModel，这个方法我们在7.2 小节ViewModelProvider的 get 方法中用到过。注意在从 Map中去 ViewModel 的时候是根据 Key，也就是7.2小节注释 1 拼接的那个字符串DEFAULT_KEY + ":" + canonicalName。这也就解释了第 4 节的疑问 为什么在对应的作用域内，保正只生产出对应的唯一实例
- 注释 4：这个是一个重点方法了，表明要清空存储的数据，还会调用到ViewModel的 clear 方法，也就是最终会调用带 ViewModel 的onCleared()方法
- 那么这个ViewModelStore的 clear 方法，什么时候会调用呢？
*** ComponentActivity的构造方法
    #+BEGIN_SRC java
// ComponentActivity.java
public ComponentActivity() {
    Lifecycle lifecycle = getLifecycle();
   	
    getLifecycle().addObserver(new LifecycleEventObserver() {
        @Override
        public void onStateChanged(@NonNull LifecycleOwner source,
                @NonNull Lifecycle.Event event) {
          	// 1
            if (event == Lifecycle.Event.ON_DESTROY) {
                if (!isChangingConfigurations()) {
                    getViewModelStore().clear();
                }
            }
        }
    });
}
   #+END_SRC 
- 在ComponentActivity的构造方法中，我们看到，在 Activity 的生命周期为 onDestory的时候，并且当前不是，配置更改（比如横竖屏幕切换）就会调用ViewModelStore 的 clear 方法，进一步回 调用 ViewModel 的onCleared方法。
- 这就回答了第四节提出的问题onCleared方法在什么调用
- 最后看一下 ViewModel 的源码，以及其子类AndroidViewModel
** ViewModel 的源码
- ViewModel类其实更像是更规范化的抽象接口
#+BEGIN_SRC java
public abstract class ViewModel {
    private volatile boolean mCleared = false;
    @SuppressWarnings("WeakerAccess")
    protected void onCleared() {
    }
    @MainThread
    final void clear() {
        mCleared = true;
        if (mBagOfTags != null) {
            synchronized (mBagOfTags) {
                for (Object value : mBagOfTags.values()) {
                    // see comment for the similar call in setTagIfAbsent
                    closeWithRuntimeException(value);
                }
            }
        }
        onCleared();
    }
}
#+END_SRC 
- ViewModel 的子类AndroidViewModel
#+BEGIN_SRC java
public class AndroidViewModel extends ViewModel {
    @SuppressLint("StaticFieldLeak")
    private Application mApplication;
    public AndroidViewModel(@NonNull Application application) {
        mApplication = application;
    }
    /**
     * Return the application.
     */
    @SuppressWarnings({"TypeParameterUnusedInFormals", "unchecked"})
    @NonNull
    public <T extends Application> T getApplication() {
        return (T) mApplication;
    }
}
#+END_SRC 
- 提供了一个规范，提供了一个 Application 的 Context
- 到现在整个源码过程就看了，包括前面，我们提到的那几个关键类的源码。
- 到目前为止，我们第 4 节抛出的问题，已经解决了，两个了，还有一个ViewModel为什么不会随着Activity的屏幕旋转而销毁；
** 分析为啥ViewModel不会随着Activity的屏幕旋转而销毁
- 首先知道的是 ViewModel 不被销毁，是在一个 ViewModelStore 的 Map 中存着呢，所以要保证ViewModelStore不被销毁。
- 首先得具备一个前置的知识
- 在 Activity 中提供了 onRetainNonConfigurationInstance 方法，用于处理配置发生改变时数据的保存。随后在重新创建的 Activity 中调用 getLastNonConfigurationInstance 获取上次保存的数据。
*** onRetainNonConfigurationInstance方法
    #+BEGIN_SRC java
// ComponentActivity.java
/**
 * Retain all appropriate non-config state.  You can NOT
 * override this yourself!  Use a {@link androidx.lifecycle.ViewModel} if you want to
 * retain your own non config state.
 */
@Override
@Nullable
public final Object onRetainNonConfigurationInstance() {
    Object custom = onRetainCustomNonConfigurationInstance();
    ViewModelStore viewModelStore = mViewModelStore;
    if (viewModelStore == null) {
        // No one called getViewModelStore(), so see if there was an existing
        // ViewModelStore from our last NonConfigurationInstance
        NonConfigurationInstances nc =
                (NonConfigurationInstances) getLastNonConfigurationInstance();
        if (nc != null) {
            viewModelStore = nc.viewModelStore;
        }
    }
    if (viewModelStore == null && custom == null) {
        return null;
    }
		// 1
    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.custom = custom;
    nci.viewModelStore = viewModelStore;
    return nci;
}
    #+END_SRC 
- 注意看下方法上的注释
- 不需要也不能重写此方法，因为用 final 修饰
- 配置发生改变时数据的保存，用ViewModel就行
- 注释 1：把ViewModel存储在 NonConfigurationInstances 对象中
- 现在再看下ComponentActivity 的 getViewModelStore方法
#+BEGIN_SRC java
// ComponentActivity.java
@NonNull
@Override
public ViewModelStore getViewModelStore() {
    if (getApplication() == null) {
        throw new IllegalStateException("Your activity is not yet attached to the "
                + "Application instance. You can't request ViewModel before onCreate call.");
    }
    if (mViewModelStore == null) {
      	// 1
        NonConfigurationInstances nc =
                (NonConfigurationInstances) getLastNonConfigurationInstance();
        if (nc != null) {
            // Restore the ViewModelStore from NonConfigurationInstances
            mViewModelStore = nc.viewModelStore;
        }
        if (mViewModelStore == null) {
            mViewModelStore = new ViewModelStore();
        }
    }
    return mViewModelStore;
}
#+END_SRC 
注释 1：获取了NonConfigurationInstances一个对象，不为空从其身上拿一个ViewModelStore，这个就是之前保存的ViewModelStore
当 Activity 重建时还会走到getViewModelStore方法，这时候就是在NonConfigurationInstances拿一个缓存的ViewModelStore。
** 总结
- 1.ViewModel为什么不会随着Activity的屏幕旋转而销毁
  - 主要是通过onRetainNonConfigurationInstance方法把ViewModelStore缓存在NonConfigurationInstances中，在getViewModelStore取出ViewModelStore。具体内容看第 11 节
- 2.为什么在对应的作用域内，保正只生产出对应的唯一实例
  - ViewModelStore的 get方法，是根据 key 来取值的，如果 key相同，那取出来的ViewModel就是一个。具体内容看第 9.2 小节
- 3.onCleared方法在什么调用
  - 当 Activity 真正销毁的时候，而不是配置改变会调用ViewModelStore的 clear进而调用了ViewModel的onCleared，具体内容看第 9.2 小节


* Dagger Dagger2 Hilt Koin: 自动依赖注入框架
- 有一些库通过自动执行创建和提供依赖项的过程解决此问题，实现原理有如下几种方案：
  - 1. 通过反射，在运行时连接依赖项;
  - 2. 通过注解，编译时生成连接依赖项的代码;
  - 3. kotlin 强大的语法糖和函数式编程;
- 1. Dagger：
- Android领域最广为熟知的依赖注入框架，可以说大名鼎鼎了
  - Dagger 1.x版本：Square基于反射实现的，有两个缺点一个是反射的耗时，另一个是反射是运行时的，编译期不会报错。而使用难度较高，刚接触时有经常容易写错，造成开发效率底；
  - Dagger 2.x版本：Google基于Java注解实现的，完美解决了上述问题，
- Koin
  - 为 Kotlin 开发者提供的一个实用型轻量级依赖注入框架，采用纯 Kotlin 语言编写而成，仅使用功能解析，无代理、无代码生成、无反射(通过kotlin 强大的语法糖（例如 Inline、Reified 等等）和函数式编程实现)；
- Hilt
  - Hilt 通过为项目中的每个 Android 类提供容器并自动为您管理其生命周期，定义了一种在应用中执行 DI 的标准方法。
  - Hilt 在热门 DI 库 Dagger 的基础上构建而成，因而能够受益于 Dagger 提供的编译时正确性、运行时性能、可伸缩性和 Android Studio 支持。
** Hilt使用流程
*** 添加依赖项
    #+BEGIN_SRC groovy
//1. 配置Hilt的插件路径
buildscript {
    ...
    dependencies {
        ...
        classpath 'com.google.dagger:hilt-android-gradle-plugin:2.28-alpha'
    }
}
//2. 引入Hilt的插件
plugins {
    ...
    id 'dagger.hilt.android.plugin'
    id 'kotlin-kapt'
}
//3. 添加Hilt的依赖库及Java8
android {
  ...
  compileOptions {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
  }
  //对于 Kotlin 项目，需要添加 kotlinOptions
  kotlinOptions {
      jvmTarget = "1.8"
  }
}
dependencies {
    ...
    implementation "com.google.dagger:hilt-android:2.28-alpha"
    kapt "com.google.dagger:hilt-android-compiler:2.28-alpha"
}
    #+END_SRC
** Hilt 应用类
- 用@HiltAndroidApp注解Application;
- @HiltAndroidApp注解 会触发 Hilt 的代码生成操作，生成的代码包括应用的一个基类，该基类充当应用级依赖项容器;
#+BEGIN_SRC kotlin
@HiltAndroidApp
class MyApplication : MultiDexApplication() {
}
#+END_SRC
** 将依赖项注入 Android 类
- 1. 用@AndroidEntryPoint注释类;
  - 目前支持6类入口点：Application（通过使用 @HiltAndroidApp），Activity，Fragment，View，Service，BroadcastReceiver
  - 使用 @AndroidEntryPoint 注解 Android 类，还必须为依赖于该类的 Android 类添加注释，例如为注解 fragment ，则还必须为该 fragment 依赖的 Activity 添加@AndroidEntryPoint注释。
- 2. 使用 @Inject 注释执行字段
  - @AndroidEntryPoint 会为项目中的每个 Android 类生成一个单独的 Hilt 组件。这些组件可以从它们各自的父类接收依赖项, 如需从组件获取依赖项，请使用 @Inject 注释执行字段注入， 注意：Hilt注入的字段是不可以声明成private的；
- 3. 构造函数中使用 @Inject 注释
  - 为了执行字段注入，需要在类的构造函数中使用 @Inject 注释，以告知 Hilt 如何提供该类的实例：
#+BEGIN_SRC kotlin
@AndroidEntryPoint
class HiltDemoActivity : AppCompatActivity() {
    @Inject
    lateinit var cpu: CPU
}
class CPU @Inject constructor() {
    var name: String = ""
    fun run() {
        LjyLogUtil.d("$name run...")
    }
}
#+END_SRC
** 带参数的依赖注入：
- 如果构造函数中带有参数，Hilt要如何进行依赖注入呢？
- 需要构造函数中所依赖的所有其他对象都支持依赖注入
#+BEGIN_SRC kotlin
class CPU @Inject constructor() {
    var name: String = ""
    fun run() {
        LjyLogUtil.d("$name run...")
    }
}
class Phone @Inject constructor(val cpu: CPU) {
    fun use() {
        cpu.run()
    }
}
@AndroidEntryPoint
class HiltActivity : AppCompatActivity() {
    @Inject
    lateinit var phone: Phone
    fun test() {
        phone.cpu.name = "麒麟990"
        phone.use()
    }
}
#+END_SRC
** Hilt Module
- 有时一些类型参数不能通过构造函数注入, 如 接口 或 来自外部库的类，此时可以使用 Hilt模块 向Hilt提供绑定信息；
- Hilt 模块是一个带有 @Module 注释的类，并使用 @InstallIn 设置作用域
*** 使用 @Binds 注入接口实例
    #+BEGIN_SRC kotlin
//1. 接口
interface ICPU {
    fun run()
}
//2. 实现类
class KylinCPU @Inject constructor() : ICPU {
    override fun run() {
        LjyLogUtil.d("kylin run...")
    }
}
//3. 被注入的类，入参是接口类型
class Phone @Inject constructor(val cpu: ICPU) {
    fun use() {
        cpu.run()
    }
}
//4. 使用@Binds注入接口实例
@Module
@InstallIn(ActivityComponent::class)
abstract class CPUModel {
    @Binds
    abstract fun bindCPU(cpu: KylinCPU): ICPU
}
//5. 使用注入的实例
@AndroidEntryPoint
class HiltActivity : AppCompatActivity() {
    @Inject
    lateinit var phone: Phone
    fun test() {
        phone.cpu.name = "麒麟990"
        phone.use()
    }
}
    #+END_SRC
*** 使用 @Provides 注入实例
- 如果某个类不归您所有（因为它来自外部库，如 Retrofit、OkHttpClient 或 Room 数据库等类），或者必须使用构建器模式创建实例，也无法通过构造函数注入。
#+BEGIN_SRC kotlin
@Module
@InstallIn(ApplicationComponent::class)
class NetworkModel {
    @Provides
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient().newBuilder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(60, TimeUnit.SECONDS)
            .writeTimeout(90, TimeUnit.SECONDS)
            .build()
    }
}
#+END_SRC
*** 为同一类型提供多个绑定
- 比如网络请求中可能需要不同配置的OkHttpClient，或者不同BaseUrl的Retrofit
- 使用@Qualifier注解实现
#+BEGIN_SRC kotlin
//1. 接口和实现类
interface ICPU {
    fun run()
}

class KylinCPU @Inject constructor() : ICPU {
    override fun run() {
        LjyLogUtil.d("kylin run...")
    }
}
class SnapdragonCPU @Inject constructor() : ICPU {
    override fun run() {
        LjyLogUtil.d("snapdragon run...")
    }
}
//2. 创建多个类型的注解
@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class BindKylinCPU
@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class BindSnapdragonCPU
//@Retention:注解的生命周期
//AnnotationRetention.SOURCE：仅编译期，不存储在二进制输出中
//AnnotationRetention.BINARY：存储在二进制输出中，但对反射不可见
//AnnotationRetention.RUNTIME：存储在二进制输出中，对反射可见

//3. 在Hilt模块中使用注解
@Module
@InstallIn(ActivityComponent::class)
abstract class CPUModel {
    @BindKylinCPU
    @Binds
    abstract fun bindKylinCPU(cpu: KylinCPU): ICPU
    @BindSnapdragonCPU
    @Binds
    abstract fun bindSnapdragonCPU(cpu: SnapdragonCPU): ICPU
}
//4. 使用依赖注入获取实例，可以用在字段注解，也可以用在构造函数或者方法入参中
class Phone5 @Inject constructor(@BindSnapdragonCPU private val cpu: ICPU) {
    @BindKylinCPU
    @Inject
    lateinit var cpu1: ICPU
    @BindSnapdragonCPU
    @Inject
    lateinit var cpu2: ICPU
    fun use() {
        cpu.run()
        cpu1.run()
        cpu2.run()
    }
    fun use(@BindKylinCPU cpu: ICPU) {
        cpu.run()
    }
}
#+END_SRC
** 组件默认绑定
- 由于可能需要来自 Application 或 Activity 的 Context 类，因此 Hilt 提供了 @ApplicationContext 和 @ActivityContext 限定符。
- 每个 Hilt 组件都附带一组默认绑定，Hilt 可以将其作为依赖项注入您自己的自定义绑定
#+BEGIN_SRC kotlin
class Test1 @Inject constructor(@ApplicationContext private val context: Context)
class Test2 @Inject constructor(@ActivityContext private val context: Context)
#+END_SRC
- 对于Application和Activity这两个类型，Hilt也是给它们预置好了注入功能(必须是这两个，即使子类也不可以)
#+BEGIN_SRC kotlin
class Test3 @Inject constructor(val application: Application)
class Test4 @Inject constructor(val activity: Activity)
#+END_SRC
** Hilt内置组件类型
- 上面使用Hilt Module时，有用到@InstallIn(), 意思是把这个模块安装到哪个组件中
- Hilt内置了7种组件可选：
  - ApplicationComponent：对应Application，依赖注入实例可以在全项目中使用
  - ActivityRetainedComponent：对应ViewModel（在配置更改后仍然存在，因此它在第一次调用 Activity#onCreate() 时创建，在最后一次调用 Activity#onDestroy() 时销毁）
  - ActivityComponent：对应Activity，Activity中包含的Fragment和View也可以使用；
  - FragmentComponent：对应Fragment
  - ViewComponent：对应View
  - ViewWithFragmentComponent：对应带有 @WithFragmentBindings 注释的 View
  - ServiceComponent：对应Service
- Hilt 没有为 broadcast receivers 提供组件，因为 Hilt 直接从 ApplicationComponent 注入 broadcast receivers；
|---------------------------+--------------------------------------------------------------+------------------------+-------------------------|
| Component                 | Description                                                  | Created at             | Destroyed at            |
|---------------------------+--------------------------------------------------------------+------------------------+-------------------------|
| ApplicationComponent      | 为App提供依赖                                                | Application#onCreate() | Application#onDestroy() |
| ActivityComponent         | 为Activity提供依赖                                           | Activity#onCreate()    | Activity#onDestroy()    |
|---------------------------+--------------------------------------------------------------+------------------------+-------------------------|
| ActivityRetainedComponent | Retained顾名思义，其生命周期更长，不会因屏幕旋转等因素重建， | Activity#onCreate()    | Activity#onDestroy()    |
|                           | 实际上是借助ViewModel实现的                                  |                        |                         |
|---------------------------+--------------------------------------------------------------+------------------------+-------------------------|
| FragmentComponent         | 为Fragment提供依赖                                           | Fragment#onAttach()    | Fragment#onDestroy()    |
| ViewComponent             | 为View提供依赖，构造函数中进行注入                           | View#super()           | View destroyed          |
| ViewWithFragmentComponent | 为Fragment中的View提供依赖                                   | View#super()           | View destroyed          |
| ServiceComponent          | 为Service提供依赖                                            | Service#onCreate()     | Service#onDestroy()     |
|---------------------------+--------------------------------------------------------------+------------------------+-------------------------|

** 组件作用域
- Hilt默认会为每次的依赖注入行为都创建不同的实例。
- Hilt内置7种组件作用域注解
  - @Singleton：对应组件ApplicationComponent，整个项目共享同一个实例
  - @ActivityRetainedScope：对应组件ActivityRetainedComponent
  - @ActivityScoped：对应组件ActivityComponent，在同一个Activity（包括其包含的Fragment和View中）内部将会共享同一个实例
  - @FragmentScoped：对应组件FragmentComponent
  - @ViewScoped：对应组件ViewComponent和ViewWithFragmentComponent；
  - @ServiceScopedService：对应ServiceComponent
- 比如我们经常会需要一个全局的OkhttpClient或者Retrofit,就可以如下实现
#+BEGIN_SRC kotlin
 interface ApiService {
    @GET("search/repositories?sort=stars&q=Android")
    suspend fun searRepos(@Query("page") page: Int, @Query("per_page") perPage: Int): RepoResponse
}
@Module
@InstallIn(ApplicationComponent::class)
class NetworkModel {
    companion object {
        private const val BASE_URL = "https://api.github.com/"
    }
    @Singleton
    @Provides
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
    //组件作用域:Hilt默认会为每次的依赖注入行为都创建不同的实例。
    @Singleton
    @Provides
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .addConverterFactory(GsonConverterFactory.create())
            .baseUrl(BASE_URL)
            .client(okHttpClient)
            .build()
    }
    @Singleton
    @Provides
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient().newBuilder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(60, TimeUnit.SECONDS)
            .writeTimeout(90, TimeUnit.SECONDS)
            .build()
    }
}
#+END_SRC
- 或是使用Room操作本地数据库
#+BEGIN_SRC kotlin
@Database(entities = [RepoEntity::class], version = Constants.DB_VERSION)
abstract class AppDatabase : RoomDatabase() {
    abstract fun repoDao(): RepoDao
}
@Module
@InstallIn(ApplicationComponent::class)
object RoomModule {
    @Provides
    @Singleton
    fun provideAppDatabase(application: Application): AppDatabase {
        return Room
            .databaseBuilder(
                application.applicationContext,
                AppDatabase::class.java,
                Constants.DB_NAME
            )
            .allowMainThreadQueries() //允许在主线程中查询
            .build()
    }
    @Provides
    @Singleton
    fun provideRepoDao(appDatabase: AppDatabase):RepoDao{
        return appDatabase.repoDao()
    }
}
#+END_SRC
** ViewModel的依赖注入
- 通过上面的学习，那我们如果在ViewModel中创建Repository要如何实现呢，可以如下:
#+BEGIN_SRC kotlin
//1. 仓库层
class Repository @Inject constructor(){
    @Inject
    lateinit var apiService: ApiService
    suspend fun getData(): RepoResponse {
        return apiService.searRepos(1, 5)
    }
}
//2. ViewModel层
@ActivityRetainedScoped
class MyViewModel @Inject constructor(private val repository: Repository): ViewModel() {
    var result: MutableLiveData<String> = MutableLiveData()
    fun doWork() {
        viewModelScope.launch {
            runCatching {
                withContext(Dispatchers.IO){
                    repository.getData()
                }
            }.onSuccess {
                result.value="RepoResponse=${gson().toJson(it)}"
            }.onFailure {
                result.value=it.message
            }
        }
    }
}
//3. Activity层
@AndroidEntryPoint
class HiltMvvmActivity : AppCompatActivity() {
    @Inject
    lateinit var viewModel: MyViewModel
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_hilt_mvvm)
        viewModel.result.observe(this, Observer {
            LjyLogUtil.d("result:$it")
        })
        lifecycleScope
        viewModel.doWork()
    }
}
#+END_SRC
*** ViewModel 和 @ViewModelInject 注解
- 这种改变了获取ViewModel实例的常规方式, 为此Hilt专门为其提供了一种独立的依赖注入方式: @ViewModelInject
#+BEGIN_SRC kotlin
//1. 添加两个额外的依赖
implementation 'androidx.hilt:hilt-lifecycle-viewmodel:1.0.0-alpha02'
kapt 'androidx.hilt:hilt-compiler:1.0.0-alpha02'
//2. 修改MyViewModel: 去掉@ActivityRetainedScoped注解，把@Inject改为@ViewModelInject
class MyViewModel @ViewModelInject constructor(private val repository: Repository): ViewModel() {
}
//3. activity中viewModel获取改为常规写法
@AndroidEntryPoint
class HiltMvvmActivity : AppCompatActivity() {
//    @Inject
//    lateinit var viewModel: MyViewModel
    val viewModel: MyViewModel by viewModels()
//  或  val viewModel: MyViewModel by lazy { ViewModelProvider(this).get(MyViewModel::class.java) }
}
#+END_SRC
*** SavedStateHandle 和 @assist注解
- Activity/Fragment被销毁一般有三种情况：
  - 界面关闭或退出应用
  - Activity 配置 (configuration) 被改变，如旋转屏幕时；
  - 在后台时因运行内存不足被系统回收；
- ViewModel 会处理2的情况，而3的情况就需要使用onSaveInstanceState()保存数据，重建时用SavedStateHandle恢复数据，就要用@assist 注解添加 SavedStateHandle 依赖项
#+BEGIN_SRC kotlin
class MyViewModel @ViewModelInject constructor(
    private val repository: Repository,
    //SavedStateHandle 用于进程被终止时，保存和恢复数据
    @Assisted private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    var result: MutableLiveData<String> = MutableLiveData()
    private val userId: MutableLiveData<String> = savedStateHandle.getLiveData("userId")
    fun doWork() {
        viewModelScope.launch {
            runCatching {
                withContext(Dispatchers.IO) {
                    repository.getData(userId)
                }
            }.onSuccess {
                result.value = "RepoResponse=${Gson().toJson(it)}"
            }.onFailure {
                result.value = it.message
            }
        }
    }
}
#+END_SRC
** 在 Hilt 不支持的类中注入依赖项
- 可以使用 @EntryPoint 注释创建入口点, 调用EntryPointAccessors的静态方法来获得自定义入口点的实例
- EntryPointAccessors提供了四个静态方法：fromActivity、fromApplication、fromFragment、fromView，根据自定义入口的MyEntryPoint的注解@InstallIn所指定的范围选择对应的获取方法；
#+BEGIN_SRC kotlin
@EntryPoint
@InstallIn(ApplicationComponent::class)
interface MyEntryPoint{
    fun getRetrofit():Retrofit
}
#+END_SRC
*** 在ContentProvider中使用
- Hilt支持的入口点中少了一个关键的Android组件：ContentProvider, 主要原因就是ContentProvider.onCreate() 在Application的onCreate() 之前执行，因此很多人会利用这个特性去进行提前初始化, 详见Android Jetpack系列--5. App Startup使用详解, 而Hilt的工作原理是从Application.onCreate()中开始的，即ContentProvider.onCreate()执行之前，Hilt的所有功能都还无法正常工作；
#+BEGIN_SRC kotlin
class MyContentProvider : ContentProvider() {
    override fun onCreate(): Boolean {
        context?.let {
            val appContext = it.applicationContext
            //调用EntryPointAccessors.fromApplication()函数来获得自定义入口点的实例
            val entryPoint = EntryPointAccessors.fromApplication(appContext,MyEntryPoint::class.java)
            //再调用入口点中定义的getRetrofit()函数就能得到Retrofit的实例
            val retrofit = entryPoint.getRetrofit()
            LjyLogUtil.d("retrofit:$retrofit")
        }
        return true
    }
}
#+END_SRC
*** 在 App Startup 中使用
- App Startup 会默认提供一个 InitializationProvider，InitializationProvider 继承 ContentProvider；
#+BEGIN_SRC kotlin
class LjyInitializer : Initializer<Unit> {
    override fun create(context: Context) {
        //调用EntryPointAccessors.fromApplication()函数来获得自定义入口点的实例
        val entryPoint = EntryPointAccessors.fromApplication(context, MyEntryPoint::class.java)
        //再调用入口点中定义的getRetrofit()函数就能得到Retrofit的实例
        val retrofit = entryPoint.getRetrofit()
        LjyLogUtil.d("retrofit:$retrofit")
    }
    override fun dependencies(): List<Class<out Initializer<*>>> {
        return emptyList()
    }
}
#+END_SRC
- 报错解决
  - Expected @HiltAndroidApp to have a value. Did you forget to apply the Gradle Plugin?
#+BEGIN_SRC groovy
android {
    defaultConfig {
            javaCompileOptions {
            annotationProcessorOptions {
                arguments  =  ["room.schemaLocation":
                             "$projectDir/schemas".toString()]
            }
        }
    }
}
//If so, try changing from "arguments  = " to "arguments + = ", as just using equals overwrites anything set previously.
#+END_SRC
** Dagger Hilt - ViewModel的依赖注入及实现原理
- ViewModel的注入方法，使用起来非常简单：
#+BEGIN_SRC kotlin
class ActivityViewModel @ViewModelInject constructor(
    private val repository: Repository,
    @Assisted private val savedState: SavedStateHandle
) : ViewModel() {

}
@AndroidEntryPoint
class MainActivity : AppCompatActivity(R.layout.activity_main) {

    private val viewModel by viewModels<ActivityViewModel>()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

    }
}
#+END_SRC
- ViewModle创建需要借助ViewModel.Factory、而非构造函数直接创建。上面整个注入过程并没有自定义任何factory，仅仅@ViewModelInject一个注解就搞定了，这是怎么实现的呢？
*** viewModels{…}
- viewModels{...}是一个继承Lazy<>的ktx扩展，可以通过by关键字方便地创建ViewModel，以前我在airbnb的Mvrx中见到过类似用法，看来是被Jetpack借鉴了。
- 官方自然不只是简单的借(chao)鉴(xi)，里面自有其玄机
#+BEGIN_SRC kotlin
@MainThread
inline fun <reified VM : ViewModel> ComponentActivity.viewModels(
    noinline factoryProducer: (() -> Factory)? = null
): Lazy<VM> {
    val factoryPromise = factoryProducer ?: {
        // ComponentActivity#getDefaultViewModelProviderFactory()
        defaultViewModelProviderFactory
    }

    return ViewModelLazy(VM::class, { viewModelStore }, factoryPromise)
}
#+END_SRC
- 通过源码知道，ViewModel.Factory默认使用了defaultViewModelProviderFactory。所以只要重写这个defaultViewModelProviderFactory，就可以hook自定义实现进去
*** 重写getDefaultViewModelProviderFactory
- 通过前一篇文章我们知道，Hilt会在编译期修改被注入对象的父类，
#+BEGIN_SRC kotlin
@AndroidEntryPoint
class MainActivity : AppCompatActivity(R.layout.activity_main) {
#+END_SRC
- MainActivity原本继承自AppCompatActivity，但经Hilt处理后父类变为了Hilt_MainActivity
#+BEGIN_SRC java
@Generated("dagger.hilt.android.processor.internal.androidentrypoint.ActivityGenerator")
public abstract class Hilt_MainActivity extends AppCompatActivity implements GeneratedComponentManager<Object> {
  private volatile ActivityComponentManager componentManager;
...
  @Override
  public ViewModelProvider.Factory getDefaultViewModelProviderFactory() {
    ViewModelProvider.Factory factory = DefaultViewModelFactories.getActivityFactory(this);
    if (factory != null) {
      return factory;
    }
    return super.getDefaultViewModelProviderFactory();
  }
}
#+END_SRC 
- HIlt_MainActivity中通过DefaultViewModelFactories.getActivityFactory(this)返回ViewModel.Factory。
#+BEGIN_SRC java
public final class DefaultViewModelFactories {
  @Nullable
  public static ViewModelProvider.Factory getActivityFactory(ComponentActivity activity) {
    return getFactoryFromSet(
        EntryPoints.get(activity, ActivityEntryPoint.class).getActivityViewModelFactory());
  }
}
#+END_SRC 
- 一句话概括：Hilt通过Dagger生成的Component获取ViewModelFactory
  - EntryPoints.get(activity, ActivityEntryPoint.class)创建并获取ActivityComponent，
  - getActivityViewModelFactory()通过Component内的Module获取Factory
*** 创建ActivityComponent
    #+BEGIN_SRC kotlin
public final class EntryPoints {
  @Nonnull
  public static <T> T get(Object component, Class<T> entryPoint) {
    if (component instanceof GeneratedComponent) {
      return entryPoint.cast(component);
    } else if (component instanceof GeneratedComponentManager) {
      return entryPoint.cast(((GeneratedComponentManager<?>) component).generatedComponent());
    } 
  }
}
#+END_SRC
- javas
#+BEGIN_SRC java
@Generated("dagger.hilt.android.processor.internal.androidentrypoint.ActivityGenerator")
public abstract class Hilt_MainActivity extends AppCompatActivity implements GeneratedComponentManager<Object> {
  private volatile ActivityComponentManager componentManager;
...
  @Override
  public final Object generatedComponent() {
    return componentManager().generatedComponent();
  }
  
  protected ActivityComponentManager createComponentManager() {
    return new ActivityComponentManager(this);
  }
  protected final ActivityComponentManager componentManager() {
    if (componentManager == null) {
      synchronized (componentManagerLock) {
        if (componentManager == null) {
          componentManager = createComponentManager();
        }
      }
    }
    return componentManager;
  }
#+END_SRC 
- 如上，Hilt_MainActivity继承自GeneratedComponentManager，ActivityComponentManager获取generatedComponent
#+BEGIN_SRC java
public class ActivityComponentManager implements GeneratedComponentManager<Object> {
 //...
  protected Object createComponent() {
    return ((ActivityComponentBuilderEntryPoint)
            activityRetainedComponentManager.generatedComponent())
        .activityComponentBuilder()
        .activity(activity)
        .build();
  }
}
#+END_SRC 
- 最终通过Hilt_MainActivity的ActivityComponentManager获创建ActivityComponent，ActivityComponentManager内部通过activityRetainedComponentManager（借助ViewModel）保证了ActivityComponent的复用。
*** 获取ViewModelFactory
- 获取ActivityComponent后，通过内部的Model获取ViewModelFactory。
- Hilt中提供了ActivityModule，可以InstallIn到ActivityComponent。ActivityModule中定义了Factory的Provider
#+BEGIN_SRC java
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP_PREFIX)
public final class ViewModelFactoryModules {
    /**
     * Hilt Modules for providing the activity level ViewModelFactory
     */
    @Module
    @InstallIn(ActivityComponent.class)
    public abstract static class ActivityModule {
        @NonNull
        @Multibinds
        abstract Map<String, ViewModelAssistedFactory<? extends ViewModel>> viewModelFactoriesMap();
        @Provides
        @IntoSet
        @NonNull
        @DefaultActivityViewModelFactory
        static ViewModelProvider.Factory provideFactory(
                @NonNull Activity activity,
                @NonNull Application application,
                @NonNull Map<String, Provider<ViewModelAssistedFactory<? extends ViewModel>>>
                        viewModelFactories) {
            // Hilt guarantees concrete activity is a subclass of ComponentActivity.
            SavedStateRegistryOwner owner = (ComponentActivity) activity;
            Bundle defaultArgs = activity.getIntent() != null
                    ? activity.getIntent().getExtras() : null;
            SavedStateViewModelFactory delegate =
                    new SavedStateViewModelFactory(application, owner, defaultArgs);
            return new HiltViewModelFactory(owner, defaultArgs, delegate, viewModelFactories)
#+END_SRC 
- 通过SavedStateViewModelFactory的defaultArgs，将ViewModel所需的参数进行注入
*** 总结
- Hilt在编译期改写Activity或者Fragment的父类，获取了自定义的ViewModel.Factory的方法，从而hook了ViewModle的创建过程，对ViewModel进行注入。整个实现过程借助@InstallIn以及@AndroidEntryPoint的注解，本身就是一个Hilt的最佳实践，值得学习和借鉴


* App Startup: 这块儿内容需要找个开源项目实练一下代码
- App Startup是一个可以用于加速App启动速度的一个库。很多人一听到可以加速App的启动速度？那这是好东西啊，迫不及待地想要将这个库引入到自己的项目当中，结果研究了半天，发现越看越不明白，怎么学着学着还和ContentProvider扯上关系了？
- 所以，在学习App Startup的用法之前，首先我们需要搞清楚的是，App Startup具体是用来解决什么问题的。
- 关注我比较久的朋友应该都知道，LitePal是由我编写并长期维护的一个Android数据库框架。这个框架可以帮助大家自动管理表的创建与升级，并提供方便的数据库操作API。
- 而用过LitePal的朋友一定知道，LitePal有提供一个initialize()接口，在进行所有的数据库操作之前，我们需要在自己的Application当中去调用这个接口进行初始化：
#+BEGIN_SRC kotlin
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        LitePal.initialize(this)
    }
}
#+END_SRC
- 为什么LitePal要求先进行初始化呢？因为Android的数据库中有需要操作都是需要依赖于Context的，在初始化的时候传入一次Context，LitePal会在内部将其保存下来，这样所以有其他数据库接口就不需要再传入Context参数了，从而让API变得更加精简。
- 这确实是个不错的主意，但是并不是只有LitePal想到了这一点，许多库也提供了类似的初始化接口，因此如果你在项目当中引入了非常多的第三方库，那么Application中的代码就可能会变成这个样子：
#+BEGIN_SRC kotlin
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        LitePal.initialize(this)
        AAA.initialize(this)
        BBB.initialize(this)
        CCC.initialize(this)
		DDD.initialize(this)
		EEE.initialize(this)
    }
}
#+END_SRC
- 这样的代码就会显得有些凌乱了对不对？随着你引用的第三方库越来越多，这种情况真的是有可能发生的。
- 于是，有些更加聪明的库设计者，他们想到了一种非常巧妙的办法来避免显示地调用初始化接口，而是可以自动调用初始化接口，这种办法就是借助ContentProvider。
- ContentProvider我们都知道是Android四大组件之一，它的主要作用是跨应用程序共享数据。比如为什么我们可以读取到电话簿中的联系人、相册中的照片等数据，借助的都是ContentProvider。
- 然而这些聪明的库设计者们并没有打算使用ContentProvider来跨应用程序共享数据，只是准备使用它进行初始化而已。我们来看如下代码：
#+BEGIN_SRC kotlin
class MyProvider : ContentProvider() {
    override fun onCreate(): Boolean {
        context?.let {
            LitePal.initialize(it)
        }
        return true
    }
}
#+END_SRC
- 这里我定义了一个MyProvider，并让它继承自ContentProvider，然后我们在onCreate()方法中调用了LitePal的初始化接口。注意在ContentProvider中也是可以获取到Context的。
- 当然，继承了ContentProvider之后，我们是要重写很多个方法的，只不过其他方法在我们这个场景下完全使用不到，所以你可以在那些方法中直接抛出一个异常，或者进行空实现都是可以的。
- 另外不要忘记，四大组件是需要在AndroidManifest.xml文件中进行注册才可以使用的，因此记得添加如下内容：
#+BEGIN_SRC xml
<application ...>
    <provider
        android:name=".MyProvider"
        android:authorities="${applicationId}.myProvider"
        android:exported="false" />
</application>
#+END_SRC
- authorities在这里并没有固定的要求，填写什么值都是可以的，但必须保证这个值在整个手机上是唯一的，所以通常会使用${applicationId}作为前缀，以防止和其他应用程序冲突。
- 那么，自定义的这个MyProvider它会在什么时候执行呢？我们来看一下这张流程图：

[[./pic/appstartup.png]]

- 可以看到，一个应用程序的执行顺序是这个样子的。首先调用Application的attachBaseContext()方法，然后调用ContentProvider的onCreate()方法，接下来调用Application的onCreate()方法。
- 那么，假如LitePal在自己的库当中实现了上述的MyProvider，会发生什么情况呢？
- 你会发现LitePal.initialize()这个接口可以省略了，因为在MyProvider当中这个接口会被自动调用，这样在进入Application的onCreate()方法时，LitePal其实已经初始化过了。
- 有没有觉得这种设计方式很巧妙？它可以将库的用法进一步简化，不需要你主动去调用初始化接口，而是将这个工作在背后悄悄自动完成了。
- 那么有哪些库使用了这种设计方式呢？这个真的有很多了，比如说Facebook的库，Firebase的库，还有我们所熟知的WorkManager，Lifecycles等等。这些库都没有提供一个像LitePal那样的初始化接口，其实就是使用了上述的技巧。
- 看上去如此巧妙的技术方案，那么它有没有什么缺点呢？
- 有，缺点就是，ContentProvider会增加许多额外的耗时。
- 毕竟ContentProvider是Android四大组件之一，这个组件相对来说是比较重量级的。也就是说，本来我的初始化操作可能是一个非常轻量级的操作，依赖于ContentProvider之后就变成了一个重量级的操作了。
- 关于ContentProvider的耗时，Google官方也有给出一个测试结果：
  
[[./pic/contentProviderCost.png]]

- 这是在一台搭载Android 10系统的Pixel2手机上测试的情况。可以看到，一个空的ContentProvider大约会占用2ms的耗时，随着ContentProvider的增加，耗时也会跟着一起增加。如果你的应用程序中使用了50个ContentProvider，那么将会占用接近20ms的耗时。
- 注意这还只是空ContentProvider的耗时，并没有算上你在ContentProvider中执行逻辑的耗时。
- 这个测试结果告诉我们，虽然刚才所介绍的使用ContentProvider来进行初始化的设计方式很巧妙，但是如果每个第三方库都自己创建了一个ContentProvider，那么最终我们App的启动速度就会受到比较大的影响。
- 有没有办法解决这个问题呢？
- 有，就是使用我们今天要介绍的主题：App Startup。
- 我上面花了很长的篇幅来介绍App Startup具体是用来解决什么问题的，因为这部分内容才是App Startup库的核心，只有了解了它是用来解决什么问题的，才能快速掌握它的用法。不然就会像刚开始说的那样，学着学着怎么学到ContentProvider上面去了，一头雾水。
- 那么App Startup是如何解决这个问题的呢？它可以将所有用于初始化的ContentProvider合并成一个，从而使App的启动速度变得更快。
- 具体来讲，App Startup内部也创建了一个ContentProvider，并提供了一套用于初始化的标准。然后对于其他第三方库来说，你们就不需要再自己创建ContentProvider了，都按我的这套标准进行实现就行了，我可以保证你们的库在App启动之前都成功进行初始化。
- 了解了App Startup具体是用来解决什么问题的，以及它的实现原理，接下来我们开始学习它的用法，这部分就非常简单了。
- 首先要使用App Startup，我们要将这个库引入进来：
#+BEGIN_SRC groovy
dependencies {
    implementation "androidx.startup:startup-runtime:1.0.0-alpha01"
}
#+END_SRC
- 接下来我们要定义一个用于执行初始化的Initializer，并实现App Startup库的Initializer接口，如下所示：
#+BEGIN_SRC kotlin
class LitePalInitializer : Initializer<Unit> {
    override fun create(context: Context) {
        LitePal.initialize(context)
    }
    override fun dependencies(): List<Class<out Initializer<*>>> {
        return listOf(OtherInitializer::class.java)
    }
}
#+END_SRC
- 实现Initializer接口要求重现两个方法，在create()方法中，我们去进行之前要进行的初始化操作就可以了，create()方法会把我们需要的Context参数传递进来。
- dependencies()方法表示，当前的LitePalInitializer是否还依赖于其他的Initializer，如果有的话，就在这里进行配置，App Startup会保证先初始化依赖的Initializer，然后才会初始化当前的LitePalInitializer。
- 当然，绝大多数的情况下，我们的初始化操作都是不会依赖于其他Initializer的，所以通常直接返回一个emptyList()就可以了，如下所示：
#+BEGIN_SRC kotlin
class LitePalInitializer : Initializer<Unit> {
    override fun create(context: Context) {
        LitePal.initialize(context)
    }
    override fun dependencies(): List<Class<out Initializer<*>>> {
        return emptyList()
    }
}
#+END_SRC
- 定义好了Initializer之后，接下来还剩最后一步，将它配置到AndroidManifest.xml当中。但是注意，这里的配置是有比较严格的格式要求的，如下所示：
#+BEGIN_SRC xml
<application ...>
	<provider
		android:name="androidx.startup.InitializationProvider"
		android:authorities="${applicationId}.androidx-startup"
		android:exported="false"
		tools:node="merge">
		<meta-data
			android:name="com.example.LitePalInitializer"
			android:value="androidx.startup" />
	</provider>
	
</application>
#+END_SRC
- 上述配置，我们能修改的地方并不多，只有meta-data中的android:name部分我们需要指定成我们自定义的Initializer的全路径类名，其他部分都是不能修改的，否则App Startup库可能会无法正常工作。
- 没错，App Startup库的用法就是这么简单，基本我将它总结成了三步走的操作。
- 引入App Startup的库。
- 自定义一个用于初始化的Initializer。
- 将自定义Initializer配置到AndroidManifest.xml当中。
- 这样，当App启动的时候会自动执行App Startup库中内置的ContentProvider，并在它的ContentProvider中会搜寻所有注册的Initializer，然后逐个调用它们的create()方法来进行初始化操作。
- 只用一个ContentProvider就可以让所有库都正常初始化，Everyone is happy。
- 其实到这里为止，App Startup库的知识就已经讲完了，最后再介绍一个不太常用的知识点吧：延迟初始化。
- 现在我们已经知道，所有的Initializer都会在App启动的时候自动执行初始化操作。但是如果我作为LitePal库的用户，就是不希望它在启动的时候自动初始化，而是想要在特定的时机手动初始化，这要怎么办呢？
- 首先，你得通过分析LitePal源码的方式，找到LitePal用于初始化的Initializer的全路径类名是什么，比如上述例子当中的com.example.LitePalInitializer（注意这里我只是为了讲解这个知识点而举的例子，实际上LitePal还并没有接入App Startup）。
- 然后，在你的项目的AndroidManifest.xml当中加入如下配置：
#+BEGIN_SRC xml
<application ...>
	<provider
		android:name="androidx.startup.InitializationProvider"
		android:authorities="${applicationId}.androidx-startup"
		android:exported="false"
		tools:node="merge">
		<meta-data
			android:name="com.example.LitePalInitializer"
			tools:node="remove" />
	</provider>
</application>
#+END_SRC
- 区别就在于，这里在LitePalInitializer的meta-data当中加入了一个tools:node="remove"的标记。
- 这个标记用于告诉manifest merger tool，在最后打包成APK时，将所有android:name是com.example.LitePalInitializer的meta-data节点全部删除。
- 这样，LitePal库在自己的AndroidManifest.xml中配置的Initializer也会被删除，既然删除了，App Startup在启动的时候肯定就无法初始化它了。
- 而在之后手动去初始化LitePal的代码也极其简单，如下所示：
#+BEGIN_SRC kotlin
AppInitializer.getInstance(this)
    .initializeComponent(LitePalInitializer::class.java)
#+END_SRC
- 将LitePalInitializer传入到initializeComponent()方法当中即可，App Startup库会按照同样的标准去调用其create()方法来执行初始化操作。
- 到这里为止，App Startup的功能基本就全部讲解完了。
- 最后如果让我总结一下的话，这个库的整体用法非常简单，但是可能并不适合所有人去使用。如果你是一个库开发者，并且使用了ContentProvider的方式来进行初始化操作，那么你应该接入App Startup，这样可以让接入你的库的App降低启动耗时。而如果你是一个App开发者，我认为使用ContentProvider来进行初始化操作的概率很低，所以可能App Startup对你来说用处并不大。
- 当然，考虑到业务逻辑分离的代码结构，App的开发者也可以考虑将一些原来放在Application中的初始化代码，移动到一个Initializer中去单独执行，或许可以让你的代码结构变得更加合理与清晰。

* AnchorTask: (安卓启动优化)
- Android 启动优化，大家第一时间可能会想到异步加载。将耗时任务放到子线程加载，等到所有加载任务加载完成之后，再进入首页。
- 多线程异步加载方案确实是 ok 的。但如果遇到前后依赖的关系呢。比如任务2 依赖于任务 1，这时候要怎么解决呢。
- 这时候就可以使用 AnchorTask 解决，它的实现原理是构建一个有向无环图，拓扑排序之后，如果任务 B 依赖任务 A，那么 A 一定排在任务 B 之后。
** 基本使用
*** 第一步：在 moulde build.gradle 配置远程依赖
#+BEGIN_SRC groovy
implementation 'com.xj.android:anchortask:0.1.0'
#+END_SRC
- 最新的版本号可以看这里 lastedt version
*** 第二步：自定义 AnchorTaskB，继承 AnchorTask，重写相应的方法
    #+BEGIN_SRC kotlin
class AnchorTaskB : AnchorTask() {
    override fun isRunOnMainThread(): Boolean {
        return false
    }
    override fun run() {
        val start = System.currentTimeMillis()
        try {
            // 在这里进行操作，这里通过睡眠模拟耗时操作
            Thread.sleep(300)
        } catch (e: Exception) {
        }
        com.xj.anchortask.library.log.LogUtils.i(
            TAG, "AnchorTaskOne: " + (System.currentTimeMillis() - start)
        )
    }
    // 返回依赖的任务，这里是通过 class name 去找到对应的 task
    override fun getDependsTaskList(): List<Class<out AnchorTask>>? {
        return ArrayList<Class<out AnchorTask>>().apply {
            add(AnchorTaskA::class.java)
        }
    }

}
    #+END_SRC
- 如果任务 C 依赖任务 B，任务 A，可以这样写
#+BEGIN_SRC kotlin
class AnchorTaskC : AnchorTask() {
    override fun getDependsTaskList(): List<Class<out AnchorTask>>? {
        return ArrayList<Class<out AnchorTask>>().apply {
            add(AnchorTaskA::class.java)
            add(AnchorTaskB::class.java)
        }
    }

}
#+END_SRC
- 最后，通过 AnchorTaskDispatcher.instance .addTask(AnchorTaskFive()) 添加任务，并调用 start() 方法启动， await() 方法表示阻塞等待所有任务执行完毕。
#+BEGIN_SRC kotlin
AnchorTaskDispatcher.instance.setContext(this).setLogLevel(LogUtils.LogLevel.DEBUG).setTimeOutMillion(1000L).
            .addTask(AnchorTaskZero())
            .addTask(AnchorTaskOne())
            .addTask(AnchorTaskTwo())
            .addTask(AnchorTaskThree())
            .addTask(AnchorTaskFour())
            .addTask(AnchorTaskFive())
            .start()
            .await()
#+END_SRC
** AnchorTaskDispatcher 介绍
- AnchorTaskDispatcher start 方法必须在主线程调用，子线程调用会抛出异常。
- setTimeOutMillion 方法是配合 await() 方法使用的，单独调用没有任何效果，表示 await 等待的超时时间
- await 阻塞当前线程，等待所有任务执行完毕之后，会自动往下走
- await() 方法必须在 start 方法之后调用
- setThreadPoolExecutor 设置 task 执行的线程池
** AnchorTask 介绍
- AnchorTask 实现了 IAnchorTask 接口，主要有几个方法
  - isRunOnMainThread(): Boolean 表示是否在主线程运行，默认值是 false
  - priority(): Int 方法 表示线程的优先级别，默认值是 Process.THREAD_PRIORITY_FOREGROUND
  - needWait() 表示当我们调用 AnchorTaskDispatcher await 时，是否需要等待，return true，表示需要等待改任务执行结束，AnchorTaskDispatcher await 方法才能继续往下执行。
  - fun getDependsTaskList(): List<class&gt;?</class 方法返回前置任务依赖，默认值是返回 null.
  - fun run() 方法，表示任务执行的时候
#+BEGIN_SRC kotlin
interface IAnchorTask : IAnchorCallBack {
     // * 是否在主线程执行
    fun isRunOnMainThread(): Boolean
     // * 任务优先级别
    @IntRange(
        from = Process.THREAD_PRIORITY_FOREGROUND.toLong(),
        to = Process.THREAD_PRIORITY_LOWEST.toLong()
    )
    fun priority(): Int
    /**
     * 调用 await 方法，是否需要等待改任务执行完成
     * true 不需要
     * false 需要
     */
    fun needWait(): Boolean

    // * 当前任务的前置任务，可以用来确定顶点的入度
    fun getDependsTaskList(): List<Class<out AnchorTask>>?
     // * 任务被执行的时候回调
    fun run()
}
AnchorTaskOne : AnchorTask() {
    override fun isRunOnMainThread(): Boolean {
        return false
    }
    override fun run() {
        val start = System.currentTimeMillis()
        try {
            Thread.sleep(300)
        } catch (e: Exception) {
        }
        LogUtils.i(
            TAG, "AnchorTaskOne: " + (System.currentTimeMillis() - start)
        )
    }

}
#+END_SRC
** 监听任务的回调
   #+BEGIN_SRC kotlin
val anchorTask = AnchorTaskTwo()
anchorTask.addCallback(object : IAnchorCallBack {
                           override fun onAdd() {
                               com.xj.anchortask.LogUtils.i(TAG, "onAdd: $anchorTask")
                           }
                           override fun onRemove() {
                               com.xj.anchortask.LogUtils.i(TAG, "onRemove: $anchorTask")
                           }
                           override fun onStart() {
                               com.xj.anchortask.LogUtils.i(TAG, "onStart:$anchorTask ")
                           }
                           override fun onFinish() {
                               com.xj.anchortask.LogUtils.i(TAG, "onFinish:$anchorTask ")
                           }

})
   #+END_SRC

* AnchorTask 是怎么实现的
** 如何构建一个有向无环图
- 这里我们采用 BFS 方法实现，算法思想大概是这样的
  - 建立入度表，入度为 0 的节点先入队
  - 当队列不为空，进行循环判断
    - 节点出队，添加到结果 list 当中
    - 将该节点的邻居入度减 1
    - 若邻居课程入度为 0，加入队列
- 若结果 list 与所有节点数量相等，则证明不存在环。否则，存在环
** 多线程中，任务执行是随机的，那如何保证任务被依赖的任务先于任务执行呢？
- 这里要解决的主要有三个问题
  - 首先我们要解决一个问题，它有哪些前置任务，这个可以用 list 存储，代表它依赖的任务 list。当它所依赖的任务 list 没有执行完毕，当前任务需要等待。
  - 当前任务执行完毕之后，所有依赖它的子任务需要感知到。我们可以用一个 map 来存储这种关系，key 是当前任务，value 是依赖于当前任务的集合（list）
  - 多线程当中，等待和唤醒功能，有多种方式可以实现。wait、notify 机制，ReentrantLock Condition 机制，CountDownLatch 机制。这里我们选择 CountDownLatch 机制，因为 CountDownLatch 有点类似于计数器，特别适合这种场景。
** 具体实现
*** IAnchorTask
- 首先，我们定义一个 IAnchorTask 接口，主要有一个方法
  - isRunOnMainThread(): Boolean 表示是否在主线程运行，默认值是 false
  - priority(): Int 方法 表示线程的优先级别，默认值是 Process.THREAD_PRIORITY_FOREGROUND
  - needWait() 表示当我们调用 AnchorTaskDispatcher await 时，是否需要等待，return true，表示需要等待改任务执行结束，AnchorTaskDispatcher await 方法才能继续往下执行。
  - fun getDependsTaskList(): List<class&gt;?</class 方法返回前置任务依赖，默认值是返回 null.
  - fun run() 方法，表示任务执行的时候
#+BEGIN_SRC kotlin
interface IAnchorTask : IAnchorCallBack {
    // * 是否在主线程执行
    fun isRunOnMainThread(): Boolean
    // * 任务优先级别
    @IntRange(
        from = Process.THREAD_PRIORITY_FOREGROUND.toLong(),
        to = Process.THREAD_PRIORITY_LOWEST.toLong()
    )
    fun priority(): Int
    /**
     * 调用 await 方法，是否需要等待改任务执行完成
     * true 不需要
     * false 需要
     */
    fun needWait(): Boolean
    // * 当前任务的前置任务，可以用来确定顶点的入度
    fun getDependsTaskList(): List<Class<out AnchorTask>>?
    // * 任务被执行的时候回调
    fun run()
}
#+END_SRC
- 它有一个实现类 AnchorTask，增加了 await 和 countdown 方法
  - await 方法，调用它，当前任务会等待
  - countdown() 方法，如果当前计数器值 > 0,会减一，否则，什么也不操作
#+BEGIN_SRC kotlin
abstract class AnchorTask : IAnchorTask {

    private val countDownLatch: CountDownLatch = CountDownLatch(getListSize())
    private fun getListSize() = getDependsTaskList()?.size ?: 0

    companion object {
        const val TAG = "AnchorTask"
    }
    // * self call,await
    fun await() {
        countDownLatch.await()
    }
    // * parent call, countDown
    fun countdown() {
        countDownLatch.countDown()
    }
}
#+END_SRC
*** 排序实现
- 无环图的拓扑排序，这里采用的是 BFS 算法。具体的可以见 AnchorTaskUtils#getSortResult 方法，它有三个参数
  - list 存储所有的任务
  - taskMap: MutableMap<class, AnchorTask&gt; = HashMap()</class存储所有的任务,key 是 Class，value 是 AnchorTask
  - taskChildMap: MutableMap<class, ArrayList<class&gt;?&gt; =<br /> HashMap()</class</class,储存当前任务的子任务， key 是当前任务的 class，value 是 AnchorTask 的 list
- 算法思想
  - 首先找出所有入度为 0 的队列，用 queue 变量存储
  - 当队列不为空，进行循环判断。
    - 从队列 pop 出，添加到结果队列
    - 遍历当前任务的子任务，通知他们的入度减一（其实是遍历 taskChildMap），如果入度为 0，添加到队列 queue 里面
  - 当结果队列和 list size 不相等试，证明有环
#+BEGIN_SRC kotlin
@JvmStatic
fun getSortResult(
    list: MutableList<AnchorTask>, taskMap: MutableMap<Class<out AnchorTask>, AnchorTask>,
    taskChildMap: MutableMap<Class<out AnchorTask>, ArrayList<Class<out AnchorTask>>?>
): MutableList<AnchorTask> {

    val result = ArrayList<AnchorTask>()
    // 入度为 0 的队列
    val queue = ArrayDeque<AnchorTask>()
    val taskIntegerHashMap = HashMap<Class<out AnchorTask>, Int>()

    // 建立每个 task 的入度关系
    list.forEach { anchorTask: AnchorTask ->
                       val clz = anchorTask.javaClass
                   if (taskIntegerHashMap.containsKey(clz)) {
                       throw AnchorTaskException("anchorTask is repeat, anchorTask is $anchorTask, list is $list")
                   }
                   val size = anchorTask.getDependsTaskList()?.size ?: 0
                   taskIntegerHashMap[clz] = size
                   taskMap[clz] = anchorTask
                   if (size == 0) {
                       queue.offer(anchorTask)
                   }
    }
    // 建立每个 task 的 children 关系
    list.forEach { anchorTask: AnchorTask ->
                       anchorTask.getDependsTaskList()?.forEach { clz: Class<out AnchorTask> ->
                                                                      var list = taskChildMap[clz]
                                                                  if (list == null) {
                                                                      list = ArrayList<Class<out AnchorTask>>()
                                                                  }
                                                                  list.add(anchorTask.javaClass)
                                                                  taskChildMap[clz] = list
                       }
    }
    // 使用 BFS 方法获得有向无环图的拓扑排序
    while (!queue.isEmpty()) {
        val anchorTask = queue.pop()
        result.add(anchorTask)
        val clz = anchorTask.javaClass
        taskChildMap[clz]?.forEach { // 遍历所有依赖这个顶点的顶点，移除该顶点之后，如果入度为 0，加入到改队列当中
                                     var result = taskIntegerHashMap[it] ?: 0
                                     result--
                                     if (result == 0) {
                                         queue.offer(taskMap[it])
                                     }
                                     taskIntegerHashMap[it] = result
        }
    }
    // size 不相等，证明有环
    if (list.size != result.size) {
        throw AnchorTaskException("Ring appeared，Please check.list is $list, result is $result")
    }
    return result
}
#+END_SRC
*** AnchorTaskDispatcher
- AnchorTaskDispatcher 这个类很重要，有向无环图的拓扑排序和多线程的依赖唤醒，都是借助这个核心类完成的。
- 它主要有几个成员变量
#+BEGIN_SRC kotlin
// 存储所有的任务
private val list: MutableList<AnchorTask> = ArrayList()

// 存储所有的任务,key 是 Class<out AnchorTask>，value 是 AnchorTask
private val taskMap: MutableMap<Class<out AnchorTask>, AnchorTask> = HashMap()

// 储存当前任务的子任务， key 是当前任务的 class，value 是 AnchorTask 的 list
private val taskChildMap: MutableMap<Class<out AnchorTask>, ArrayList<Class<out AnchorTask>>?> =
    HashMap()

// 拓扑排序之后的主线程任务
private val mainList: MutableList<AnchorTask> = ArrayList()

// 拓扑排序之后的子线程任务
private val threadList: MutableList<AnchorTask> = ArrayList()

//需要等待的任务总数，用于阻塞
private lateinit var countDownLatch: CountDownLatch

//需要等待的任务总数，用于CountDownLatch
private val needWaitCount: AtomicInteger = AtomicInteger()
#+END_SRC
- 它有一个比较重要的方法 setNotifyChildren(anchorTask: AnchorTask) ，有一个方法参数 AnchorTask，它的作用是通知该任务的子任务，当前任务执行完毕，入度数减一。
#+BEGIN_SRC kotlin
/**
 *  通知 child countdown,当前的阻塞任务书也需要 countdown
 */
fun setNotifyChildren(anchorTask: AnchorTask) {
    taskChildMap[anchorTask::class.java]?.forEach {
        taskMap[it]?.countdown()
    }
    if (anchorTask.needWait()) {
        countDownLatch.countDown()
    }
}
#+END_SRC
- 接下来看一下 start 方法
#+BEGIN_SRC kotlin
start(): AnchorTaskDispatcher {
    if (Looper.myLooper() != Looper.getMainLooper()) {
        throw AnchorTaskException("start method should be call on main thread")
    }
    startTime = System.currentTimeMillis()

    val sortResult = AnchorTaskUtils.getSortResult(list, taskMap, taskChildMap)
    LogUtils.i(TAG, "start: sortResult is $sortResult")
    sortResult.forEach {
        if (it.isRunOnMainThread()) {
            mainList.add(it)
        } else {
            threadList.add(it)
        }
    }

    countDownLatch = CountDownLatch(needWaitCount.get())
    val threadPoolExecutor =
        this.threadPoolExecutor ?: TaskExecutorManager.instance.cpuThreadPoolExecutor

    threadList.forEach {
        threadPoolExecutor.execute(AnchorTaskRunnable(this, anchorTask = it))
    }

    mainList.forEach {
        AnchorTaskRunnable(this, anchorTask = it).run()
    }
    return this
}
#+END_SRC
- 它主要干几件事
  - 检测是否在主线程，不是抛出异常，这里为什么要检测在主线程呢？主要是构建有向无环图的过程，我们必须保证是线程安全的
  - 获取有向无环图的拓扑排序
  - 根据拓扑排序的排序结果，执行相应的任务。可以看到在执行任务的时候，我们使用 AnchorTaskRunnable 包裹起来
#+BEGIN_SRC kotlin
class AnchorTaskRunnable(
    private val anchorTaskDispatcher: AnchorTaskDispatcher,
    private val anchorTask: AnchorTask
) : Runnable {
    override fun run() {
        Process.setThreadPriority(anchorTask.priority())
        //  前置任务没有执行完毕的话，等待，执行完毕的话，往下走
        anchorTask.await()
        anchorTask.onStart()
        // 执行任务
        anchorTask.run()
        anchorTask.onFinish()
        // 通知子任务，当前任务执行完毕了，相应的计数器要减一。
        anchorTaskDispatcher.setNotifyChildren(anchorTask)
    }
}
#+END_SRC
- AnchorTaskRunnable 有点类似于装饰者模式，多线程依赖的执行关系在这里都得到体现，只有几行代码
  - 前置任务没有执行完毕的话，等待，执行完毕的话，往下走
  - 执行任务
  - 通知子任务，当前任务执行完毕了，相应的计数器（入度数）要减一。
*** 总结
- AnchorTask 的原理不复杂，本质是有向无环图与多线程知识的结合。
  - 根据 BFS 构建出有向无环图，并得到它的拓扑排序
  - 在多线程执行过程中，我们是通过任务的子任务关系和 CounDownLatch 确保先后执行关系的
    - 前置任务没有执行完毕的话，等待，执行完毕的话，往下走
    - 执行任务
    - 通知子任务，当前任务执行完毕了，相应的计数器（入度数）要减一。

* AnchorTask 1.0.0 版本正式发布了
** 更新说明
  - 之前的 0.1.0 版本 配置前置依赖任务，是通过 AnchorTask getDependsTaskList 的方式，他是通过 className 找到 AnchorTask，并且内聚在当前的 AnchorTask 中，从全局的角度看 ，这种方式不太直观，1.0.0 放弃了这种方式，参考阿里 Alpha 的方式，通过 addTask(TASK_NAME_THREE).afterTask(TASK_NAME_ZERO, TASK_NAME_ONE)
  - 1.0.0 版本新增了 Project 类，并增加 OnProjectExecuteListener 监听
  - 1.0.0 版本新增 OnGetMonitorRecordCallback 监听，方便统计各个任务的耗时
** 说明
- Android 启动优化，大家第一时间可能会想到异步加载。将耗时任务放到子线程加载，等到所有加载任务加载完成之后，再进入首页。
- 多线程异步加载方案确实是 ok 的。但如果遇到前后依赖的关系呢。比如任务2 依赖于任务 1，这时候要怎么解决呢。
- 假设我们有这样的任务依赖
*** 我们要怎么使用它呢
    #+BEGIN_SRC kotlin
val project =
AnchorProject.Builder().setContext(context).setLogLevel(LogUtils.LogLevel.DEBUG)
.setAnchorTaskCreator(ApplicationAnchorTaskCreator())
.addTask(TASK_NAME_ZERO)
.addTask(TASK_NAME_ONE)
.addTask(TASK_NAME_TWO)
.addTask(TASK_NAME_THREE).afterTask(TASK_NAME_ZERO, TASK_NAME_ONE)
.addTask(TASK_NAME_FOUR).afterTask(TASK_NAME_ONE, TASK_NAME_TWO)
.addTask(TASK_NAME_FIVE).afterTask(TASK_NAME_THREE, TASK_NAME_FOUR)
.build()

project.start().await()

ApplicationAnchorTaskCreator : IAnchorTaskCreator {
    override fun createTask(taskName: String): AnchorTask? {
        when (taskName) {
            TASK_NAME_ZERO -> {
                return AnchorTaskZero()
            }

            TASK_NAME_ONE -> {
                return AnchorTaskOne()
            }
            TASK_NAME_TWO -> {
                return AnchorTaskTwo()
            }
            TASK_NAME_THREE -> {
                return AnchorTaskThree()
            }
            TASK_NAME_FOUR -> {
                return AnchorTaskFour()
            }
            TASK_NAME_FIVE -> {
                return AnchorTaskFive()
            }
        }
        return null
    }
}
    #+END_SRC
- Demo 跑起来，可以看到预期的效果。

[[./pic/anchorTask.png]]

** 基本使用
*** 第一步：在 moulde build.gradle 配置远程依赖
    #+BEGIN_SRC groovy
implementation 'com.xj.android:anchortask:1.0.0'
    #+END_SRC
- 最新的版本号可以看这里 lastedt version
*** 第二步：自定义 AnchorTaskZero，继承 AnchorTask，并指定 taskName，注意 taskName必须是唯一的，因为我们会根据 taskName 找到相应的 AnchorTask 重写相应的方法
    #+BEGIN_SRC kotlin
class AnchorTaskZero() : AnchorTask(TASK_NAME_ZERO) {
    override fun isRunOnMainThread(): Boolean {
        return false
    }
    override fun run() {
        val start = System.currentTimeMillis()
        try {
            Thread.sleep(300)
        } catch (e: Exception) {
        }
        LogUtils.i(
            TAG, "AnchorTaskOne: " + (System.currentTimeMillis() - start)
        )
    }
}
    #+END_SRC
- 如果任务 三 依赖任务 二，任务 一，可以这样写
#+BEGIN_SRC kotlin
addTask(TASK_NAME_THREE).afterTask(TASK_NAME_ZERO, TASK_NAME_ONE)
#+END_SRC
*** 最后，通过 project.start() 方法启动， 如果需要阻塞等待，调用 await() 方法
    #+BEGIN_SRC kotlin
AnchorProject.Builder().setContext(context).setLogLevel(LogUtils.LogLevel.DEBUG)
    .setAnchorTaskCreator(ApplicationAnchorTaskCreator())
    .addTask(TASK_NAME_ZERO)
    .addTask(TASK_NAME_ONE)
    .addTask(TASK_NAME_TWO)
    .addTask(TASK_NAME_THREE).afterTask(TASK_NAME_ZERO, TASK_NAME_ONE)
    .addTask(TASK_NAME_FOUR).afterTask(TASK_NAME_ONE, TASK_NAME_TWO)
    .addTask(TASK_NAME_FIVE).afterTask(TASK_NAME_THREE, TASK_NAME_FOUR)
    .build()
project.start().await()
    #+END_SRC
- 监听任务回调
#+BEGIN_SRC kotlin
project.addListener(object : OnProjectExecuteListener {
                        // project 开始执行的时候
                        override fun onProjectStart() {
                            com.xj.anchortask.LogUtils.i(MyApplication.TAG, "onProjectStart ")
                        }
                        // project 执行一个 task 完成的时候
                        override fun onTaskFinish(taskName: String) {
                            com.xj.anchortask.LogUtils.i(
                                MyApplication.TAG,
                                "onTaskFinish, taskName is $taskName"
                            )
                        }
                        // project 执行完成的时候
                        override fun onProjectFinish() {
                            com.xj.anchortask.LogUtils.i(MyApplication.TAG, "onProjectFinish ")
                        }
})
#+END_SRC
- 添加每个任务执行耗时回调
#+BEGIN_SRC kotlin
project.onGetMonitorRecordCallback = object : OnGetMonitorRecordCallback {

    // 所有 task 执行完毕会调用这个方法，Map 存储了 task 的执行时间， key 是 taskName，value 是时间，单位毫秒
    override fun onGetTaskExecuteRecord(result: Map<String?, Long?>?) {
        onGetMonitorRecordCallback?.onGetTaskExecuteRecord(result)
    }
    // 所有 task 执行完毕会调用这个方法，costTime 执行时间
    override fun onGetProjectExecuteTime(costTime: Long) {
        onGetMonitorRecordCallback?.onGetProjectExecuteTime(costTime)
    }
}
#+END_SRC
** AnchorProject 介绍
- AnchorTaskDispatcher start 方法必须在主线程调用，子线程调用会抛出异常。
- await 阻塞当前线程，等待所有任务执行完毕之后，会自动往下走，await 方法携带一个参数，timeOutMillion 表示超时等待的时间
- await() 方法必须在 start 方法之后调用
- 添加任务是通过 AnchorProject.Builder().addTask 添加的，典型的构造模式
- 设置执行的线程池，可以通过 AnchorProject.Builder().setThreadPoolExecutor(TaskExecutorManager.instance.cpuThreadPoolExecutor)
** AnchorTask 介绍
- AnchorTask 实现了 IAnchorTask 接口，主要有几个方法
  - isRunOnMainThread(): Boolean表示是否在主线程运行，默认值是 false
  - priority(): Int 方法 表示线程的优先级别，默认值是 Process.THREAD_PRIORITY_FOREGROUND
  - needWait() 表示当我们调用 AnchorTaskDispatcher await 时，是否需要等待，return true，表示需要等待改任务执行结束，AnchorTaskDispatcher await 方法才能继续往下执行。
  - fun run() 方法，表示任务执行的时候
#+BEGIN_SRC kotlin
interface IAnchorTask : IAnchorCallBack {
    // * 是否在主线程执行
    fun isRunOnMainThread(): Boolean
    // * 任务优先级别
    @IntRange(
        from = Process.THREAD_PRIORITY_FOREGROUND.toLong(),
        to = Process.THREAD_PRIORITY_LOWEST.toLong()
    )
    fun priority(): Int
    /**
     * 调用 await 方法，是否需要等待改任务执行完成
     * true 不需要
     * false 需要
     */
    fun needWait(): Boolean
    // * 任务被执行的时候回调
    fun run()
}
class AnchorTaskOne : AnchorTask() {
    override fun isRunOnMainThread(): Boolean {
        return false
    }
    override fun run() {
        val start = System.currentTimeMillis()
        try {
            Thread.sleep(300)
        } catch (e: Exception) {
        }
        LogUtils.i(
            TAG, "AnchorTaskOne: " + (System.currentTimeMillis() - start)
        )
    }
}
#+END_SRC
** 监听任务的回调
   #+BEGIN_SRC kotlin
val anchorTask = AnchorTaskTwo()
anchorTask.addCallback(object : IAnchorCallBack {
                           override fun onAdd() {
                               com.xj.anchortask.LogUtils.i(TAG, "onAdd: $anchorTask")
                           }
                           override fun onStart() {
                               com.xj.anchortask.LogUtils.i(TAG, "onStart:$anchorTask ")
                           }
                           override fun onFinish() {
                               com.xj.anchortask.LogUtils.i(TAG, "onFinish:$anchorTask ")
                           }
})
   #+END_SRC
** 总结
- AnchorTask 的原理不复杂，本质是有向无环图与多线程知识的结合。
  - 根据 BFS 构建出有向无环图，并得到它的拓扑排序
  - 在多线程执行过程中，我们是通过任务的子任务关系和 CounDownLatch 确保先后执行关系的
    - 前置任务没有执行完毕的话，等待，执行完毕的话，往下走
    - 执行任务
    - 通知子任务，当前任务执行完毕了，相应的计数器（入度数）要减一。

* Android - 一种新奇的冷启动速度优化思路(Fragment极度懒加载 + Layout子线程预加载)
** 最常见的优化方案
- 数据懒加载，比如Fragment用户不可见时不进行数据的获取
- 优化布局层级，减少首次inflate layout的耗时
- 将绝大部分sdk的初始化放线程池中运行
- 能用ViewStub的就用ViewStub，按需加载layout
- 一定要尽量避免启动过程中，出现的主线程去unpack一些全局配置的数据
- 不仅仅是三方库可以放子线程进行，一些时效性要求没那么高的逻辑都可以放子线程

** 项目结构
- 在我们的Android项目中，应用过了闪屏之后会进入到主屏 - MainActivity，这个地方我吐槽很多次了，广告闪屏作为launcher真的不是特别靠谱，最好的方式应该是从MainActivity里面来启动AdActivity，甚至是不用Activity，采用一个全屏的AdView都可以。
- 先简单介绍一下我们项目中MainActivity涉及到的结构：
  
[[./pic/tabs.png]]

- 当App冷启动的时候，肉眼可见的要初始化的东西太多了，本身Fragment就是一个相对重的东西。比Activity要轻量很多，但是比View又要重
- 我们首页大概是 4-5个tab，每个tab都是一个Fragment，且第一个tab内嵌了4个Fragment，我这一次的优化主要将目标瞄准了首页的 tab1 以及tab1内嵌的四个tab
** 极致的懒加载
*** 极致的懒加载
- 平时见到的懒加载：
  - 就是初始化fragment的时候，会连同我们写的网络请求一起执行，这样非常消耗性能，最理想的方式是，只有用户点开或滑动到当前fragment时，才进行请求网络的操作。因此，我们就产生了懒加载这样一个说法。
- 由于我们首屏4个子Tab都是继承自一个基类BaseLoadListFragment，数据加载的逻辑非常的死，按照上述的改法，影响面太大。后续可能会徒增烦恼
*** 懒加载方案
  - 首屏加载时，只往ViewPager中塞入默认要展示的tab，剩余的tab用空的占位Fragment代替
  - 当用户滑动到其他tab时，比如滑动到好友动态tab，就用FriendFragment把当前的EmptyPlaceholderFragment替换掉，然后adapter.notifyDataSetChanged
  - 当四个Tab全部替换为数据tab时，清除掉EmptyFragment的引用，释放内存
- 说到这里，又不得不提一个老生常谈的一个坑，因为我们的首页是用的ViewPager + FragmentPagerAdapter来进行实现的。因此就出现了一个坑：
  - ViewPager + FragmentPagerAdapter组合使用，调用notifyDataSetChanged()方法无效，无法刷新Fragment列表
- 下面我会对这个问题进行一下详细的介绍
*** FragmentPagerAdapter与FragmentStatePagerAdapter
- 当我们要使用ViewPager来加载Fragment时，官方为我们提供了这两种Adapter，都是继承自PagerAdapter。
- 区别，上官方描述：
- FragmentPagerAdapter
  - This version of the pager is best for use when there are a handful of typically more static fragments to be paged through, such as a set of tabs. The fragment of each page the user visits will be kept in memory, though its view hierarchy may be destroyed when not visible. This can result in using a significant amount of memory since fragment instances can hold on to an arbitrary amount of state. For larger sets of pages, consider FragmentStatePagerAdapter.
- FragmentStatePagerAdapter
  - This version of the pager is more useful when there are a large number of pages, working more like a list view. When pages are not visible to the user, their entire fragment may be destroyed, only keeping the saved state of that fragment. This allows the pager to hold on to much less memory associated with each visited page as compared toFragmentPagerAdapter at the cost of potentially more overhead when switching between pages
- 总结：
  - 使用FragmentStatePagerAdapter时，如果tab对于用户不可见了，Fragment就会被销毁，FragmentPagerAdapter则不会，使用FragmentPagerAdapter时，所有的tab上的Fragment都会hold在内存里
  - 当tab非常多时，推荐使用FragmentStatePagerAdapter
  - 当tab不多，且固定时，推荐用FragmentPagerAdapter
- 我们项目中就是使用的ViewPager+FragmentPagerAdapter。
*** FragmentPagerAdapter的刷新问题
- 正常情况，我们使用adapter时，想要刷新数据只需要：
  - 更新dataSet
  - 调用notifyDataSetChanged()
- 但是，这个在这个Adapter中是不适用的。因为（这一步没耐心的可以直接看后面的总结）：
  - 默认的PagerAdapter的destoryItem只会把Fragment detach掉，而不会remove
  - 当再次调用instantiateItem的时候，之前detach掉的Fragment，又会从mFragmentManager中取出，又可以attach了
- _这里关于 instantiateItem()方法以及dataSetChanged()以及getItemPosition()源码我省略掉了，改天需要进阶的时候再搜一遍自己review一遍_
- 简单总结一下：
  - 1，ViewPager的dataSetChanged()中会去用adapter.getItemPosition来判断是否要移除当前Item（position = POSITION_NONE时remove）
  - 2，PagerAdapter的getItemPosition默认实现为POSITION_UNCHANGED
- 上述两点导致ViewPager构建完成Adapter之后，不会有机会调用到Adapter的instantiateItem了。
- 再者，即使重写了getItemPosition方法，每次返回POSITION_NONE，还是不会替换掉Fragment，这是因为instantiateItem方法中，会根据getItemId()去从FragmetnManager中找到已经创建好的Fragment返回回去，而getItemId()的默认实现是return position。
*** FragmentPagerAdapter刷新的正确姿势
- 重写getItemId()和getItemPosition()
#+BEGIN_SRC java
class TabsAdapter extends FragmentPagerAdapter {
    private ArrayList<Fragment> mFragmentList;
    private ArrayList<String> mPageTitleList;
    private int mCount;
    TabsAdapter(FragmentManager fm, ArrayList<Fragment> fragmentList, ArrayList<String> pageTitleList) {
        super(fm);
        mFragmentList = fragmentList;
        mCount = fragmentList.size();
        mPageTitleList = pageTitleList;
    }
    @Override public Fragment getItem(int position) {
        return mFragmentList.get(position);
    }
    @Override public CharSequence getPageTitle(int position) {
        return mPageTitleList.get(position);
    }
    @Override public int getCount() {
        return mCount;
    }
    @Override public long getItemId(int position) {
        //这个地方的重写非常关键，super中是返回position，
        //如果不重写，还是会继续找到FragmentManager中缓存的Fragment
        return mFragmentList.get(position).hashCode();
    }
    @Override public int getItemPosition(@NonNull Object object) {
        //不在数据集合里面的话，return POSITION_NONE，进行item的重建
        int index = mFragmentList.indexOf(object);
        if (index == -1) {
            return POSITION_NONE;
        } else {
            return mFragmentList.indexOf(object);
        }
    }
    void refreshFragments(ArrayList<Fragment> fragmentList) {
        mFragmentList = fragmentList;
        notifyDataSetChanged();
    }
}#+END_SRC 
- 其他的相关代码：
**** （1）实现ViewPager.OnPageChangeListener，来监控ViewPager的滑动状态，才可以在滑动到下一个tab的时候进行Fragment替换的操作，其中mDefaultTab是我们通过接口返回的当前启动展示的tab序号
     #+BEGIN_SRC java
  @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
    }
    @Override
    public void onPageSelected(int position) {
        mCurrentSelectedTab = position;
    }
    @Override
    public void onPageScrollStateChanged(int state) {
        if (!hasReplacedAllEmptyFragments && mCurrentSelectedTab != mDefaultTab && state == 0) {
            //当满足： 1. 没有全部替换完 2. 当前tab不是初始化的默认tab（默认tab不会用空的Fragment去替换） 3. 滑动结束了，即state = 0
            replaceEmptyFragmentsIfNeed(mCurrentSelectedTab);
        }
    }
     #+END_SRC   
- 备注：
  - onPageScrollStateChanged接滑动的状态值。一共有三个取值：
    - 0：什么都没做
    - 1：开始滑动
    - 2：滑动结束
  - 一次引起页面切换的滑动，state的顺序分别是： 1  ->  2  ->  0
**** （2）进行Fragment的替换，这里因为我们的tab数量是可能根据全局config信息而改变的，所以这个地方写的稍微纠结了一些。
     #+BEGIN_SRC java
    /**
     * 如果全部替换完了，直接return
     * 替换过程：
     * 1. 找到当前空的tab在mEmptyFragmentList 中的实际下标
     *
     * @param tabId 要替换的tab的tabId - （当前空的Fragment在adapter数据列表mFragmentList的下标）
     */
    private void replaceEmptyFragmentsIfNeed(int tabId) {
        if (hasReplacedAllEmptyFragments) {
            return;
        }
        int tabRealIndex = mEmptyFragmentList.indexOf(mFragmentList.get(tabId)); //找到当前的空Fragment在 mEmptyFragmentList 是第几个
        if (tabRealIndex > -1) {
            if (Collections.replaceAll(mFragmentList, mEmptyFragmentList.get(tabRealIndex), mDataFragmentList.get(tabRealIndex))) {
                mTabsAdapter.refreshFragments(mFragmentList); //将mFragmentList中的相应empty fragment替换完成之后刷新数据
                boolean hasAllReplaced = true;
                for (Fragment fragment : mFragmentList) {
                    if (fragment instanceof EmptyPlaceHolderFragment) {
                        hasAllReplaced = false;
                        break;
                    }
                }
                if (hasAllReplaced) {
                    mEmptyFragmentList.clear(); //全部替换完成的话，释放引用
                }
                hasReplacedAllEmptyFragments = hasAllReplaced;
            }
        }
    }
     #+END_SRC 

** 神奇的的预加载（预加载View，而不是data）
- Android在启动过程中可能涉及到的一些View的预加载方案：
  - WebView提前创建好，因为webview创建的耗时较长，如果首屏有h5的页面，可以提前创建好。
  - Application的onCreate时，就可以开始在子线程中进行后面要用到的Layout的inflate工作了，最先想到的应该是官方提供的AsyncLayoutInflater
  - 填充View的数据的预加载，今天的内容不涉及这一项
*** 需要预加载什么
- 直接看图，这个是首页四个子Tab Fragment的基类的layout，因为某些东西设计的不合理，导致层级是非常的深，直接导致了首页上的三个tab加上FeedMainFragment自身，光将这个View inflate出来的时间就非常长。因此我们考虑在子线程中提前inflate layout
*** 修改AsyncLayoutInflater
- 官方提供了一个类，可以来进行异步的inflate，但是有两个缺点：
- 每次都要现场new一个出来
- 异步加载的view只能通过callback回调才能获得（死穴）
- 因此决定自己封装一个AsyncInflateManager，内部使用线程池，且对于inflate完成的View有一套缓存机制。而其中最核心的LayoutInflater则直接copy出来就好。
- 先看AsyncInflateManager的实现，这里我直接将代码copy进来，而不是截图了，这样你们如果想用其中部分东西，可以直接copy：
#+BEGIN_SRC java
/**
 * 用来提供子线程inflate view的功能，避免某个view层级太深太复杂，主线程inflate会耗时很长，
 * 实就是对 AsyncLayoutInflater进行了抽取和封装
 */
public class AsyncInflateManager {
    private static AsyncInflateManager sInstance;

    private ConcurrentHashMap<String, AsyncInflateItem> mInflateMap; //保存inflateKey以及InflateItem，里面包含所有要进行inflate的任务
    private ConcurrentHashMap<String, CountDownLatch> mInflateLatchMap;
    private ExecutorService mThreadPool; //用来进行inflate工作的线程池

    private AsyncInflateManager() {
        mThreadPool = new ThreadPoolExecutor(4, 4, 0, TimeUnit.MILLISECONDS, new LinkedBlockingDeque<Runnable>());
        mInflateMap = new ConcurrentHashMap<>();
        mInflateLatchMap = new ConcurrentHashMap<>();
    }
    public static AsyncInflateManager getInstance() {
        // 单例
    }
    /**
     * 用来获得异步inflate出来的view
     * @param context
     * @param layoutResId 需要拿的layoutId
     * @param parent      container
     * @param inflateKey  每一个View会对应一个inflateKey，因为可能许多地方用的同一个 layout，但是需要inflate多个，用InflateKey进行区分
     * @param inflater    外部传进来的inflater，外面如果有inflater，传进来，用来进行可能的SyncInflate，
     * @return 最后inflate出来的view
     */
    @UiThread
        @NonNull
        public View getInflatedView(Context context, int layoutResId, @Nullable ViewGroup parent, String inflateKey, @NonNull LayoutInflater inflater) {
        if (!TextUtils.isEmpty(inflateKey) && mInflateMap.containsKey(inflateKey)) {
            AsyncInflateItem item = mInflateMap.get(inflateKey);
            CountDownLatch latch = mInflateLatchMap.get(inflateKey);
            if (item != null) {
                View resultView = item.inflatedView;
                if (resultView != null) { // 拿到了view直接返回
                    removeInflateKey(inflateKey);
                    replaceContextForView(resultView, context);
                    return resultView;
                }
                if (item.isInflating() && latch != null) { // 没拿到view，但是在inflate中，等待返回
                    try {
                        latch.wait();
                    } catch (InterruptedException e) {
                        Log.e(TAG, e.getMessage(), e);
                    }
                    removeInflateKey(inflateKey);
                    if (resultView != null) {
                        replaceContextForView(resultView, context);
                        return resultView;
                    }
                }
                item.setCancelled(true); // 如果还没开始inflate，则设置为false，UI线程进行inflate
            }
        }
        // 拿异步inflate的View失败，UI线程inflate
        return inflater.inflate(layoutResId, parent, false);
    }
    /**
     * inflater初始化时是传进来的application，inflate出来的view的context没法用来startActivity，
     * 因此用MutableContextWrapper进行包装，后续进行替换
     */
    private void replaceContextForView(View inflatedView, Context context) {
        if (inflatedView == null || context == null) return;
        Context cxt = inflatedView.getContext();
        if (cxt instanceof MutableContextWrapper) 
            ((MutableContextWrapper) cxt).setBaseContext(context);
    }
    @UiThread
        private void asyncInflate(Context context, AsyncInflateItem item) {
        if (item == null || item.layoutResId == 0 || mInflateMap.containsKey(item.inflateKey) || item.isCancelled() || item.isInflating()) 
            return;
        onAsyncInflateReady(item);
        inflateWithThreadPool(context, item);
    }

    private void onAsyncInflateReady(AsyncInflateItem item) { }
    private void onAsyncInflateStart(AsyncInflateItem item) { }
    private void onAsyncInflateEnd(AsyncInflateItem item, boolean success) {
        item.setInflating(false);
        CountDownLatch latch = mInflateLatchMap.get(item.inflateKey);
        if (latch != null)  // 释放锁
            latch.countDown();
    }
    private void removeInflateKey(String inflateKey) { }
    private void inflateWithThreadPool(Context context, AsyncInflateItem item) {
        mThreadPool.execute(new Runnable() {
                @Override
                public void run() {
                    if (!item.isInflating() && !item.isCancelled()) {
                        try {
                            onAsyncInflateStart(item);
                            item.inflatedView = new BasicInflater(context).inflate(item.layoutResId, item.parent, false);
                            onAsyncInflateEnd(item, true);
                        } catch (RuntimeException e) {
                            Log.e(TAG, "Failed to inflate resource in the background! Retrying on the UI thread", e);
                            onAsyncInflateEnd(item, false);
                        }
                    }
                }
            });
    }
    /**
     * copy from AsyncLayoutInflater - actual inflater
     */
    private static class BasicInflater extends LayoutInflater {
        private static final String[] sClassPrefixList = new String[]{"android.widget.", "android.webkit.", "android.app."};
        BasicInflater(Context context) {
            super(context);
        }
        public LayoutInflater cloneInContext(Context newContext) {
            return new BasicInflater(newContext);
        }
        protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException {
            for (String prefix : sClassPrefixList) {
                try {
                    View view = this.createView(name, prefix, attrs);
                    if (view != null) {
                        return view;
                    }
                } catch (ClassNotFoundException ignored) {
                }
            }
            return super.onCreateView(name, attrs);
        }
    }
}
#+END_SRC 
- 这里我用一个AsyncInflateItem来管理一次要inflate的一个单位，
#+BEGIN_SRC java
public class AsyncInflateItem {
    String inflateKey;
    int layoutResId;
    ViewGroup parent;
    OnInflateFinishedCallback callback;
    View inflatedView;
    private boolean cancelled;
    private boolean inflating;
    //还有一些set get方法
}
#+END_SRC 
- 以及最后inflate的回调callback：
#+BEGIN_SRC java
public interface OnInflateFinishedCallback {
    void onInflateFinished(AsyncInflateItem result);
}
#+END_SRC 
- 经过这样的封装，外面可以直接在Application的onCreate中，开始异步的inflate view的任务。调用如下：
#+BEGIN_SRC java
AsyncInflateUtil.startTask();
public class AsyncInflateUtil {
    public static void startTask() {
        Context context = new MutableContextWrapper(CommonContext.getApplication());
        AsyncInflateManager.getInstance().asyncInflateViews(context,
                new AsyncInflateItem(InflateKey.TAB_1_CONTAINER_FRAGMENT, R.layout.fragment_main),
                new AsyncInflateItem(InflateKey.SUB_TAB_1_FRAGMENT, R.layout.fragment_load_list),
                new AsyncInflateItem(InflateKey.SUB_TAB_2_FRAGMENT, R.layout.fragment_load_list),
                new AsyncInflateItem(InflateKey.SUB_TAB_3_FRAGMENT, R.layout.fragment_load_list),
                new AsyncInflateItem(InflateKey.SUB_TAB_4_FRAGMENT, R.layout.fragment_load_list));
    }
    public class InflateKey {
        public static final String TAB_1_CONTAINER_FRAGMENT = "tab1";
        public static final String SUB_TAB_1_FRAGMENT = "sub1";
        public static final String SUB_TAB_2_FRAGMENT = "sub2";
        public static final String SUB_TAB_3_FRAGMENT = "sub3";
        public static final String SUB_TAB_4_FRAGMENT = "sub4";
    }
}
#+END_SRC 
- 注意：这里会有一个坑。就是在Application的onCreate中，能拿到的Context只有Application，这样inflate的View，View持有的Context就是Application，这会导致一个问题。
- 如果用View.getContext()这个context去进行Activity的跳转就会。。抛异常
- Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?
- 而如果想要传入Activity来创建LayoutInflater，时机又太晚。众所周知，Context是一个抽象类，实现它的包装类就是ContextWrapper，而Activity、Appcation等都是ContextWrapper的子类，然而，ContextWrapper还有一个神奇的子类，
#+BEGIN_SRC java
 package android.content;
/**
 * Special version of {@link ContextWrapper} that allows the base context to
 * be modified after it is initially set.
 */
public class MutableContextWrapper extends ContextWrapper {
    public MutableContextWrapper(Context base) {
        super(base);
    }
    
    /**
     * Change the base context for this ContextWrapper. All calls will then be
     * delegated to the base context.  Unlike ContextWrapper, the base context
     * can be changed even after one is already set.
     * 
     * @param base The new base context for this wrapper.
     */
    public void setBaseContext(Context base) {
        mBase = base;
    }
}
#+END_SRC 
*** 装饰器模式
- 可以看到Android上Context的设计采用了装饰器模式，装饰器模式极大程度的提高了灵活性。这个例子对我最大的感受就是，当官方没有提供MutableContextWrapper这个类时，其实我们自己也完全可以通过同样的方式去进行实现。思维一定要灵活~
** 总结
- 常见的启动速度优化的方案有：
  - 数据懒加载，比如Fragment用户不可见时不进行数据的获取
  - 优化布局层级，减少首次inflate layout的耗时
  - 将绝大部分sdk的初始化放线程池中运行
  - 能用ViewStub的就用ViewStub，按需加载layout
  - 一定要尽量避免启动过程中，出现的主线程去unpack一些全局配置的数据
  - 不仅仅是三方库可以放子线程进行，一些时效性要求没那么高的逻辑都可以放子线程
- 这些都可以在网上找到大量的文章以及各个大佬的实现方案。
- 首先，优化的大方向肯定先定好：
  - 懒加载
  - 预加载
- 懒加载：
  - 首屏加载时，只往ViewPager中塞入默认要展示的tab，剩余的tab用空的占位Fragment代替
  - 当用户滑动到其他tab时，比如滑动到好友动态tab，就用FriendFragment把当前的EmptyPlaceholderFragment替换掉，然后adapter.notifyDataSetChanged
  - 当四个Tab全部替换为数据tab时，清除掉EmptyFragment的引用，释放内存
- 预加载：
  - Application onCreate方法中，针对后续所有的Fragment，在子线程中将Layout先给inflate出来
  - 针对inflate完成的View加入一套缓存的存取机制，以及等待机制
    - 如果正在inflate，则进行阻塞等待
    - 如果已经inflate完成了，取出view，并释放缓存对于View的引用
    - 如果还没有开始Inflate，则在UI线程直接进行inflate
- 从ContextWrapper、MutableContextWrapper类的设计中学到了  ↓
- 写代码的时候，首先要进行设计，选用最合适的设计模式，这样后续赚到的远远大于写一个文档、想一个设计所耗费的时间和脑力成本


* 启动优化
** 启动速度的测量
- 当然，我们而已通过自己的感觉判断启动的快慢，但量化还是非常重要的，不然你都无法向 PM 交差不是。所以，我们有必要了解下 Android 中的启动速度是如何测量的。
*** 方式 1：使用 ADB
- 获取启动速度的第一种方式是使用 ADB，使用下面的指令的时候在启动应用的时候会使用 AMS 进行统计。但是缺点是统计时间不够准确：
#+BEGIN_SRC kotlin
adb shell am start -n ｛包名｝/｛包名｝.{活动名}
#+END_SRC
*** 方式 2：代码埋点
- 在 Application 的 attachBaseContext() 方法中记录开始时间，第一个 Activity 的 onWindowFocusChanged() 中记录结束时间。缺点是统计不完全，因为在 attachBaseContext() 之前还有许多操作。
*** 方式 3：TraceView
- 在 AS 中打开 DDMS，或者到 SDK 安装目录的 tools 目录下面使用 monitor.bat 打开 DDMS。
- TraceView 工具的使用可以参考这篇文章：《Android 性能分析之TraceView使用(应用耗时分析)》
- 通过 TraceView 主要可以得到两种数据：单次执行耗时的方法以及执行次数多的方法。但 TraceView 性能耗损太大，不能比较正确反映真实情况。
*** 方式 4：Systrace
- Systrace 能够追踪关键系统调用的耗时情况，如系统的 IO 操作、内核工作队列、CPU 负载、Surface 渲染、GC 事件以及 Android 各个子系统的运行状况等。但是不支持应用程序代码的耗时分析。
*** 方式 5：Systrace + 插桩
- 类似于 AOP，通过切面为每个函数统计执行时间。这种方式的好处是能够准确统计各个方法的耗时。
- 原理就是
#+BEGIN_SRC java
    public void method() {
        TraceMethod.i();
        // Real work
        TraceMethod.o();
    }
#+END_SRC 
*** 方式 6：录屏
- 录屏方式收集到的时间，更接近于用户的真实体感。可以在录屏之后按帧来进行统计分析。
** 怎么记录安卓app的启动速度
- 1）Android Profiler，可以设置从启动开始监控，得到cpu内存等信息
- 2）Perfetto UI，开发者模式新增加了一个“系统跟踪”的功能，只有安卓10可以用
- 3）MethodTracing  Debug.startMethodTracing() 和 stopMethodTracing() 方法来开始和结束 Tracing。Traceview打开
- 4）profilo可以做线上监控
** 启动优化
*** 一般解决办法
**** 延迟初始化
- 一些逻辑，如果没必要在程序启动的时候就立即初始化，那么可以将其推迟到需要的时候再初始化。比如，我们可以使用单例的方式来获取类的实例，然后在获取实例的时候再进行初始化操作。
- **但是需要注意的是，懒加载要防止集中化，否则容易出现首页显示后用户无法操作的情形。可以按照耗时和是否必要将业务划分到四个维度：必要且耗时，必要不耗时，非必要但耗时，非必要不耗时。**然后对应不同的维度来决定是否有必要在程序启动的时候立即初始化。
**** 防止主线程阻塞
- 一般我们也不会把耗时操作放在主线程里面，毕竟现在有了 RxJava 之后，在程序中使用异步代价并不高。这种耗时操作包括，大量的计算、IO、数据库查询和网络访问等。
- 另外，关于开启线程池的问题下面的话总结得比较好，除了一般意义上线程池和使用普通线程的区别，还要考虑应用启动这个时刻的特殊性：
- 如何开启线程同样也有学问：Thread、ThreadPoolExecutor、AsyncTask、HandlerThread、IntentService 等都各有利弊；例如通常情况下 ThreadPoolExecutor 比 Thread 更加高效、优势明显，但是特定场景下单个时间点的表现 Thread 会比 ThreadPoolExecutor 好：同样的创建对象，ThreadPoolExecutor 的开销明显比 Thread 大。
来自：https://www.jianshu.com/p/f5514b1a826c
**** 布局优化
- 比如，之前我在使用 Fragment 和 ViewPager 搭配的时候，发现虽然 Fragment 可以被复用，但是如果通过 Adapter 为 ViewPager 的每个项目指定了标题，那么这些标题控件不会被复用。当 ViewPager 的条目比较多的时候，甚至会造成 ANR.
- 对于这种布局优化相关的东西，可以参考性能优化的 Android性能优化-布局优化 模块。
**** 使用启动页面防止白屏
- 这种方法只是治标不治本的方法，就是在应用启动的时候避免白屏，可以通过设置自定义主题来实现。
- 这种实现方式可以参考我的开源项目 MarkNote 的实现。
*** 其他借鉴办法
**** 使用 BlockCanary 检测卡顿
BlockCanary 是一个开源项目，类似于 LeakCanary （很多地方也借鉴了 LeakCanary 的东西），主要用来检测程序中的卡顿，项目地址是 Github-BlockCanary. 它的原理是对 Looper 中的 loop() 方法打处的日志进行处理，通过一个自定义的日志输出 Printer 监听方法执行的开始和结束。可以通过该项目作者的文章来了解这个项目：
BlockCanary — 轻松找出Android App界面卡顿元凶
**** GC 优化
- GC 优化的思想就是减少垃圾回收的时间间隔，所以在启动的过程中不要频繁创建对象，特别是大对象，避免进行大量的字符串操作，特别是序列化跟反序列化过程。一些频繁创建的对象，例如网络库和图片库中的 Byte 数组、Buffer 可以复用。如果一些模块实在需要频繁创建对象，可以考虑移到 Native 实现。
**** 类重排
- 如果我们的代码在打包的时候被放进了不同的 dex 里面，当启动的时候，如果需要用到的类分散在各个 dex 里面，那么系统要花额外的时间到各个 dex 里加载类。因此，我们可以通过类重排调整类在 Dex 中的排列顺序，把启动时用到的类放进主 dex 里。
- 目前可以使用 ReDex 的 Interdex 调整类在 Dex 中的排列顺序。
- 可以参考下面这篇文章来了解类重拍在手 Q 中的应用以及他们遇到的各种问题：
- Redex 初探与 Interdex：Andorid 冷启动优化
**** 资源文件重排
- 对应于类重排，还有资源的重排。可以参考下阿里的资源重排优化方案：
- 支付宝 App 构建优化解析：通过安装包重排布优化 Android 端启动性能
- 这种方案的原理时先通过测试找出程序启动过程中需要加载的资源，然后再打包的时候通过修改 7z 压缩工具将上述热点资源放在一起。这样，在系统进行资源加载的时候，这些资源将要用到的资源会一起被加载进程内存当中并缓存，减少了 IO 的次数，同时不需要从磁盘读取文件，来提高应用启动的速度。
**** 类的加载
- 通过 Hook 来去掉应用启动过程中的 verify 来减少启动过程中的耗时。但是这种方式存在虚拟机兼容的问题，在 ART 虚拟机上面进行 Hook 需要兼容几个版本。
** 启动优化方法
- 1、I/O 优化
  - 启动过程不建议出现网络 I/O，相比之下，磁盘 I/O 是启动优化一定要抠的点
- 2、数据重排
  -  Dex 文件用的到的类和安装包 APK 里面各种资源文件一般都比较小，但是读取非常频繁。我们可以利用系统这个机制将它们按照读取顺序重新排列，减少真实的磁盘 I/O 次数。
- 3、类重排
  - 启动过程类加载顺序可以通过复写 ClassLoader 得到。然后通过 ReDex 的Interdex调整类在 Dex 中的排列顺序
- 4、资源文件重排
  - 它们都是通过修改 Kernel 源码，单独编译了一个特殊的 ROM，支付宝安装包重排布优化 Android 
  - 适合出海项目，低端机型
- 5、类的加载
  - 加载类的过程有一个 verify class 的步骤，可以通过 Hook 来去掉 verify 这个步骤，Dalvik比较好用，art平台比较复杂，需要兼容。这对启动速度有几十毫秒的优化。其实最大的优化场景在于首次和覆盖安装时。
- 6、加固会对启动速度有影响
- 7、支付宝GC抑制，Dalvik比较好使，Android 5.0 以下的系统占比已经不高，其次这也会带来一些兼容性问题。一是设备厂商没有加密内存中的 Dalvik 库文件，二是设备厂商没有改动 Google 的 Dalvik 源码。PLT hook，阻止gc线程唤醒。
- 8、无需等待 ODEX 优化的直接 DEX 加载方案，优化低端 Dalvik机型

