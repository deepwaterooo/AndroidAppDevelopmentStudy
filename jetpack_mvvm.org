#+latex_class: cn-article
#+title: Jetpack MVVM
#+author: deepwaterooo

* Jetpack library
- https://blog.csdn.net/Alexwll/article/details/83302173
- Android Jetpack组件的优势：
  - 轻松管理应用程序的生命周期
  - 构建可观察的数据对象，以便在基础数据库更改时通知视图
  - 存储在应用程序轮换中未销毁的UI相关数据，在界面重建后恢复数据
  - 轻松的实现SQLite数据库
  - 系统自动调度后台任务的执行，优化使用性能
  - Android Jetpack组件推荐的使用项目架构
    
[[./pic/jetpack.png]]

- 上面架构组件的功能如下：
  - Activity和Fragment负责产品与用户的交互
  - ViewModel作为数据的存储和驱动
  - Resposity负责调度数据的获取
  - Room储存本地序列化的数据
  - Retrofit获取远程数据的数据

* MVVM
** 关于MVC/MVP/MVVM的一些错误认识
- https://juejin.cn/post/6844903938873901064


* LifeCycle
- LifeCycle 是 Jetpack 提供的一个可感知 Activity 或 Fragment 的生命周期 变化的组件。这个组件方便业务针对生命周期的变化做出相应管理和改变，也可以防止业务内存泄漏。首先了解下与 LifeCycle 相关的概念：
- LifeCycle：抽象类，定义了添加和删除观察者（LifecycleObserver）的抽象方法，也定义了生命周期事件Lifecycle.Event ，以及生命周期状态Lifecycle.State；
- Lifecycle.Event ：LifeCycle的内部枚举类，定义了 LifecycleOwner（也就是Activity 或 Fragment ）的生命周期事件，从 ON_CREATE 到 ON_DESTROY；
- Lifecycle.State：LifeCycle的内部枚举类，定义了生命周期状态。
- LifecycleRegistry： LifeCycle 的实现类，管理LifecycleObserver，维护生命周期状态Lifecycle.State，并负责分发 Activity 或 Fragment 的生命周期事件Lifecycle.Event；
- LifecycleObserver：接口，生命周期观察者，它没有任何方法，依赖注解 OnLifecycleEvent；
- FullLifecycleObserver：接口，继承自LifecycleObserver接口，以生命周期方法（onCreate…onDestroy）的形式观察 Activity 或 Fragment 的生命周期；
- LifecycleEventObserver：接口，继承自LifecycleObserver接口，以生命周期事件（ON_CREATE…ON_DESTROY）的形式观察 Activity 或 Fragment 的生命周期；
- LifecycleOwner：接口，关联 Activity 或 Fragment 相关生命周期事件；
- OnLifecycleEvent：注解，主要是声明方法监听 Lifecycle.Event 事件；
- Lifecycling：辅助类，将 LifecycleObserver 转换为适配器 LifecycleEventObserver（FullLifecycleObserverAdapter、SingleGeneratedAdapterObserver、CompositeGeneratedAdaptersObserver、ReflectiveGenericLifecycleObserver），其中ReflectiveGenericLifecycleObserver 处理 以注解OnLifecycleEvent 声明的LifecycleObserver。
- 通常情况下，业务定义的 LifecycleObserver，一般是通过注解 OnLifecycleEvent 来观察 Activity 或 Fragment 相关生命周期，当 ReportFragment 或 Fragment 的生命周期发生变化时候，ReflectiveGenericLifecycleObserver 通过反射的方式调用 LifecycleObserver 的相关含有OnLifecycleEvent 注解的方法。
- 这里 Activity 的生命周期的监听是通过 ReportFragment 实现的，Fragment 的生命周期的监听是通过 它自身生命周期回调实现的。另外，定义在 LifecycleObserver 中声明的生命周期事件，都是在 Activity 或 Fragment 的自身生命周期方法调用之后再调用的。由于 LifecycleRegistry 在 addObserver 的时候，会以一个链表结构的 Map 来存储 LifecycleObserver，所以注册的相关 LifecycleObserver，最后接受处理生命周期事件时，也是按照添加顺序依次触发的。
** Activity 中的 LifeCycle 的流程是：
- 在 Activity 中实现 LifecycleOwner 接口，并创建 LifecycleRegistry 对象；
- 在 ReportFragment 中，当前版本SDK 大于等于 29（也就是安卓10）时，会创建 Activity 的生命周期监听器，否则就使用 ReportFragment 的生命周期作为监听；
- 当 ReportFragment的生命周期发生变化时，通过 ReportFragment 中的 activity 对象，获取 LifecycleOwner对象 ，然后获取 Lifecycle 的实现类 LifecycleRegistry 对象，然后调用它的 handleLifecycleEvent 方法；
- 添加生命周期观察者LifecycleObserver，通过 Activity 获取 Lifecycle的实现类 LifecycleRegistry 对象，调用 addObserver 方法，移除生命周期观察者LifecycleObserver，调用 removeObserver ；
- addObserver 方法会创建一个 ObserverWithState 对象，并将LifecycleObserver对象传递给 ObserverWithState 的构造函数，在这个方法中，通过 Lifecycling 创建一个 实现了 LifecycleEventObserver 的适配器对象，LifecycleObserver对象被包装在LifecycleEventObserver 的适配器对象中；
- LifecycleRegistry 会用一个 链表的 Map 去维护 LifecycleObserver对象 和 ObserverWithState 对象，也会维护 生命周期状态 Lifecycle.State；
- LifecycleRegistry 对象 接受 handleLifecycleEvent 时，就会触发添加的 LifecycleEventObserver 的 onStateChanged方法；然后适配者（FullLifecycleObserverAdapter、SingleGeneratedAdapterObserver、CompositeGeneratedAdaptersObserver、ReflectiveGenericLifecycleObserver）通知LifecycleObserver观察者。
- Fragment 中的 LifeCycle 的流程，除了 生命周期的监听方式不一样以外，其它的和 Activity 一样。Fragment 是在自身的生命周期方法回调中做的处理。
** 使用
- 定义生命周期观察者，使用注解 OnLifecycleEvent 定义生命周期事件：
#+BEGIN_SRC kotlin
open class BizObserver : LifecycleObserver {
    @OnLifecycleEvent(value = Lifecycle.Event.ON_CREATE)
    fun onCreate() {
        Log.d("LogUtils", "onCreate() "); // 可是为什么我打印不出来呢？
    }
    @OnLifecycleEvent(value = Lifecycle.Event.ON_START)
    fun onStart() {
        Log.d("LogUtils", "onStart() "); 
    }
    @OnLifecycleEvent(value = Lifecycle.Event.ON_RESUME)
    fun onResume() {
        Log.d("LogUtils", "onResume() "); 
    }
    @OnLifecycleEvent(value = Lifecycle.Event.ON_PAUSE)
    fun onPause() {
        Log.d("LogUtils", "onPause() "); 
    }
    @OnLifecycleEvent(value = Lifecycle.Event.ON_STOP)
    fun onStop() {
        Log.d("LogUtils", "onStop() "); 
    }
    @OnLifecycleEvent(value = Lifecycle.Event.ON_DESTROY)
    fun onDestroy() {
        Log.d("LogUtils", "onDestroy() "); 
    }
}
#+END_SRC
- 或者 使用 DefaultLifecycleObserver 观察生命周期：
#+BEGIN_SRC kotlin
open class BizObserver : DefaultLifecycleObserver {

    override fun onCreate(owner: LifecycleOwner) {
        Log.d("LogUtils", "onCreate() ");
    }
    override fun onStart(owner: LifecycleOwner) {
        Log.d("LogUtils", "onStart() "); 
    }
    override fun onResume(owner: LifecycleOwner) {
        Log.d("LogUtils", "onResume() "); 
    }
    override fun onPause(owner: LifecycleOwner) {
        Log.d("LogUtils", "onPause() "); 
    }
    override fun onStop(owner: LifecycleOwner) {
        Log.d("LogUtils", "onStop() "); 
    }
    override fun onDestroy(owner: LifecycleOwner) {
        Log.d("LogUtils", "onDestroy() "); 
    }
}
#+END_SRC
- 在 Activity 中添加：
#+BEGIN_SRC kotlin
class YourActivity : BaseAppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        this.lifecycle.addObserver(BizXXX())
    }
}
#+END_SRC
- 在 Fragment 中添加：
#+BEGIN_SRC kotlin
class YourFragment : Fragment() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        this.lifecycle.addObserver(BizXXX())
    }
}
#+END_SRC
- 当不能直接使用 LifeCycle 的时候，也可以间接使用 LifeCycle，比如 数据层也要监听生命周期的变化，那么可以将 Presenter 层定义 为一个 LifeOwner：
#+BEGIN_SRC kotlin
open class BizPresenter : LifecycleObserver, LifecycleOwner {

    private val lifecycleRegistry: LifecycleRegistry = LifecycleRegistry(this)
    override fun getLifecycle(): Lifecycle {
        return lifecycleRegistry
    }

    @OnLifecycleEvent(value = Lifecycle.Event.ON_CREATE)
    fun onCreate() {
        lifecycle.addObserver(BizModel())
        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE)
    }

    @OnLifecycleEvent(value = Lifecycle.Event.ON_START)
    fun onStart() {
        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START)
    }

    @OnLifecycleEvent(value = Lifecycle.Event.ON_RESUME)
    fun onResume() {
        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME)
    }

    @OnLifecycleEvent(value = Lifecycle.Event.ON_PAUSE)
    fun onPause() {
        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    }

    @OnLifecycleEvent(value = Lifecycle.Event.ON_STOP)
    fun onStop() {
        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP)
    }

    @OnLifecycleEvent(value = Lifecycle.Event.ON_DESTROY)
    fun onDestroy() {
        lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    }
}
class BizModel : LifecycleObserver {
    @OnLifecycleEvent(value = Lifecycle.Event.ON_CREATE)
    fun onCreate() {
    }
    @OnLifecycleEvent(value = Lifecycle.Event.ON_DESTROY)
    fun onDestroy() {
    }
}
#+END_SRC
- 这种嵌套也是很实用的。其实上面的我自己没有试通，ktl试通了


* Android Jetpack组件Lifecycle基本使用和原理分析
** Lifecycle简介
- 什么是Lifecycle
- Lifecycle提供了可用于构建生命周期感知型组件的类和接口，可以根据 Activity 或 Fragment 的当前生命周期状态自动调整其行为。
- 一句话：可以感知 Activity、Fragment 的生命周期并且可以在相应的回调事件中处理，非常方便
- 这样 Lifecycle 库能有效的避免内存泄漏和解决常见的 Android 生命周期难题！
** Lifecycle基本用法
- 假设我们有一这样的需求：我们想提供一个接口可以感知Activity的生命周期，并且实现回调！用 Lifecycle 是怎么实现的？
*** 定义ILifecycleObserver接口
- 首先我们定义一个接口去实现 LifecycleObserver，然后定义方法，用上OnLifecycleEvent注解。
#+BEGIN_SRC kotlin
interface ILifecycleObserver : LifecycleObserver {
    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    fun onCreate(owner: LifecycleOwner)

    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    fun onStart(owner: LifecycleOwner)
    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    fun onResume(owner: LifecycleOwner)
    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    fun onPause(owner: LifecycleOwner)
    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    fun onStop(owner: LifecycleOwner)
    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    fun onDestroy(owner: LifecycleOwner)
    @OnLifecycleEvent(Lifecycle.Event.ON_ANY)
    fun onLifecycleChanged(owner: LifecycleOwner, event: Lifecycle.Event)
}
#+END_SRC
- 当然你也可以不实现LifecycleObserver而是实现 DefaultLifecycleObserver 接口，Google官方更推荐我们使用 DefaultLifecycleObserver 接口
- 你可以在build.gradle 中依赖，然后就能使用了(在现在新版的2.4.0上运行不通)
#+BEGIN_SRC groovy
def lifecycle_version = "2.2.0"
implementation "androidx.lifecycle:lifecycle-common-java8:$lifecycle_version"
class BaseLifecycle : DefaultLifecycleObserver {
		//处理生命周期回调
}
#+END_SRC
*** 定义ActivityLifecycleObserver类
- 定义ActivityLifecycleObserver类去实现我们定义好的ILifecycleObserver接口
#+BEGIN_SRC kotlin
class ActivityLifecycleObserver : ILifecycleObserver {
    // private val TAG = ActivityLifecycleObserver::class.java.simpleName
    private var TAG = javaClass.simpleName
    
    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    override fun onCreate(owner: LifecycleOwner) {
        Log.d(TAG, "onCreate()")
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    override fun onStart(owner: LifecycleOwner) {
        Log.d(TAG, "onStart()")
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    override fun onResume(owner: LifecycleOwner) {
        Log.d(TAG, "onResume()")
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    override fun onPause(owner: LifecycleOwner) {
        Log.d(TAG, "onPause()")
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    override fun onStop(owner: LifecycleOwner) {
        Log.d(TAG, "onStop()")
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    override fun onDestroy(owner: LifecycleOwner) {
        Log.d(TAG, "onDestroy()")
    }
    override fun onLifecycleChanged(owner: LifecycleOwner, event: Lifecycle.Event) { // <<<<==== 这个方法不能省，会报错
        Log.d(TAG, "onLifecycleChanged(owner = $owner, event = $event)"); 
    }
}
#+END_SRC
- 这个类中，我们在对应的生命周期方法中，打印一句Log，方便测试！这个类就是我们将要使用的类，它是一个观察者，可以观察Activity、Fragment的生命周期
*** 定义BaseActivity
- 在我们的BaseActivity中通过getLifecycle()获取一个Lifecycle，然后把我们的ActivityLifecycleObserver添加进来
#+BEGIN_SRC kotlin
open class BaseActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(ActivityLifecycleObserver())//1
    }
}
#+END_SRC
- Lifecycle是被观察者，通过Add的方式把LifecycleObserver这个观察者添加进来，然后在Activity 执行到对应生命周期的时候通知观察者
- 此时ActivityLifecycleObserver就可以感知Activity的生命周期了，就是这么的神奇
*** 定义LifecycleActivity类
- 让LifecycleActivity**继承 **BaseActivity，然后运行代码，看日志
#+BEGIN_SRC kotlin
class LifecycleActivity : BaseActivity()
#+END_SRC
- LifecycleActivity来作为我们默认启动的Activity，启动LifecycleActivity然后关闭页面，来查看生命周期的日志！
*** 结果日志
    #+BEGIN_SRC kotlin
D/ActivityLifecycleObserver: onCreate()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_CREATE)
D/ActivityLifecycleObserver: onStart()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_START)
D/ActivityLifecycleObserver: onResume()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_RESUME)
D/ActivityLifecycleObserver: onPause()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_PAUSE)
D/ActivityLifecycleObserver: onStop()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_STOP)
D/ActivityLifecycleObserver: onDestroy()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_DESTROY)
D/ActivityLifecycleObserver: onCreate()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_CREATE)
D/ActivityLifecycleObserver: onStart()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_START)
D/ActivityLifecycleObserver: onResume()
D/ActivityLifecycleObserver: onLifecycleChanged(owner = com.me.ktl.MainActivity@5489e09, event = ON_RESUME)
    #+END_SRC
- 每当LifecycleActivity发生了对应的生命周期改变，ActivityLifecycleObserver就会执行对应事件注解的方法，其中onLifecycleChanged的注解是**@OnLifecycleEvent(Lifecycle.Event.ON_ANY)**所以每次都会调用
- 总结上面的现象：
- 我们声明了一个ILifecycleObserver接口，并在方法中加入了 @OnLifecycleEvent(Lifecycle.Event.XXX)注解，在BaseActivity的onCreate方法中通过lifecycle.addObserver(ActivityLifecycleObserver())这行代码，然后就可以在 ActivityLifecycleObserver 对应的方法中实现对具体Activity的生命周期回调了，好神奇！为什么会是这样呢？
** 抛出问题
- Lifecycle是怎样感知生命周期的？
- Lifecycle是如何处理生命周期的？
- LifecycleObserver的方法是怎么回调的呢？
- 为什么LifecycleObserver可以感知到Activity的生命周期
- 下面就一步一步的具体分析，阅读源码，从源码中寻找答案
** Lifecycle的原理分析的前置准备
- 在分析 Lifecycle 源码之前，我们必须先对几个重要的类有感性的认识，方便下面看源码！
*** LifecycleOwner
    #+BEGIN_SRC java
public interface LifecycleOwner {
    /**
     * @return The lifecycle of the provider.
     */
    @NonNull
    Lifecycle getLifecycle();
}
    #+END_SRC
- 生命周期持有者，返回一个Lifecycle对象，如果你使用的是 AndroidX（也属于 Jetpack 一部分）在这Activity 、Fragment 两个类中，默认实现了 LifecycleOwner 接口
#+BEGIN_SRC java
public class ComponentActivity extends androidx.core.app.ComponentActivity implements LifecycleOwner,XXX {
	private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);
    public Lifecycle getLifecycle() {
        return mLifecycleRegistry;
    }
}
public class Fragment implements LifecycleOwner,XXX {
	private final LifecycleRegistry mLifecycleRegistry;
    public Fragment() {
        initLifecycle();
    }
    private void initLifecycle() {
        mLifecycleRegistry = new LifecycleRegistry(this);
        //....
    }
    public Lifecycle getLifecycle() {
        return mLifecycleRegistry;
    }
}
#+END_SRC
- 可以看到我们 Activity 和 Fragment 中默认实现了
- 可以看到在 ComponentActivity 和 Fragment类默认实现了 LifecycleOwner 接口，并在中 getLifecycle()方法返回的是LifecycleRegistry对象，此时 Activity 和 Fragment类中分别持有了 Lifecycle
- 我们先看下 Lifecycle 类是什么
*** Lifecycle
    #+BEGIN_SRC java
public abstract class Lifecycle {
    @MainThread
    public abstract void addObserver(@NonNull LifecycleObserver observer);
    @MainThread
    public abstract void removeObserver(@NonNull LifecycleObserver observer);
    @MainThread
    @NonNull
    public abstract State getCurrentState();
    public enum Event {
    }
    public enum State {
    }
}
    #+END_SRC
- 在Lifecycle类中定义了添加观察者和移除观察者的方法，并定义了两个枚举类，这两个类等一下再具体说
- LifecycleRegistry类是对Lifecycle这个抽象类的具体实现，可以处理多个观察者，如果你自定义 LifecycleOwner可以直接使用它。
- 说完了被观察者，接下来看下观察者LifecycleObserver
*** LifecycleObserver
    #+BEGIN_SRC java
public interface LifecycleObserver {
}
    #+END_SRC
- 就是一个简单的接口，这个接口只是来标志这个是对Lifecycle的观察者，内部没有任何方法，全部都依赖于OnLifecycleEvent注解
#+BEGIN_SRC java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface OnLifecycleEvent {
    Lifecycle.Event value();
}
#+END_SRC
- 注解的值是一个 Lifecycle.Event 也就是 4.2小节没有看的那两个枚举中的一个，接下来去看下Lifecycle中的两个枚举类。
*** Lifecycle.Event和Lifecycle.State
    #+BEGIN_SRC java
public abstract class Lifecycle {
    public enum Event {
        ON_CREATE,
        ON_START,
        ON_RESUME,
        ON_PAUSE,
        ON_STOP,
        ON_DESTROY,
        ON_ANY
    }
    public enum State {
        DESTROYED,
        INITIALIZED,
        CREATED,
        STARTED,
        RESUMED;
        public boolean isAtLeast(@NonNull State state) {
            return compareTo(state) >= 0;
        }
    }
}
    #+END_SRC
- Event：定一个一些枚举常量，和 Activity、Fragment 的生命周期是一一对应的，可以响应其生命周期，其中多了一个ON_ANY，它是可以匹配任何事件的，Event 的使用是和 LifecycleObserver 配合使用的，
#+BEGIN_SRC java
class TestObserver implements LifecycleObserver {
  @OnLifecycleEvent(ON_STOP)
  void onStopped() {}
}
#+END_SRC
- State：当前Lifecycle的自己的目前的状态，它是和Event配合使用的
- Event和State之间的关系
  
[[./pic/stateEvent.jpg]]

*** 总结
- LifecycleOwner：可获取Lifecycle的接口，可以再 Activity、Fragment生命周期改变时，通过LifecycleRegistry类处理对应的生命周期事件，并通知 LifecycleObserver这个观察者
- Lifecycle：是被观察者，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。
- LifecycleObserver：观察者，可以通过被LifecycleRegistry类通过 addObserver(LifecycleObserver o)方法注册,被注册后，LifecycleObserver便可以观察到LifecycleOwner对应的生命周期事件
- Lifecycle.Event：分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。
- Lifecycle.State：Lifecycle组件的当前状态。
- 了解上面的基本内容，就进行具体的源码分析，通过看源码，就能知道整个流程了。
** Lifecycle的源码解析
*** 分析的入口BaseActivity
- 在基类BaseActivity中的一行代码就能实现对应生命周期的回调
    #+BEGIN_SRC kotlin
open class BaseActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(ActivityLifecycleObserver())//1
    }
}
    #+END_SRC
- 我们先看下getLifecycle() 方法，然后在看addObserver(ActivityLifecycleObserver())的内容，注意这时候分成两步了，我们先看getLifecycle()
- 我们点进去这个getLifecycle()方法
*** ComponentActivity 类
- 然后我们来到了ComponentActivity中，代码如下
#+BEGIN_SRC java
public class ComponentActivity extends xxx implements LifecycleOwner,xxx {//1
	private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);//2
	@Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ReportFragment.injectIfNeededIn(this);//4
    }
    public Lifecycle getLifecycle() {
        return mLifecycleRegistry;//3
    }
}
#+END_SRC
- 是不是很熟悉因为，之前我们在 4.1 小节已经看到过了，这里看下重点，在onCreate方法中有一行代码ReportFragment.injectIfNeededIn(this);
- **注释4：**在onCreate方法中，看到初始化了一个ReportFragment，接下来看一下ReportFragment的源码
*** ReportFragment 类
    #+BEGIN_SRC java
public class ReportFragment extends Fragment {
    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        dispatchCreate(mProcessListener);
        dispatch(Lifecycle.Event.ON_CREATE);·
    }
    @Override
    public void onStart() {
        super.onStart();
        dispatchStart(mProcessListener);
        dispatch(Lifecycle.Event.ON_START);
    }
    @Override
    public void onResume() {
        super.onResume();
        dispatchResume(mProcessListener);
        dispatch(Lifecycle.Event.ON_RESUME);
    }
    @Override
    public void onPause() {
        super.onPause();
        dispatch(Lifecycle.Event.ON_PAUSE);
    }
    @Override
    public void onStop() {
        super.onStop();
        dispatch(Lifecycle.Event.ON_STOP);
    }
    @Override
    public void onDestroy() {
        super.onDestroy();
        dispatch(Lifecycle.Event.ON_DESTROY);
        // just want to be sure that we won't leak reference to an activity
        mProcessListener = null;
    }
    private void dispatch(Lifecycle.Event event) {
        Activity activity = getActivity();
        if (activity instanceof LifecycleRegistryOwner) { // 1
            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);
            return;
        }
        if (activity instanceof LifecycleOwner) { // 2
            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();
            if (lifecycle instanceof LifecycleRegistry) 
                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);
        }
    }
}
    #+END_SRC
- 可以看到在 ReportFragment 中的各个生命周期都调用了dispatch(Lifecycle.Event event) 方法，传递了不同的Event的值，这个就是在Activity、Fragment的各个生命周期回调时，Lifecycle 所要处理的生命周期方法。
- 在**dispatch(Lifecycle.Event event)**方法中最终调用了((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);方法
- 看到这儿，还记得咱们在第 3 节的疑问吗？到这儿就可以解答前两个问题了
  - 1.Lifecycle是怎样感知生命周期的？
    - 就是在ReportFragment中的各个生命周期都调用了dispatch(Lifecycle.Event event) 方法，传递了不同的Event的值
  - 2.Lifecycle是如何处理生命周期的？
    - 通过调用了((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);方法，也就是LifecycleRegistry 类来处理这些生命周期。
- 此时，就应该看 LifecycleRegistry 的 handleLifecycleEvent 方法中的代码了
*** LifecycleRegistry 的 handleLifecycleEvent 方法
    #+BEGIN_SRC java
//LifecycleRegistry.java
public void handleLifecycleEvent(@NonNull Lifecycle.Event event) {
    State next = getStateAfter(event);
    moveToState(next);
}
    #+END_SRC
- 根据当前Lifecycle.Event的值，其实也就是 Activity、Fragment 生命周期回调的值，来获取下一个 Lifecycle.State 的状态，也就是 Lifecycle 将要到什么状态
#+BEGIN_SRC java
//LifecycleRegistry.java
static State getStateAfter(Event event) {
    switch (event) {
        case ON_CREATE:
        case ON_STOP:
            return CREATED;
        case ON_START:
        case ON_PAUSE:
            return STARTED;
        case ON_RESUME:
            return RESUMED;
        case ON_DESTROY:
            return DESTROYED;
        case ON_ANY:
            break;
    }
    throw new IllegalArgumentException("Unexpected event value " + event);
}
#+END_SRC
- 上面代码结合这个图看，使用效果更加
  
[[./pic/stateEvent.jpg]]

- 不同的 Lifecycle.Event 的生命周期状态对 Lifecycle.State 的当前状态的取值。
- 继续跟代码，看下当到下一个状态时，要发生什么事情
#+BEGIN_SRC java
//LifecycleRegistry.java
private void moveToState(State next) {
    if (mState == next) 
        return;
    mState = next;
    if (mHandlingEvent || mAddingObserverCounter != 0) {
        mNewEventOccurred = true;
        return;
    }
    mHandlingEvent = true;
    sync(); // 1 <<<<<======
    mHandlingEvent = false;
}
#+END_SRC
***** 注释1： sync()方法
- 然后看 LifecycleRegistry 的 sync 方法
#+BEGIN_SRC java
//LifecycleRegistry.java
private void sync() {
    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();
    if (lifecycleOwner == null) {
        throw new IllegalStateException("LifecycleOwner of this LifecycleRegistry is already"
                + "garbage collected. It is too late to change lifecycle state.");
    }
    while (!isSynced()) {
        mNewEventOccurred = false;
        // no need to check eldest for nullability, because isSynced does it for us.
        if (mState.compareTo(mObserverMap.eldest().getValue().mState) < 0) 
            backwardPass(lifecycleOwner); // 1
        Entry<LifecycleObserver, ObserverWithState> newest = mObserverMap.newest();
        if (!mNewEventOccurred && newest != null && mState.compareTo(newest.getValue().mState) > 0) 
            forwardPass(lifecycleOwner);  // 2
    }
    mNewEventOccurred = false;
}
#+END_SRC
- 如果没有同步过，会比较mState当前的状态和mObserverMap中的eldest和newest的状态做对比，看是往前还是往后；比如mState由STARTED到RESUMED是状态向前，反过来就是状态向后。这个是和 Lifecycle 生命周期有关系，但不是一个东西，具体的看上面贴的图，一目了然！
***** 注释2：往后这里看下往后的代码forwardPass(lifecycleOwner);
- 然后看 LifecycleRegistry 的 forwardPass 方法
#+BEGIN_SRC java
//LifecycleRegistry.java
private void forwardPass(LifecycleOwner lifecycleOwner) {
    Iterator<Entry<LifecycleObserver, ObserverWithState>> ascendingIterator = 
            mObserverMap.iteratorWithAdditions();
    while (ascendingIterator.hasNext() && !mNewEventOccurred) {
        Entry<LifecycleObserver, ObserverWithState> entry = ascendingIterator.next();
        ObserverWithState observer = entry.getValue()； // 1: 获取 ObserverWithState 实例
        while ((observer.mState.compareTo(mState) < 0 && !mNewEventOccurred
                && mObserverMap.contains(entry.getKey()))) {
            pushParentState(observer.mState);
            observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState)); // 2: 调用 ObserverWithState 的 dispatchEvent 方法
            popParentState();
        }
    }
}
#+END_SRC
- 注释1：获取 ObserverWithState 实例
- 注释2：调用 ObserverWithState 的 dispatchEvent 方法

** ObserverWithState
- 这个类名很直接，观察者并且带着 State，
#+BEGIN_SRC java
//ObserverWithState.java
static class ObserverWithState {
    State mState;
    LifecycleEventObserver mLifecycleObserver;
    ObserverWithState(LifecycleObserver observer, State initialState) {
        mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);//1
        mState = initialState;
    }
    void dispatchEvent(LifecycleOwner owner, Event event) {
        State newState = getStateAfter(event);
        mState = min(mState, newState);
        mLifecycleObserver.onStateChanged(owner, event);//2
        mState = newState;
    }
}
#+END_SRC
- 在看dispatchEvent方法之前，先看下构造，ObserverWithState 是怎么初始化的？这里提一句，是在Lifecycle.addObserver(@NonNull LifecycleObserver observer);方法时候初始化的。
- 也就是 lifecycle.addObserver(ActivityLifecycleObserver())
#+BEGIN_SRC kotlin
open class BaseActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        lifecycle.addObserver(ActivityLifecycleObserver())
    }
}
#+END_SRC
- 在这里初始化的。
- ObserverWithState 内部包括了 State 和 LifecycleEventObserver，LifecycleEventObserver 是一个接口，它继承了 LifecycleObserver 接口。
  - 注释1：mLifecycleObserver这个的获取的实例其实是ReflectiveGenericLifecycleObserver，具体的点进去看一眼就明白了，我就不贴代码了，但是得注意在实例化 ReflectiveGenericLifecycleObserver(object);时候把LifecycleObserver，传入ReflectiveGenericLifecycleObserver的构造中了，此时ReflectiveGenericLifecycleObserver持有LifecycleObserver的实例
  - 注释2：关键代码 mLifecycleObserver.onStateChanged(owner, event)，这里其实调用的是ReflectiveGenericLifecycleObserver的onStateChanged方法
- 接下来看下 ReflectiveGenericLifecycleObserver 的 onStateChanged 方法

** ReflectiveGenericLifecycleObserver
   #+BEGIN_SRC java
//ReflectiveGenericLifecycleObserver.java
class ReflectiveGenericLifecycleObserver implements LifecycleEventObserver {
    private final Object mWrapped;
    private final CallbackInfo mInfo;
    ReflectiveGenericLifecycleObserver(Object wrapped) {
        mWrapped = wrapped;//LifecycleObserver的实例
        mInfo = ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());//1
    }
    @Override
    public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Event event) {
        mInfo.invokeCallbacks(source, event, mWrapped);//2
    }
}
   #+END_SRC
- mWrapped其实是LifecycleObserver的实例
- 注释 1：接下来看mInfo的初始化过程，这个是最关键的代码了
- 注意注意注意，此时我们要兵分两路先看注释 1 的代码，此时注释 2 的代码是被回调的代码

** ClassesInfoCache 的 getInfo 方法
   #+BEGIN_SRC java
//ClassesInfoCache.java
CallbackInfo getInfo(Class<?> klass) {
    CallbackInfo existing = mCallbackMap.get(klass);
    if (existing != null) {
        return existing;
    }
    existing = createInfo(klass, null);//1
    return existing;
}
   #+END_SRC
- 这个klass是LifecycleObserver的字节码文件对象（LifecycleObserver.class）字节码？反射的味道，没错继续看下去马上就有结果了。
#+BEGIN_SRC java
private CallbackInfo createInfo(Class<?> klass, @Nullable Method[] declaredMethods) {
    // 1: 获取LifecycleObserver.class 声明的方法，也即是我们例子中ILifecycleObserver接口中声明的方法
    Method[] methods = declaredMethods != null ? declaredMethods : getDeclaredMethods(klass);
    boolean hasLifecycleMethods = false;
    for (Method method : methods) {
        // 2: 遍历方法，获取方法上声明的OnLifecycleEvent注解
        OnLifecycleEvent annotation = method.getAnnotation(OnLifecycleEvent.class);
        if (annotation == null) continue;
        hasLifecycleMethods = true;
      
        Class<?>[] params = method.getParameterTypes();
        int callType = CALL_TYPE_NO_ARG;
        if (params.length > 0) {
            callType = CALL_TYPE_PROVIDER;
            if (!params[0].isAssignableFrom(LifecycleOwner.class)) 
                throw new IllegalArgumentException("invalid parameter type. Must be one and instanceof LifecycleOwner");
        }
        // 3: 获取OnLifecycleEvent注解上的value
        Lifecycle.Event event = annotation.value();
        // 4: 给callType = CALL_TYPE_PROVIDER_WITH_EVENT 赋值
        if (params.length > 1) {
            callType = CALL_TYPE_PROVIDER_WITH_EVENT;
            if (!params[1].isAssignableFrom(Lifecycle.Event.class)) 
                throw new IllegalArgumentException("invalid parameter type. second arg must be an event");
            if (event != Lifecycle.Event.ON_ANY) 
                throw new IllegalArgumentException("Second arg is supported only for ON_ANY value");
        }
        if (params.length > 2) 
            throw new IllegalArgumentException("cannot have more than 2 params");
        // 5: 把callType和当前的method 存储到 MethodReference 中，方便接下来取用
        MethodReference methodReference = new MethodReference(callType, method);
        verifyAndPutHandler(handlerToEvent, methodReference, event, klass);
    }
    CallbackInfo info = new CallbackInfo(handlerToEvent);
    mCallbackMap.put(klass, info);
    mHasLifecycleMethods.put(klass, hasLifecycleMethods);
    return info;
}
#+END_SRC
- 上面代码比较长，但都有用其实就是反射获取方法获取注解值的过程，我们挨个看
- 注释1：获取LifecycleObserver.class 声明的方法，也即是我们例子中ILifecycleObserver接口中声明的方法
- 注释2：遍历方法，获取方法上声明的OnLifecycleEvent注解
- 注释3：获取OnLifecycleEvent注解上的value
- 注释4：给callType = CALL_TYPE_PROVIDER_WITH_EVENT 赋值
- 注释5：把callType和当前的method 存储到 MethodReference 中，方便接下来取用
- 看一下MethodReference中的代码
#+BEGIN_SRC java
//MethodReference.java
static class MethodReference {
    final int mCallType;
    final Method mMethod;
    MethodReference(int callType, Method method) {
        mCallType = callType;
        mMethod = method;
        mMethod.setAccessible(true);
    }
}
#+END_SRC
- 好的，以上的mInfo 赋值的问题就看完了
- 当初在第 7 节在看注释 1 的代码是兵分两路了，现在继续看第 7 节注释 2 的代码吧
- 也即是就是mInfo的invokeCallbacks方法
- 继续看ClassesInfoCache的invokeCallbacks方法
- 点进去来到了 ClassesInfoCache 的 invokeCallbacks方法中
#+BEGIN_SRC java
//ClassesInfoCache.java
void invokeCallbacks(LifecycleOwner source, Lifecycle.Event event, Object target) {
    invokeMethodsForEvent(mEventToHandlers.get(event), source, event, target);
    invokeMethodsForEvent(mEventToHandlers.get(Lifecycle.Event.ON_ANY), source, event,
            target);//ON_ANY也会调用
}
private static void invokeMethodsForEvent(List<MethodReference> handlers,
        LifecycleOwner source, Lifecycle.Event event, Object mWrapped) {
    if (handlers != null) {
        for (int i = handlers.size() - 1; i >= 0; i--) {
            handlers.get(i).invokeCallback(source, event, mWrapped);//1
        }
    }
}
#+END_SRC
- 注释 1：继续看MethodReference 的invokeCallback方法
#+BEGIN_SRC java
//MethodReference.java
void invokeCallback(LifecycleOwner source, Lifecycle.Event event, Object target) {
    //noinspection TryWithIdenticalCatches
    try {
        switch (mCallType) {
            case CALL_TYPE_NO_ARG:
                mMethod.invoke(target);
                break;
            case CALL_TYPE_PROVIDER:
                mMethod.invoke(target, source);
                break;
            case CALL_TYPE_PROVIDER_WITH_EVENT: // 1
                mMethod.invoke(target, source, event);
                break;
        }
    } catch (InvocationTargetException e) {
        throw new RuntimeException("Failed to call observer method", e.getCause());
    } catch (IllegalAccessException e) {
        throw new RuntimeException(e);
    }
}
#+END_SRC
- 看到最后是用反射调用了mMethod.invoke(target);这里的target就是LifecycleObserver之前解释过了
- mCallType和mMethod的值分别是什么呢？就是在前面初始化mInfo存的值，再看下源码
#+BEGIN_SRC java
static class MethodReference {
    final int mCallType;
    final Method mMethod;
    MethodReference(int callType, Method method) {
        mCallType = callType;
        mMethod = method;
        mMethod.setAccessible(true);
    }
    void invokeCallback(LifecycleOwner source, Lifecycle.Event event, Object target) {
        // noinspection TryWithIdenticalCatches
        try {
            switch (mCallType) {
                case CALL_TYPE_NO_ARG:
                    mMethod.invoke(target);
                    break;
                case CALL_TYPE_PROVIDER:
                    mMethod.invoke(target, source);
                    break;
                case CALL_TYPE_PROVIDER_WITH_EVENT:
                    mMethod.invoke(target, source, event);
                    break;
            }
        } catch (InvocationTargetException e) {
            throw new RuntimeException("Failed to call observer method", e.getCause());
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
}
#+END_SRC
由前面分析可以知道mCallType = CALL_TYPE_PROVIDER_WITH_EVENT，mMethod就是当时遍历时当前的方法
由于之前通过Map存储过，所以invokeCallback会被遍历调用，最终会反射调用对方法和注解。
当然其他mCallType的值也会被反射调用
** 总结:在来回顾当初抛出的问题
- 1.Lifecycle是怎样感知生命周期的？
  - 就是在ReportFragment中的各个生命周期都调用了dispatch(Lifecycle.Event event) 方法，传递了不同的Event的值
- 2.Lifecycle是如何处理生命周期的？
  - 通过调用了((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);方法，也就是LifecycleRegistry 类来处理这些生命周期。
- 3.LifecycleObserver的方法是怎么回调是的呢？
  - LifecycleRegistry 的 handleLifecycleEvent方法，然后会通过层层调用最后通过反射到LifecycleObserver方法上的@OnLifecycleEvent(Lifecycle.Event.XXX)注解值，来调用对应的方法
- 4.为什么LifecycleObserver可以感知到Activity的生命周期
  - LifecycleRegistry调用handleLifecycleEvent方法时会传递Event类型，然后会通过层层调用，最后是通过反射获取注解的值，到LifecycleObserver方法上的@OnLifecycleEvent(Lifecycle.Event.XXX)注解上对应的Event的值，注意这个值是和Activity/Fragment的生命周期的一一对应的，所以就可以感知Activity、Fragment的生命周期了。

* Android Jetpack组件LiveData基本使用和原理分析
- LiveData一般是和 ViewModel 配合使用的，但是本文就以单独使用 LiveData 作为例子单独使用，这样可以只关注 LiveData 而不被其他所干扰。
- 本文整体流程：首先要知道什么是 LiveData，然后演示一个例子，来看看 LiveData 是怎么使用的，接着提出问题为什么是这样的，最后读源码来解释原因！
- LiveData 的源码比较简单，底层依赖了 Lifecycle，所以懂 Lifecycle 的源码是关键，我之前写过一篇
- Android Jetpack组件Lifecycle基本使用和原理分析 最好是先看这篇文章，才能更好的理解 LiveData。
- 什么是 LiveData
  - LiveData是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。
- LiveData基础使用的例子
  - 这个例子，是点击按钮通过 LiveData 来更新 TextView 的内容
#+BEGIN_SRC kotlin
class MainActivity : BaseActivity() {
    private lateinit var binding: ActivityMainBinding

    private val mContent = MutableLiveData<String>()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
       
        binding.btnUpdate.setOnClickListener {
            mContent.value = "最新值是:Update"
        }
        mContent.observe(this, Observer { content -> binding.tvContent.text = content })
    }
}
#+END_SRC
- 布局也很简单，一个文本框，一个按钮
#+BEGIN_SRC xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <TextView
        android:id="@+id/tvContent"
        android:layout_width="0dp"
        android:text="Hello World"
        android:layout_height="wrap_content"
        android:textColor="#f00"
        android:gravity="center"
        android:textSize="24sp"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <Button
        android:id="@+id/btnUpdate"
        android:layout_width="wrap_content"
        android:text="Update"
        android:padding="5dp"
        android:layout_height="wrap_content"
        android:textColor="#000"
        android:textSize="18sp"
        android:layout_marginTop="20dp"
        android:textAllCaps="false"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/tvContent" />
</androidx.constraintlayout.widget.ConstraintLayout>
#+END_SRC
- 默认TextView展示的是： Hello World，点击按钮后展示的是：“最新值是:Update” 。这个就是LiveData 的简单使用。
** 抛出问题
- 为什么LiveData的工作机制是这样的
- LiveData 是怎么回调的？
- LiveData 为什么可以感知生命周期？
- LiveData 可以感知生命周期，有什么用，或者说有什么优势？
- LiveData 为什么只会将更新通知给活跃的观察者。非活跃观察者不会收到更改通知？
- LiveData此外还提供了observerForever()方法，所有生命周期事件都能通知到，怎么做到的？
- 解析来通过分析源码，来寻找答案。文章最后我会解释这些问题的，做一个统一的总结。
** 源码分析前的准备工作
- 我需要了解几个类，来对接下来的源码分析做一个铺垫。
- 先看之前例子中的代码
#+BEGIN_SRC kotlin
class LiveDataActivity : BaseActivity() {
    private val mContent = MutableLiveData<String>()
  	
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
				
        mContent.observe(this, Observer { content ->
            tvContent.text = content
        })
    }
}
#+END_SRC
- 只贴出了主要代码，我们来看下主要的类以及方法，方法参数
- 声明了一个MutableLiveData对象
- 调用了MutableLiveData的observe方法
- observe方法中 传入 this 和 Observer
- this 指的是LiveDataActivity对象，其实一个是一个LifecycleOwner。Observer是一个接口
- 来分别看下具体内容。
*** MutableLiveData类
    #+BEGIN_SRC java
public class MutableLiveData<T> extends LiveData<T> {
    public MutableLiveData(T value) {
        super(value);
    }
    public MutableLiveData() {
        super();
    }
    @Override
    public void postValue(T value) {
        super.postValue(value);
    }
    @Override
    public void setValue(T value) {
        super.setValue(value);
    }
}
    #+END_SRC
- 继承了LiveData是一个可变的LiveData
- 是一个被观察者，是一个数据持有者
- 提供了 setValue 和 postValue方法，其中postValue可以在子线程调用
- postValue方法，我们下面会具体分析
*** MutableLiveData的observe方法参数中的 this
- 当前 Activity 的对象，本质上是一个LifecycleOwner 我在这篇 Android Jetpack组件Lifecycle基本使用和原理分析中有分析过，它的源码。
#+BEGIN_SRC java
public interface LifecycleOwner {
    @NonNull
    Lifecycle getLifecycle();
}
#+END_SRC
*** MutableLiveData的observe方法参数中的 Observer
    #+BEGIN_SRC java
public interface Observer<T> {
    /**
     * Called when the data is changed.
     * @param t  The new data
     */
    void onChanged(T t);
}
    #+END_SRC
- Observer是一个观察者
- Observer中有一个回调方法，在 LiveData 数据改变时会回调此方法
- 通过以上简单分析，我们大概了解了这个几个类的作用，接下来我们一步一步看源码，来从源码中解决我们在第 3 节提出的问题。
** 源码分析
- 首先我们上面示例中的 LiveData.observe()方法开始。
#+BEGIN_SRC kotlin
//LiveDataActivity.kt
private val mContent = MutableLiveData<String>()
mContent.observe(this, Observer { content ->
    tvContent.text = content
})
#+END_SRC
- 我们点进observe方法中去它的源码。
** LiveData类
- 在LiveData的observe方法中
#+BEGIN_SRC kotlin
//LiveData.java
@MainThread
public void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {
    assertMainThread("observe");
  	// 1
    if (owner.getLifecycle().getCurrentState() == DESTROYED) 
        //  ignore
        return;
  	// 2
    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);
  	// 3
    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);
  	// 4
    if (existing != null && !existing.isAttachedTo(owner)) 
        throw new IllegalArgumentException("Cannot add the same observer" + " with different lifecycles");
    if (existing != null) return;
  	// 5
    owner.getLifecycle().addObserver(wrapper);
}
#+END_SRC
- 注释 1：首先会通过LifecycleOwner获取Lifecycle对象然后获取Lifecycle 的State，如果是DESTROYED直接 return 了。忽略这次订阅
- 注释 2 ：把LifecycleOwner和Observer包装成LifecycleBoundObserver对象，至于为什么包装成这个对象，我们下面具体讲，而且这个是重点。
- 注释 3：把观察者存到 Map 中
- 注释 4：之前添加过LifecycleBoundObserver，并且LifecycleOwner不是同一个，就抛异常
- 注释 5：通过Lifecycle和添加 LifecycleBoundObserver观察者，形成订阅关系
- 总结：
  - 到现在，我们知道了LiveData的observe方法中会判断 Lifecycle 的生命周期，会把LifecycleOwner和Observer包装成LifecycleBoundObserver对象，然后 Lifecycle().addObserver(wrapper) Lifecycle 这个被观察者会在合适的实际通知观察者的回调方法。
- 等等，什么时候通知，咋通知的呢？这个具体流程是啥呢？
- 回个神，我再贴下开始的示例代码。
#+BEGIN_SRC kotlin
class LiveDataActivity : BaseActivity() {
    private val mContent = MutableLiveData<String>()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_live_data)
				// 1
        btnUpdate.setOnClickListener {
            mContent.value = "最新值是:Update"
        }
        mContent.observe(this, Observer { content ->
            tvContent.text = content
        })
    }
}
#+END_SRC
- 在点击按钮的时候 LiveData会调用setValue方法，来更新最新的值，这时候我们的观察者Observer就会收到回调，来更新 TextView。
- 所以接下来我们先看下 LiveData的setValue方法做了什么，LiveData还有一个postValue方法，我们也一并分析一下。
** LiveData的setValue方法和postValue方法
*** 先看setValue方法
    #+BEGIN_SRC java
// LiveData.java
@MainThread
protected void setValue(T value) {
    assertMainThread("setValue");
    mVersion++;
    mData = value;
    dispatchingValue(null);// 1
}
    #+END_SRC
- 调用了dispatchingValue方法，继续跟代码
#+BEGIN_SRC java
// LiveData.java
void dispatchingValue(@Nullable ObserverWrapper initiator) {
    if (mDispatchingValue) {
        mDispatchInvalidated = true;
        return;
    }
    mDispatchingValue = true;
    do {
        mDispatchInvalidated = false;
        if (initiator != null) {
          	// 1
            considerNotify(initiator);
            initiator = null;
        } else {
            for (Iterator<Map.Entry<Observer<? super T>, ObserverWrapper>> iterator =
                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {
              	// 2
                considerNotify(iterator.next().getValue());
                if (mDispatchInvalidated) break;
            }
        }
    } while (mDispatchInvalidated);
    mDispatchingValue = false;
}
#+END_SRC
- 不管如何判断，都是调用了considerNotify()方法
#+BEGIN_SRC java
// LiveData.java
private void considerNotify(ObserverWrapper observer) {
    if (!observer.mActive) return;
    if (!observer.shouldBeActive()) {
        observer.activeStateChanged(false);
        return;
    }
    if (observer.mLastVersion >= mVersion) return;
    observer.mLastVersion = mVersion;
    observer.mObserver.onChanged((T) mData);// 1
}
#+END_SRC
- 最终调用了observer.mObserver.onChanged((T) mData)方法，这个observer.mObserver就是我们的 Observer接口，然后调用它的onChanged方法。
- 到现在整个被观察者数据更新通知观察者这个流程就通了。
*** 然后再看下postValue方法
- 子线程发送消息通知更新 UI，嗯？Handler 的味道，我们具体看下代码
#+BEGIN_SRC java
// LiveData.java
protected void postValue(T value) {
    boolean postTask;
    synchronized (mDataLock) {
        postTask = mPendingData == NOT_SET;
        mPendingData = value;
    }
    if (!postTask) return;
    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);// 1
}
#+END_SRC
- 可以看到一行关键代码ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);
- 点 **postToMainThread **方法进去看下
#+BEGIN_SRC java
// ArchTaskExecutor.java
private TaskExecutor mDelegate;
@Override
public void postToMainThread(Runnable runnable) {
    mDelegate.postToMainThread(runnable);// 1
}
#+END_SRC
- 看到 mDelegate 是 TaskExecutor对象，现在目标是看下 mDelegate 的具体实例对象是谁
#+BEGIN_SRC java
// ArchTaskExecutor.java
private ArchTaskExecutor() {
    mDefaultTaskExecutor = new DefaultTaskExecutor();
    mDelegate = mDefaultTaskExecutor;// 1
}
#+END_SRC
- 好的，目前的重点是看下DefaultTaskExecutor是个啥，然后看它的postToMainThread方法
#+BEGIN_SRC java
// DefaultTaskExecutor.java
private volatile Handler mMainHandler;
@Override
public void postToMainThread(Runnable runnable) {
    if (mMainHandler == null)
        synchronized (mLock) 
            if (mMainHandler == null) 
                mMainHandler = createAsync(Looper.getMainLooper());// 1
    mMainHandler.post(runnable);// 2
}
#+END_SRC
- 注释 1：实例了一个 Handler 对象，注意构造参数 **Looper.getMainLooper()**是主线的 Looper。那么就可做到线程切换了。
- 注释 2：调用post 方法。
- 下面看下这个 Runnable
#+BEGIN_SRC java
ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);
#+END_SRC
- 这里面的方法参数是mPostValueRunnable是个 Runnable，我们看下代码
#+BEGIN_SRC java
// LiveData.java
private final Runnable mPostValueRunnable = new Runnable() {
    @SuppressWarnings("unchecked")
    @Override
    public void run() {
        Object newValue;
        synchronized (mDataLock) {
            newValue = mPendingData;
            mPendingData = NOT_SET;
        }
        setValue((T) newValue);// 1
    }
};
#+END_SRC
- **注意：**postValue方法其实最终调用也是setValue方法，然后和setValue方法走的流程就是一样的了，这个上面已经分析过了。详情请看 7.1 小节
- 但是我们还不知道ObserverWrapper是啥，好那么接下来，我们的重点来了
- 我们要详细看一下LifecycleBoundObserver类了，它包装了LifecycleOwner和Observer，这就是接下来的重点内容了。
** LifecycleBoundObserver类
- 再贴下一下代码，当LiveData调用observe方法时
#+BEGIN_SRC java
// LiveData.java
@MainThread
public void observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer) {
    assertMainThread("observe");
    if (owner.getLifecycle().getCurrentState() == DESTROYED) 
        return; //  ignore
  	// 1
    LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);
    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);
    if (existing != null && !existing.isAttachedTo(owner)) 
        throw new IllegalArgumentException("Cannot add the same observer" + " with different lifecycles");
    if (existing != null) return;
    owner.getLifecycle().addObserver(wrapper);
}
#+END_SRC
- 注释 1 ：用LifecycleBoundObserver对LifecycleOwner 和 Observer进行了包装
*** 来看下LifecycleBoundObserver类，它是LiveData的内部类
    #+BEGIN_SRC java
// LiveData.java
class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver {
    @NonNull
    final LifecycleOwner mOwner;
    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<? super T> observer) {
        super(observer);
        mOwner = owner;
    }
}
    #+END_SRC
- 两个参数，一个 owner被成员变量mOwner存储，observer参数被ObserverWrapper的 mObserver存储。
- LifecycleEventObserver是LifecycleObserver的子接口里面有一个onStateChanged方法，这个方法会在 Activity、Fragment 生命周期回调时调用，如果这么说不明看下这篇文章Android Jetpack组件Lifecycle基本使用和原理分析
- ObserverWrapper 是Observer包装类
- 我们接下来看下ObserverWrapper类
*** ObserverWrapper类
    #+BEGIN_SRC java
private abstract class ObserverWrapper {
    final Observer<? super T> mObserver;
    boolean mActive;
    int mLastVersion = START_VERSION;
    // 1
    ObserverWrapper(Observer<? super T> observer) {
        mObserver = observer;
    }
    // 2
    abstract boolean shouldBeActive();
    boolean isAttachedTo(LifecycleOwner owner) {
        return false;
    }
    void detachObserver() { }
    void activeStateChanged(boolean newActive) {
        if (newActive == mActive) return;

        //  immediately set active state, so we'd never dispatch anything to inactive owner
        mActive = newActive;
        boolean wasInactive = LiveData.this.mActiveCount == 0;
        LiveData.this.mActiveCount += mActive ? 1 : -1;
        if (wasInactive && mActive) 
            onActive(); // 3
        if (LiveData.this.mActiveCount == 0 && !mActive) 
            onInactive(); // 4
        if (mActive) 
            dispatchingValue(this); // 5
    }
}
    #+END_SRC
- 注：活跃状态指的是 Activity、Fragment 等生命周期处于活跃状态
- 注释 1：获取了我们的 Observer 对象，存储在 成员变量mObserver身上
- 注释 2：抽象方法，当前是否是活跃的状态
- 注释 3：可以继承 LiveData 来达到扩展 LiveData 的目标，并且是在活跃的状态调用
- 注释 4：可以继承 LiveData 来达到扩展 LiveData 的目标，并且是在非活跃的状态调用
- 注释 5：活跃状态，发送最新的值，来达到通知的作用， dispatchingValue(this)方法咋这么眼熟，对之前在 LiveData 调用 setValue 方法时，最终也会调用到此方法。那ObserverWrapper类中的dispatchingValue这个方法是在activeStateChanged方法中调用，那activeStateChanged啥时候调用呢？
- 我来看下ObserverWrapper的子类也就是最重要的那个类LifecycleBoundObserver，现在看它的完整代码
*** LifecycleBoundObserver完整代码
- 这里是关键代码了
#+BEGIN_SRC java
// LiveData.java
class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver {
    @NonNull final LifecycleOwner mOwner;
    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<? super T> observer) {
        super(observer);
        mOwner = owner;
    }
    @Override boolean shouldBeActive() {
        return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); // 1
    }
    @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) {
        if (mOwner.getLifecycle().getCurrentState() == DESTROYED) { // 2
            removeObserver(mObserver);
            return;
        }
        activeStateChanged(shouldBeActive()); // 3
    }
    @Override boolean isAttachedTo(LifecycleOwner owner) {
        return mOwner == owner;
    }
    @Override void detachObserver() {
        mOwner.getLifecycle().removeObserver(this); // 4
    }
}
#+END_SRC
- 注释 1：判断当前的 Lifecycle 的生命周期是否是活跃状态，会在回调观察则 Observer 的时候进行判断，只有在活跃状态，才会回调观察者Observer的onChanged方法。
- 直接就回答了我们上面的这个问题LiveData 为什么只会将更新通知给活跃的观察者。非活跃观察者不会收到更改通知？ 首先会通过LifecycleOwner获取Lifecycle对象然后获取Lifecycle 的State，并且状态大于STARTED。这里的State是和 Activity、Fragment 的生命周期是对应的，具体看这篇文章 Android Jetpack组件Lifecycle基本使用和原理分析 的第4.4小节，有详细的解释。
- 注释 2：onStateChanged每次 Activity、Fragment的生命周期回调的时候，都会走这个方法。
- 获取Lifecycle对象然后获取Lifecycle 的State如果为DESTROYED则移除观察者，在 Activity、Fragment的生命周期走到 onDestroy 的时候，就会取消订阅，避免内存泄漏。
- 注释 3：调用父类ObserverWrapper 的activeStateChanged方法，层层调用到观察者Observer的onChanged方法。（自己看下源码一目了然）
- 重点来了：在LiveData 调用setValue方法时，会回调观察者Observer的onChanged方法，Activity、Fragment的生命周期变化的时候且为活跃也会回调观察者Observer的onChanged方法。这就是为什么你在ActivityB页面，调用setValue方法，更新了value，在ActivityA 重新获取焦点时也同样会收到这个最新的值。
- 注释 4：移除观察者Observer，解除订阅关系。
- 到这个时候,LiveData 的 observer方法、setValue方法，整个流程就分析完了。
- 如果我们想不管生命周期，而是想在setValue的值发生改变的时候就能接受到通知，LiveData 还提供了一个observeForever方法
#+BEGIN_SRC kotlin
class LiveDataActivity : BaseActivity() {
    private val mContent = MutableLiveData<String>()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_live_data)
        btnUpdate.setOnClickListener {
            mContent.value = "最新值是:Update"
        }
        // 只要在值发生改变时,就能接收到
        mContent.observeForever { content -> // .observeForever { -> }
            tvContent.text = content
        }
    }
}
#+END_SRC
*** LiveData 的observeForever方法
- 这个方法比observe方法少一个LifecycleOwner参数，为啥呢？因为这个方法不需要感知生命周期，需要在setValue 值更新时立马收到回调。
- 来看下具体代码
#+BEGIN_SRC java
// LiveData.java
@MainThread
public void observeForever(@NonNull Observer<? super T> observer) {
    assertMainThread("observeForever");
  	// 1
    AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);
    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);
    if (existing instanceof LiveData.LifecycleBoundObserver) {
        throw new IllegalArgumentException("Cannot add the same observer"
                + " with different lifecycles");
    }
    if (existing != null) 
        return;
    wrapper.activeStateChanged(true);
}
#+END_SRC
- 注释 1 ：这里用到的是AlwaysActiveObserver而 observe方法用到是LifecycleBoundObserver
- 看一下这个AlwaysActiveObserver
#+BEGIN_SRC java
// LiveData.java
private class AlwaysActiveObserver extends ObserverWrapper {
    AlwaysActiveObserver(Observer<? super T> observer) {
        super(observer);
    }
    @Override
    boolean shouldBeActive() {
        return true;
    }
}
#+END_SRC
- 代码非常的简洁，在shouldBeActive方法中，直接 return true，这也太秀了吧
- 为啥直接返回 true 呢？因为这里不用管生命周期，永远都是活跃状态，所以这个方法叫observeForever
- LiveData 的源码非常值得读，而且量不是很大，里面有许多值得学习的地方。
** 使用 LiveData 的优势: 这个是Google官方总结的:使用 LiveData 具有以下优势：
- 确保界面符合数据状态
- LiveData 遵循观察者模式。当生命周期状态发生变化时，LiveData 会通知 Observer 对象。您可以整合代码以在这些 Observer 对象中更新界面。观察者可以在每次发生更改时更新界面，而不是在每次应用数据发生更改时更新界面。
- 不会发生内存泄漏
- 观察者会绑定到 Lifecycle 对象，并在其关联的生命周期遭到销毁后进行自我清理。
- 不会因 Activity 停止而导致崩溃
- 如果观察者的生命周期处于非活跃状态（如返回栈中的 Activity），则它不会接收任何 LiveData 事件。
- 不再需要手动处理生命周期
- 界面组件只是观察相关数据，不会停止或恢复观察。LiveData 将自动管理所有这些操作，因为它在观察时可以感知相关的生命周期状态变化。
- 数据始终保持最新状态
- 如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据。例如，曾经在后台的 Activity 会在返回前台后立即接收最新的数据。
- 适当的配置更改
- 如果由于配置更改（如设备旋转）而重新创建了 Activity 或 Fragment，它会立即接收最新的可用数据。
- 共享资源
- 您可以使用单一实例模式扩展 LiveData 对象以封装系统服务，以便在应用中共享它们。LiveData 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 LiveData 对象。如需了解详情，请参阅扩展 LiveData。
** 总结
- LiveData 是怎么回调的？
  - LiveData通过observe或者observeForever方法订阅了一个观察者
  - LiveData 通过调用setValue或postValue方法时，会取出观察者，调用它的onChanged方法
  - 当然，当 Activity、Fragment 生命周期由非活跃变化为活跃状态，也会收到最新的值回调onChanged方法，注意这个对应的是LiveData的observe方法。
- LiveData 为什么可以感知生命周期？
  - 是因为LifecycleBoundObserver类
  - 以及在observe方法中调用了 owner.getLifecycle().addObserver(wrapper);这行代码，具体的看下上面的源码分析吧
- LiveData 可以感知生命周期，有什么用，或者说有什么优势？
  - 可以自动取消订阅
  - 防止内存泄漏
- LiveData 为什么只会将更新通知给活跃的观察者。非活跃观察者不会收到更改通知？
  - 在每次调用setValue方法时，最走到LifecycleBoundObserver的shouldBeActive这个方法的判断上
  - 这个方法返回的是状态为STARTED之后的状态才会走通知观察者回调的逻辑，否则就不执行，具体的看下上面的源码
- LiveData此外还提供了observerForever()方法，所有生命周期事件都能通知到，怎么做到的？
  - 主要AlwaysActiveObserver的shouldBeActive这个方法直接返回的 true

* Android Jetpack组件ViewModel基本使用和原理分析
本文整体流程：首先要知道什么是 ViewModel，然后演示一个例子，来看看 ViewModel 是怎么使用的，接着提出问题为什么是这样的，最后读源码来解释原因！
- 什么是ViewModel
- ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。在对应的作用域内，保正只生产出对应的唯一实例，保证UI组件间的通信。
- ViewModel 一般要配合 LiveData、DataBinding一起使用
- 特点
  - 通过定义我们可以得出
  - ViewModel不会随着Activity的屏幕旋转而销毁；
  - 在对应的作用域内，保正只生产出对应的唯一实例，保证UI组件间的通信
  - 重点说一下ViewModel和onSaveInstanceState的关系
  - 对于简单的数据，Activity 可以使用 onSaveInstanceState() 方法从 onCreate() 中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。
  - ViewModel存储大量数据，不用序列化与反序列化
  - onSaveInstanceState存储少量数据
  - 相辅相成，不是替代
  - 进程关闭是onSaveInstanceState的数据会保留，而ViewModel销毁
** ViewModel的基础使用
这个例子，主要是在 打印 User 的信息，并且点击按钮的时候更新 User 的信息并打印
*** 首先看一下 UserViewModel这个文件
// UserViewModel.kt
// 自定义 User 数据类
data class User(var userId: String = UUID.randomUUID().toString(), var userName: String)
class UserViewModel : ViewModel() {
    private val userBean = User(userName = "刀锋之影")
    //  私有的 user LiveData
    private val _user = MutableLiveData<User>().apply {
        value = userBean
    }
    //  对外暴露的,不可更改 value 值的LiveData
    var userLiveData: LiveData<User> = _user
    // 更新 User 信息
    fun updateUser() {
        // 重新给 _user 赋值
        _user.value = userBean.apply {
            userId = UUID.randomUUID().toString()
            userName = "更新后: userName = 泰隆"
        }
    }
}
自定义 User 数据类
继承ViewModel，初始化 User
声明私有的 user LIveData 用来更新数据
对外暴露的，不可更改 value 值的LiveData
updateUser() 更新 User 信息的方法
*** 2.2.再看下ViewModelActivity的内容
class ViewModelActivity : AppCompatActivity() {
    // 初始化 UserViewModel 通过 ViewModelProvider
    private val userViewModel by lazy { ViewModelProvider(this)[UserViewModel::class.java] }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val button = Button(this)
        setContentView(button)
        
        // 观察 User 数据,并打印
        userViewModel.userLiveData.observe(this, Observer { user ->
            "User = $user".log()
        })
        // 点击按钮更新 User 信息
        button.setOnClickListener {
            userViewModel.updateUser()
        }
    }
}
初始化 UserViewModel
观察 User 数据,并打印结果
点击按钮时，更新 User 信息
*** 2.3.结果日志
// log 日志
User = User(userId=34c1a1a4-967e-439c-91e8-795b8c162997, userName=刀锋之影)
User = User(userId=a6d0f09c-9c01-412a-ab4f-44bef700d298, userName=更新后: userName = 泰隆)
*** 2.4总结：
以上就是 ViewModel 的简单使用，是配合 LiveData 的，具体 LiveData 的使用以及与原理分析，请看这篇文章
Android Jetpack组件LiveData基本使用和原理分析
通过上文可以 ViewModel 的定义以及特点，可以知道 ViewModel在对应的作用域内，保正只生产出对应的唯一实例，保证UI组件间的通信
我们来验证一下这个特点，我再写个例子，证明一下这个特点
** 3.验证ViewModel在对应的作用域内，保正只生产出对应的唯一实例
*** 3.1.ViewModelActivity2类
在ViewModelActivity2中通过supportFragmentManager添加两个 Fragment
class ViewModelActivity2 : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_view_model)
        supportFragmentManager.beginTransaction()
            .add(R.id.flContainer, FirstFragment())
            .add(R.id.flContainer, SecondFragment())
            .commit()
    }
}
*** 3.2.两个 Fragment
class FirstFragment : Fragment() {
    private val TAG = javaClass.simpleName
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        val userViewModel = ViewModelProvider(activity as ViewModelStoreOwner)[UserViewModel::class.java]
        "userViewModel = $userViewModel".logWithTag(TAG)
        return super.onCreateView(inflater, container, savedInstanceState)
    }
}
class SecondFragment : Fragment() {
    private val TAG = javaClass.simpleName
    
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        val userViewModel = ViewModelProvider(activity as ViewModelStoreOwner)[UserViewModel::class.java]
        "userViewModel = $userViewModel".logWithTag(TAG)
        return super.onCreateView(inflater, container, savedInstanceState)
    }
}
在 FirstFragment和SecondFragment的onCreateView方法中实例化UserViewModel对象
其中的参数都为activity as ViewModelStoreOwner其实也就是ViewModelActivity2
打印UserViewModel对象的地址值，来看日志
*** 3.3.结果日志
E/FirstFragment: userViewModel = com.jhb.awesomejetpack.viewmodel.UserViewModel@9940311
E/SecondFragment: userViewModel = com.jhb.awesomejetpack.viewmodel.UserViewModel@9940311
可以看到两个 Fragment 中 UserViewModel是同一个对象。
可以这两个 Fragment 可以使用其 Activity 范围共享 ViewModel 来处理此类通信
** 4.抛出问题
ViewModel为什么不会随着Activity的屏幕旋转而销毁；
为什么在对应的作用域内，保正只生产出对应的唯一实例，保证UI组件间的通信
onCleared方法在什么调用
** 5.分析源码前的准备工作
*** 5.1ViewModel 的生命周期

*** 5.2.几个类的感性认识
ViewModelStoreOwner：是一个接口，用来获取一个ViewModelStore对象
ViewModelStore：存储多个ViewModel，一个ViewModelStore的拥有者( Activity )在配置改变， 重建的时候，依然会有这个实例
ViewModel：一个对 Activity、Fragment 的数据管理类，通常配合 LiveData 使用
ViewModelProvider：创建一个 ViewModel 的实例，并且在给定的ViewModelStoreOwner中存储 ViewModel
** 6.源码分析
再看上面第一个例子中的代码
class ViewModelActivity : AppCompatActivity() {
    // 初始化 UserViewModel 通过 ViewModelProvider
    private val userViewModel by lazy { ViewModelProvider(this)[UserViewModel::class.java] }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val button = Button(this)
        setContentView(button)
        // 观察 User 数据,并打印
        userViewModel.userLiveData.observe(this, Observer { user ->
            "User = $user".log()
        })
        // 点击按钮更新 User 信息
        button.setOnClickListener {
            userViewModel.updateUser()
        }
    }
}
首先看下UserViewModel的初始化过程。
private val userViewModel by lazy { ViewModelProvider(this)[UserViewModel::class.java] }
注：上面代码类似数组的写法是 Kotlin 的写法，其实是 ViewModelProvider 的get方法
** 7.ViewModelProvider的构造方法，以及 get 方法
*** 7.1ViewModelProvider构造方法
先看ViewModelProvider构造方法，传入的参数为当前的 AppCompatActivity
// ViewModelProvider.java
private final Factory mFactory;
private final ViewModelStore mViewModelStore;
public ViewModelProvider(@NonNull ViewModelStoreOwner owner) {
    this(owner.getViewModelStore(), owner instanceof HasDefaultViewModelProviderFactory
            ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()
            : NewInstanceFactory.getInstance());
}
public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) {
    mFactory = factory;
    mViewModelStore = store;
}
通过 ViewModelStoreOwner获取ViewModelStore对象并给 mViewModelStore赋值
给mFactory赋值，这里赋值的是NewInstanceFactory这个对象
*** 7.2.ViewModelProvider的 get 方法
// ViewModelProvider.java
private static final String DEFAULT_KEY = "androidx.lifecycle.ViewModelProvider.DefaultKey";
public <T extends ViewModel> T get(@NonNull Class<T> modelClass) {
    String canonicalName = modelClass.getCanonicalName();
    if (canonicalName == null) {
        throw new IllegalArgumentException("Local and anonymous classes can not be ViewModels");
    }
  	// 1
    return get(DEFAULT_KEY + ":" + canonicalName, modelClass);
}
注释1：
调用了两个参数的 get 方法
第一个参数是字符串的拼接，用来以后获取对应 ViewModel 实例的，保证了同一个 Key 取出是同一个 ViewModel
第二参数是 UserViewModel 的字节码文件对象
看下两个参数的get方法
// ViewModelProvider.java
public <T extends ViewModel> T get(@NonNull String key, @NonNull Class<T> modelClass) {
    ViewModel viewModel = mViewModelStore.get(key);// 1
		// 2
    if (modelClass.isInstance(viewModel)) {
        if (mFactory instanceof OnRequeryFactory) {
            ((OnRequeryFactory) mFactory).onRequery(viewModel);
        }
        return (T) viewModel;
    } else {
        // noinspection StatementWithEmptyBody
        if (viewModel != null) {
            //  TODO: log a warning.
        }
    }
  	// 3
    if (mFactory instanceof KeyedFactory) {
        viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass);
    } else {
        viewModel = (mFactory).create(modelClass);
    }
  	// 4
    mViewModelStore.put(key, viewModel);
    return (T) viewModel;
}
注释 1：从ViewModelStore中，根据 key，取一个 ViewModel，ViewModelStore源码下文分析
注释 2：判断取出来的 ViewModel 实例和传进来的是否是一个，是同一个，直接返回此缓存中实例
注释 3：通过Factory创建一个ViewModel
注释 4：把新创建的ViewModel用ViewModelStore存储起来，以备下次使用，最后返回新创建的ViewModelStore
这里看一下ViewModel是怎么通过Factory创建出来的
通过 7.1 小节可以知道，这个Factory的实例是NewInstanceFactory
*** 7.3.NewInstanceFactory的create方法
// ViewModelProvider.java 中的 AndroidViewModelFactory.java
public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {
    // noinspection TryWithIdenticalCatches
    try {
        return modelClass.newInstance();
    } catch (InstantiationException e) {
        throw new RuntimeException("Cannot create an instance of " + modelClass, e);
    } catch (IllegalAccessException e) {
        throw new RuntimeException("Cannot create an instance of " + modelClass, e);
    }
}
简单粗暴，通过反射，直接创建了ViewModel对象。
这里扩展一个，在实例UserViewModel的时候
private val userViewModel by lazy { ViewModelProvider(this,ViewModelProvider.AndroidViewModelFactory.getInstance(application))[UserViewModel::class.java] }
也可以通过两个参数的构造方法，来实例化，其中第二个参数就是Factory类型。然后就会用 AndroidViewModelFactory来实例化UserViewModel，我们来具体看下代码
AndroidViewModelFactory是NewInstanceFactory的子类
// ViewModelProvider.java 中的 AndroidViewModelFactory
public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {
    if (AndroidViewModel.class.isAssignableFrom(modelClass)) {
        // noinspection TryWithIdenticalCatches
        try {
            return modelClass.getConstructor(Application.class).newInstance(mApplication);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException("Cannot create an instance of " + modelClass, e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException("Cannot create an instance of " + modelClass, e);
        } catch (InstantiationException e) {
            throw new RuntimeException("Cannot create an instance of " + modelClass, e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException("Cannot create an instance of " + modelClass, e);
        }
    }
    return super.create(modelClass);
}
如果我们创建的UserViewModel当初继承的是AndroidViewModel类就走modelClass.getConstructor(Application.class).newInstance(mApplication);实例化方法，否则就走父类的实例化方法，也就是NewInstanceFactory的create方法
在开发中建议使用AndroidViewModel类，它会提供给一个Application级别的 Context。
接下来看一下ViewModelStoreOwner是什么，以及它的具体实现
** 8.ViewModelStoreOwner
public interface ViewModelStoreOwner {
    /**
     * Returns owned {@link ViewModelStore}
     *
     * @return a {@code ViewModelStore}
     */
    @NonNull
    ViewModelStore getViewModelStore();
}
一个接口，里面一个方法返回了ViewModelStore对象
它的实现类在 AndroidX 中ComponentActivity和 Fragment
ComponentActivity的关键代码
// ComponentActivity.java
public class ComponentActivity extends androidx.core.app.ComponentActivity implements ViewModelStoreOwner,XXX{
   
    private ViewModelStore mViewModelStore;
    @NonNull
    @Override
    public ViewModelStore getViewModelStore() {
        if (getApplication() == null) {
            throw new IllegalStateException("Your activity is not yet attached to the "
                    + "Application instance. You can't request ViewModel before onCreate call.");
        }
        if (mViewModelStore == null) {
            NonConfigurationInstances nc =
                    (NonConfigurationInstances) getLastNonConfigurationInstance();
            if (nc != null) {
                //  Restore the ViewModelStore from NonConfigurationInstances
                mViewModelStore = nc.viewModelStore;
            }
            if (mViewModelStore == null) {
                mViewModelStore = new ViewModelStore();
            }
        }
        return mViewModelStore;
    } 
}
创建了一个ViewModelStore并返回了
来看下这个ViewModelStore类
** 9.ViewModelStore
*** 9.1.ViewModelStore的源码
我下面贴的是完整代码，对你没看错。
public class ViewModelStore {
		// 1
    private final HashMap<String, ViewModel> mMap = new HashMap<>();
		// 2
    final void put(String key, ViewModel viewModel) {
        ViewModel oldViewModel = mMap.put(key, viewModel);
        if (oldViewModel != null) {
            oldViewModel.onCleared();
        }
    }
		// 3
    final ViewModel get(String key) {
        return mMap.get(key);
    }
    Set<String> keys() {
        return new HashSet<>(mMap.keySet());
    }
    // 4
    public final void clear() {
        for (ViewModel vm : mMap.values()) {
            vm.clear();
        }
        mMap.clear();
    }
}
注释 1 ：声明一个 Map 来存储ViewModel
注释 2：存储ViewModel，这个方法我们在7.2 小节ViewModelProvider的 get 方法中用到过
注释 3：取出 ViewModel，这个方法我们在7.2 小节ViewModelProvider的 get 方法中用到过。注意在从 Map中去 ViewModel 的时候是根据 Key，也就是7.2小节注释 1 拼接的那个字符串DEFAULT_KEY + ":" + canonicalName。这也就解释了第 4 节的疑问 为什么在对应的作用域内，保正只生产出对应的唯一实例
注释 4：这个是一个重点方法了，表明要清空存储的数据，还会调用到ViewModel的 clear 方法，也就是最终会调用带 ViewModel 的onCleared()方法
那么这个ViewModelStore的 clear 方法，什么时候会调用呢？
*** 9.2.ComponentActivity的构造方法
// ComponentActivity.java
public ComponentActivity() {
    Lifecycle lifecycle = getLifecycle();
   	
    getLifecycle().addObserver(new LifecycleEventObserver() {
        @Override
        public void onStateChanged(@NonNull LifecycleOwner source,
                @NonNull Lifecycle.Event event) {
          	// 1
            if (event == Lifecycle.Event.ON_DESTROY) {
                if (!isChangingConfigurations()) {
                    getViewModelStore().clear();
                }
            }
        }
    });
}
在ComponentActivity的构造方法中，我们看到，在 Activity 的生命周期为 onDestory的时候，并且当前不是，配置更改（比如横竖屏幕切换）就会调用ViewModelStore 的 clear 方法，进一步回调用 ViewModel 的onCleared方法。
这就回答了第四节提出的问题onCleared方法在什么调用
最后看一下 ViewModel 的源码，以及其子类AndroidViewModel
** 10.ViewModel 的源码
ViewModel类其实更像是更规范化的抽象接口
public abstract class ViewModel {
    private volatile boolean mCleared = false;
    @SuppressWarnings("WeakerAccess")
    protected void onCleared() {
    }
    @MainThread
    final void clear() {
        mCleared = true;
        if (mBagOfTags != null) {
            synchronized (mBagOfTags) {
                for (Object value : mBagOfTags.values()) {
                    //  see comment for the similar call in setTagIfAbsent
                    closeWithRuntimeException(value);
                }
            }
        }
        onCleared();
    }
}
ViewModel 的子类AndroidViewModel
public class AndroidViewModel extends ViewModel {
    @SuppressLint("StaticFieldLeak")
    private Application mApplication;
    public AndroidViewModel(@NonNull Application application) {
        mApplication = application;
    }
    /**
     * Return the application.
     */
    @SuppressWarnings({"TypeParameterUnusedInFormals", "unchecked"})
    @NonNull
    public <T extends Application> T getApplication() {
        return (T) mApplication;
    }
}
提供了一个规范，提供了一个 Application 的 Context
到现在整个源码过程就看了，包括前面，我们提到的那几个关键类的源码。
到目前为止，我们第 4 节抛出的问题，已经解决了，两个了，还有一个ViewModel为什么不会随着Activity的屏幕旋转而销毁；
** 分析为啥ViewModel不会随着Activity的屏幕旋转而销毁
首先知道的是 ViewModel 不被销毁，是在一个 ViewModelStore 的 Map 中存着呢，所以要保证ViewModelStore不被销毁。
首先得具备一个前置的知识
在 Activity 中提供了 onRetainNonConfigurationInstance 方法，用于处理配置发生改变时数据的保存。随后在重新创建的 Activity 中调用 getLastNonConfigurationInstance 获取上次保存的数据。
*** onRetainNonConfigurationInstance方法
// ComponentActivity.java
/**
 * Retain all appropriate non-config state.  You can NOT
 * override this yourself!  Use a {@link androidx.lifecycle.ViewModel} if you want to
 * retain your own non config state.
 */
@Override
@Nullable
public final Object onRetainNonConfigurationInstance() {
    Object custom = onRetainCustomNonConfigurationInstance();
    ViewModelStore viewModelStore = mViewModelStore;
    if (viewModelStore == null) {
        //  No one called getViewModelStore(), so see if there was an existing
        //  ViewModelStore from our last NonConfigurationInstance
        NonConfigurationInstances nc =
                (NonConfigurationInstances) getLastNonConfigurationInstance();
        if (nc != null) {
            viewModelStore = nc.viewModelStore;
        }
    }
    if (viewModelStore == null && custom == null) {
        return null;
    }
		// 1
    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.custom = custom;
    nci.viewModelStore = viewModelStore;
    return nci;
}
注意看下方法上的注释
不需要也不能重写此方法，因为用 final 修饰
配置发生改变时数据的保存，用ViewModel就行
注释 1：把ViewModel存储在 NonConfigurationInstances 对象中
现在再看下ComponentActivity 的 getViewModelStore方法
// ComponentActivity.java
@NonNull
@Override
public ViewModelStore getViewModelStore() {
    if (getApplication() == null) {
        throw new IllegalStateException("Your activity is not yet attached to the "
                + "Application instance. You can't request ViewModel before onCreate call.");
    }
    if (mViewModelStore == null) {
      	// 1
        NonConfigurationInstances nc =
                (NonConfigurationInstances) getLastNonConfigurationInstance();
        if (nc != null) {
            //  Restore the ViewModelStore from NonConfigurationInstances
            mViewModelStore = nc.viewModelStore;
        }
        if (mViewModelStore == null) {
            mViewModelStore = new ViewModelStore();
        }
    }
    return mViewModelStore;
}
注释 1：获取了NonConfigurationInstances一个对象，不为空从其身上拿一个ViewModelStore，这个就是之前保存的ViewModelStore
当 Activity 重建时还会走到getViewModelStore方法，这时候就是在NonConfigurationInstances拿一个缓存的ViewModelStore。
** 总结
- 1.ViewModel为什么不会随着Activity的屏幕旋转而销毁
  - 主要是通过onRetainNonConfigurationInstance方法把ViewModelStore缓存在NonConfigurationInstances中，在getViewModelStore取出ViewModelStore。具体内容看第 11 节
- 2.为什么在对应的作用域内，保正只生产出对应的唯一实例
  - ViewModelStore的 get方法，是根据 key 来取值的，如果 key相同，那取出来的ViewModel就是一个。具体内容看第 9.2 小节
- 3.onCleared方法在什么调用
  - 当 Activity 真正销毁的时候，而不是配置改变会调用ViewModelStore的 clear进而调用了ViewModel的onCleared，具体内容看第 9.2 小节