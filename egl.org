#+latex_class: article
#+title: Android OpenGL ES 渲染相关
#+author: deepwaterooo

* NDK

* 渲染步骤
- 初始化 EGL 环境大概分了 6 个步骤，在代码中都标记出来了。我们一个个来看。
  - 获得 EGLDisplay 对象，官网解释说是一个 display connection。可能其内部封装了连接设备显示器，获取显示器信息的方法。
  -初始化 1 中获得的 display connection。这一步传入了 version 数组，作用是用来存放调用 eglInitialize 方法后获取的 EGL 的主版本和次版本。因为在 c 语言中一般是通过入参来传递返回值的，所以这里也是类似。
  - 获得显示器支持的图像缓冲配置，这里主要指定了各个颜色的深度和 alpha 通道的深度。然后调用 eglChooseConfig 方法后会返回多个支持我们指定配置的配置。这些配置会按匹配程度排序，数组第一个是最接近我们需要的配置。
  - 拿到配置后就可以创建 EGLContext，它为后续 OpenGL ES 渲染提供了上下文。
  - 创建 EGLSurface，已经有了 SurfaceView 了，这里为什么又来了一个 EGLSurface？其实 EGL 并不认识 SurfaceView，他只认识 EGLSurface，所以就用 EGLSurface 对 SurfaceView 中的 Surface 做了一层代理，实际上绘制还是绘制在 SurfaceView 中的 BufferQueue 中然后给屏幕进行显示的。
  - 最后一步即将 EGL 绑定到当前的 EGLSurface 上来，并指定了 OpenGL ES 的渲染上下文。
- 经过以上这 6 步，我们已经具备使用 OpenGL ES 进行渲染的能力了，下面来看下该怎么做。

- 首先在 SurfaceHolder 的 surfaceCreated 方法中调用上面的 initEGL，然后指定 OpenGL ES 的清屏颜色。
#+BEGIN_SRC java
@Override
    public void surfaceCreated(SurfaceHolder holder) {
        initEGL(holder);
        GLES32.glClearColor(1.0F, 0F, 0F, 1F);
    }
#+END_SRC 
- 接着在 surfaceChanged 回调中设置 OpenGL ES 中的视窗大小，并进行清屏操作。但仅仅这两步是无法将清屏颜色渲染到屏幕上的，因为此时只是将颜色渲染在了 EGLSurface 中的缓存中，另外还需要调用 EGL14.eglSwapBuffers 将缓存中的数据给到显示设备，这样才能渲染成功。
#+BEGIN_SRC java
@Override
public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
    GLES32.glViewport(0, 0, width, height);
    GLES32.glClear(GLES32.GL_COLOR_BUFFER_BIT);
    EGL14.eglSwapBuffers(mEGLDisplay, mEGLSurface);
#+END_SRC 

** OpenGL fundamentals
- GLSurfaceView是一个视图，继承至SurfaceView，它内嵌的surface专门负责OpenGL渲染。
*** GLSurfaceView提供了下列特性：
- 1> 管理一个surface，这个surface就是一块特殊的内存，能直接排版到android的视图view上。
- 2> 管理一个EGL display，它能让opengl把内容渲染到上述的surface上。
- 3> 用户自定义渲染器(render)。
- 4> 让渲染器在独立的线程里运作，和UI线程分离。
- 5> 支持按需渲染(on-demand)和连续渲染(continuous)。
- 6> 一些可选工具，如调试。
*** 使用GLSurfaceView
- 通常会继承GLSurfaceView，并重载一些和用户输入事件有关的方法。如果你不需要重载事件方法，GLSurfaceView也可以直接使用，你可以使用set方法来为该类提供自定义的行为。例如，GLSurfaceView的渲染被委托给渲染器在独立的渲染线程里进行，这一点和普通视图不一样，setRenderer(Renderer)设置渲染器。
*** 初始化GLSurfaceView
- 初始化过程其实仅需要你使用setRenderer(Renderer)设置一个渲染器(render)。当然，你也可以修改GLSurfaceView一些默认配置。
  - * setDebugFlags(int)
  - * setEGLConfigChooser(boolean)
  - * setEGLConfigChooser(EGLConfigChooser)
  - * setEGLConfigChooser(int, int, int, int, int, int)
  - * setGLWrapper(GLWrapper) 
*** 定制android.view.Surface
- GLSurfaceView默认会创建像素格式为PixelFormat.RGB_565的surface。如果需要透明效果，调用getHolder().setFormat(PixelFormat.TRANSLUCENT)。透明(TRANSLUCENT)的surface的像素格式都是32位，每个色彩单元都是8位深度，像素格式是设备相关的，这意味着它可能是ARGB、RGBA或其它。
*** 选择EGL配置
- Android设备往往支持多种EGL配置，可以使用不同数目的通道(channel)，也可以指定每个通道具有不同数目的位(bits)深度。因此，在渲染器工作之前就应该指定EGL的配置。GLSurfaceView默认EGL配置的像素格式为RGB_656，16位的深度缓存(depth buffer)，默认不开启遮罩缓存(stencil buffer)。
- 如果你要选择不同的EGL配置，请使用setEGLConfigChooser方法中的一种。
*** 调试行为
- 你可以调用调试方法setDebugFlags(int)或setGLWrapper(GLSurfaceView.GLWrapper)来自定义GLSurfaceView一些行为。在setRenderer方法之前或之后都可以调用调试方法，不过最好是在之前调用，这样它们能立即生效。
*** 设置渲染器
- 总之，你必须调用setRenderer(GLSurfaceView.Renderer)来注册一个GLSurfaceView.Renderer渲染器。渲染器负责真正的GL渲染工作。
*** 渲染模式
- 渲染器设定之后，你可以使用setRenderMode(int)指定渲染模式是按需(on demand)还是连续(continuous)。默认是连续渲染。
*** Activity生命周期
- Activity窗口暂停(pause)或恢复(resume)时，GLSurfaceView都会收到通知，此时它的onPause方法和onResume方法应该被调用。这样做是为了让GLSurfaceView暂停或恢复它的渲染线程，以便它及时释放或重建OpenGL的资源。

** 事件处理 
- 系统默认mode==RENDERMODE_CONTINUOUSLY，这样系统会自动重绘；mode==RENDERMODE_WHEN_DIRTY时，只有surfaceCreate的时候会绘制一次，然后就需要通过requestRender()方法主动请求重绘。同时也提到，如果你的界面不需要频繁的刷新最好是设置成RENDERMODE_WHEN_DIRTY，这样可以降低CPU和GPU的活动，可以省电。
- 为了处理事件，一般都是继承GLSurfaceView类并重载它的事件方法。但是由于GLSurfaceView是多线程操作，所以需要一些特殊的处理。由于渲染器在独立的渲染线程里，你应该使用Java的跨线程机制跟渲染器通讯。queueEvent(Runnable)方法就是一种相对简单的操作。
- *这里关于多线程处理的部分，是之前自己不曾注意到过的，需要理解原理和加强*
-  (注：如果在UI线程里调用渲染器的方法，很容易收到“call to OpenGL ES API with no current context”的警告，典型的误区就是在键盘或鼠标事件方法里直接调用opengl es的API，因为UI事件和渲染绘制在不同的线程里。更甚者，这种情况下调用glDeleteBuffers这种释放资源的方法，可能引起程序的崩溃，因为UI线程想释放它，渲染线程却要使用它。)
#+BEGIN_SRC java
class MyGLSurfaceView extends GLSurfaceView { 
     private MyRenderer mMyRenderer; 
         public void start() { 
             mMyRenderer = ...; 
             setRenderer(mMyRenderer); 
         } 
         public boolean onKeyDown( int keyCode, KeyEvent event) { 
             if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) { 
                 queueEvent( new Runnable() { 
                     // 这个方法会在渲染线程里被调用 
                          public void run() { 
                              mMyRenderer.handleDpadCenter(); 
                          }}); 
                      return true ; 
                  } 
                  return super .onKeyDown(keyCode, event); 
             } 
       } 
}
#+END_SRC 
- 调用queueEvent就是给队列中添加runnable
#+BEGIN_SRC java
public void queueEvent(Runnable r) {
     synchronized (sGLThreadManager) {
         mEventQueue.add(r);
         sGLThreadManager.notifyAll();
     }
}
#+END_SRC 
- 在guardenRun()中有如下代码：
#+BEGIN_SRC java
 if (! mEventQueue.isEmpty()) {
     event = mEventQueue.remove( 0 );
     break ;
 }
 if (event != null ) {
     event.run();
     event = null ;
     continue ;
 }
#+END_SRC 
- 因为每次都会remove掉添加的runnable，所以上面那个demo就是非常好的解释，每次按键就是添加runnable。当然，这也是要求绘制是一直在循环重绘的状态才能看到效果。
- (注：如果在UI线程里调用渲染器的方法，很容易收到“call to OpenGL ES API with no current context”的警告，典型的误区就是在键盘或鼠标事件方法里直接调用opengl es的API，因为UI事件和渲染绘制在不同的线程里。更甚者，这种情况下调用glDeleteBuffers这种释放资源的方法，可能引起程序的崩溃，因为UI线程想释放它，渲染线程却要使用它。)
- 再举一下简单实用的小例子，关于queueEvent()的使用的
#+BEGIN_SRC java
public class ClearActivity extends Activity {
    private GLSurfaceView mGLView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // mGLView = new GLSurfaceView(this);
        mGLView = new ClearGLSurfaceView(this);
        mGLView.setRenderer(new ClearRenderer());
        setContentView(mGLView);
    }
     @Override
    protected void onPause() {
        super.onPause();
        mGLView.onPause();
    }
     @Override
     protected void onResume() {
        super.onResume();
        mGLView.onResume();
    }
}
class ClearGLSurfaceView extends GLSurfaceView {
    public ClearGLSurfaceView(Context context) {
        super(context);
        mRenderer = new ClearRenderer();
        setRenderer(mRenderer);
    }
    public boolean onTouchEvent(final MotionEvent event) {
        queueEvent(new Runnable(){
            public void run() {
                mRenderer.setColor(event.getX() / getWidth(),
                        event.getY() / getHeight(), 1.0f);
            }});
            return true;
        }
        ClearRenderer mRenderer;
}
class ClearRenderer implements GLSurfaceView.Renderer {
    private float mRed;
    private float mGreen;
    private float mBlue;
    public void onSurfaceCreated(GL10 gl, EGLConfig config) {
        // Do nothing special.
    }
    public void onSurfaceChanged(GL10 gl, int w, int h) {
        gl.glViewport(0, 0, w, h);
    }
    public void onDrawFrame(GL10 gl) {
        gl.glClearColor(mRed, mGreen, mBlue, 1.0f);
        gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
    }
    public void setColor(float r, float g, float b) {
        mRed = r;
        mGreen = g;
        mBlue = b;
    }
}
#+END_SRC 
- 这个应用每帧都在清楚屏幕。当你点击屏幕时，它清除颜色基于你触屏时间的X、Y坐标。注意在 ClearGLSurfaceView.onTouchEvent()中使用queueEvent()。queueEvent()方法被安全地用于在UI线程和渲染线程之间进行交流。如果你愿意，你还可以使用一些其他的java线程间交流技术，例如Renderer 类本身的同步方法。然而，queueing 事件经常是一种用于处理线程间信息交流的更简单方式。
