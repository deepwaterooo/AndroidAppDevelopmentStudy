% Created 2019-09-28 Sat 09:12
\documentclass[9pt, b5paper]{article}
\usepackage{fontspec}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage[slantfont,boldfont]{xeCJK}
\setCJKmainfont[BoldFont = Heiti SC, ItalicFont = STFangsong]{STSong}
\setCJKsansfont{STHeiti}
\setCJKmonofont{STFangsong}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{float}
\usepackage{textcomp}
\usepackage{geometry}
\geometry{left=1.2cm,right=1.2cm,top=1.5cm,bottom=1.0cm}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{latexsym}
\usepackage{natbib}
\usepackage{listings}
\usepackage{minted}
\usepackage[xetex,colorlinks=true,CJKbookmarks=true,linkcolor=blue,urlcolor=blue,menucolor=blue]{hyperref}
\author{deepwaterooo}
\date{\today}
\title{Android Service}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 25.3.1 (Org mode 8.2.7c)}}
\begin{document}

\maketitle
\tableofcontents


\section{Android：Service生命周期完全解析}
\label{sec-1}
\begin{itemize}
\item 目录

\includegraphics[width=.9\linewidth]{./pic/serviceLifeCycle.png}
\end{itemize}
\subsection{生命周期 常用方法}
\label{sec-1-1}
官方说明图

\includegraphics[width=.9\linewidth]{./pic/serviceCallbacks.png}
\begin{itemize}
\item 在Service的生命周期里，常用的有：
\begin{itemize}
\item 4个手动调用的方法
\end{itemize}
\end{itemize}
\begin{center}
\begin{tabular}{ll}
\hline
手动调用方法 & 作用\\
\hline
startService() & 启动服务\\
stopService() & 关闭服务\\
bindService() & 绑定服务\\
unbindService() & 解绑服务\\
\hline
\end{tabular}
\end{center}
\begin{itemize}
\item 5个自动调用的方法
\end{itemize}
\begin{center}
\begin{tabular}{ll}
\hline
内部自动调用的方法 & 作用\\
\hline
onCreate() & 创建服务\\
onStartCommand() & 开始服务\\
onDestroy() & 销毁服务\\
onBind() & 绑定服务\\
onUnbind() & 解绑服务\\
\hline
\end{tabular}
\end{center}

\section{Android 四大组件：一份全面 \& 简洁的 Service 知识讲解攻略}
\label{sec-2}
\begin{itemize}
\item \url{https://www.jianshu.com/p/d963c55c3ab9}
\end{itemize}
\subsection{前言}
\label{sec-2-1}
Service作为 Android四大组件之一，应用非常广泛
本文将提供一份全面 \& 简洁的 Service知识讲解攻略，希望你们会喜欢
\subsection{目录}
\label{sec-2-2}

\includegraphics[width=1.3\linewidth]{./pic/service.png}
\subsection{简介}
\label{sec-2-3}
\begin{itemize}
\item 定义：服务，是Android四大组件之一， 属于 \textbf{计算型组件}
\item 作用：提供 需在后台长期运行的服务
\begin{itemize}
\item 如：复杂计算、音乐播放、下载等
\end{itemize}
\item 特点：无用户界面、在后台运行、生命周期长
\end{itemize}
\subsection{生命周期}
\label{sec-2-4}
\begin{itemize}
\item 具体请看前一章文章：Android：Service生命周期最全面解析
\begin{itemize}
\item \url{https://www.jianshu.com/p/8d0cde35eb10}
\end{itemize}
\end{itemize}
\subsection{类型}
\label{sec-2-5}
\begin{itemize}
\item Service可按照运行地点、运行类型 \& 功能进行分类，具体如下
\end{itemize}
\subsubsection{具体分类}
\label{sec-2-5-1}
\begin{itemize}
\item 按运行地点分类
\begin{itemize}
\item 本地服务
\item 远程服务
\end{itemize}
\item 按运行类型分类
\begin{itemize}
\item 前台服务
\item 后台服务
\end{itemize}
\item 按功能分类
\begin{itemize}
\item 可通信服务
\item 不可通信服务
\end{itemize}
\end{itemize}
\subsubsection{详细介绍}
\label{sec-2-5-2}
\begin{itemize}
\item 按运行地点分类
\end{itemize}
\begin{center}
\begin{tabular}{lllll}
\hline
类型 & 特点 & 优点 & 缺点 & 应用场景\\
\hline
本地 & -运行在主线程 & -节约资源 & -限制性大 & -需依附某个进程的服务\\
 & -主进程被禁止后，服务也会终止 & -通信方便： & 主进程被禁止后， & （最常用的服务类型如音乐播放）\\
 &  & 因在同一进程因此不需IPC和AIDL & 服务也会终止 & \\
\hline
远程 & -运行在独立进程 & -灵活： & -消耗资源：单独进程 & -系统级别服务\\
 & -服务常驻在后台， & 服务常驻在后台， & -使用AIDL进行IPC复杂 & \\
 & 不受其它activity影响 & 不受其它activity影响 &  & \\
\hline
\end{tabular}
\end{center}

\includegraphics[width=.9\linewidth]{./pic/location.png}
\begin{itemize}
\item 按运行类型分类

\includegraphics[width=.9\linewidth]{./pic/category.png}
\end{itemize}
\begin{center}
\begin{tabular}{lll}
\hline
类型 & 特点 & 应用场景\\
\hline
前台服务 & - 在通知栏显示通知 & 服务使用时需让用户知道并进行相关操作，如音乐播放\\
 & （用户可看到） & （服务被终止时，通知栏的通知也会消失）\\
\hline
后台服务 & - 处于后台的服务 & 服务使用时不需让用户知道并进行相关操作，如天气更新、日期同步\\
 & （用户无法看到） & （服务被终止时，用户无法知道）\\
\hline
\end{tabular}
\end{center}
\begin{itemize}
\item 按功能分类

\includegraphics[width=.9\linewidth]{./pic/function.png}
\end{itemize}
\begin{center}
\begin{tabular}{lll}
\hline
类型 & 特点 & 应用场景\\
\hline
不可通信服务 & -用startService()启动 & 服务不需与Activity \& Service通信\\
 & -调用者退出后service仍然存在 & \\
 &  & \\
\hline
可通信服务 & -用bindService()启动 & 服务需与Activity \& Service通信\\
 & -调用者退出后，随着调用者销毁 & 需控制服务开启时刻\\
 &  & *备注\\
\hline
可通信服务 & -使用startService()、bindService()启动 & 需与Activity \& Service通信\\
 & -调用者退出后，随着调用者销毁 & 不需控制服务开启时刻\\
 &  & 服务一开始便运行\\
\hline
\end{tabular}
\end{center}
\begin{itemize}
\item 备注
\begin{itemize}
\item 节约系统资源 = 第一次bindService()时才会创建服务的实例\&运行；特别当服务=remote service时，该效果越明显
\item 服务只是公开一个远程接口，供客户端Android/iOS远程调用执行方法
\item BroadcastReceiver也可完成需求，但使用BroadcastReceiver的缺点：若交互频繁，容易造成性能问题；且BroadcastReceiver本身执行代码的时间非常短且可能执行到一半，后面的代码便不会执行；而Service则没有这些问题
\end{itemize}
\end{itemize}
\subsection{使用讲解}
\label{sec-2-6}
\begin{itemize}
\item 下面，我将介绍每种Service的具体使用
\item 具体请看文章：Android：（本地、可通信的、前台、远程）Service使用全面介绍
\begin{itemize}
\item \url{https://www.jianshu.com/p/e04c4239b07e}
\end{itemize}
\end{itemize}
\subsection{其他思考}
\label{sec-2-7}
\subsubsection{Service 与 Thread的区别}
\label{sec-2-7-1}
\begin{itemize}
\item 结论：Service 与 Thread 无任何关系
\item 之所以有不少人会把它们联系起来，主要因为Service的后台概念
\begin{itemize}
\item \textbf{后台} ：后台任务运行完全不依赖UI，即使Activity被销毁 / 程序被关闭，只要进程还在，后台任务就可继续运行
\end{itemize}
\item 关于二者的异同，具体如下图：

\includegraphics[width=.9\linewidth]{./pic/serviceThreadDiff.png}

\includegraphics[width=.9\linewidth]{./pic/diff.png}
\item 注：一般会将 Service 和 Thread联合着用，即在Service中再创建一个子线程（工作线程）去处理耗时操作逻辑，如下代码：
\begin{minted}[linenos=true]{java}
@Override  
public int onStartCommand(Intent intent, int flags, int startId) {  
    // 新建工作线程
    new Thread(new Runnable() {  
        @Override  
        public void run() {  
            // 开始执行后台任务  
        }  
    }).start();  
    return super.onStartCommand(intent, flags, startId);  
}  
class MyBinder extends Binder {  
    public void service_connect_Activity() {  
        // 新建工作线程
        new Thread(new Runnable() {  
            @Override  
            public void run() {  
                // 执行具体的下载任务  
            }  
        }).start();  
    }  
}
\end{minted}
\end{itemize}
\subsubsection{Service和IntentService的区别}
\label{sec-2-7-2}
具体请看文章：Android多线程：IntentService用法\&源码
\begin{itemize}
\item \url{https://www.jianshu.com/p/8a3c44a9173a} Android 多线程 解析：IntentService（含源码解析）
\end{itemize}


\section{Android：（本地、可通信的、前台、远程）Service使用全面介绍}
\label{sec-3}
\begin{itemize}
\item \url{https://www.jianshu.com/p/e04c4239b07e}
\end{itemize}
\subsection{前言}
\label{sec-3-1}
Service作为Android四大组件之一，应用非常广泛
本文将介绍Service最基础的知识：Service的生命周期
如果你对Service还未了解，建议先阅读我写的文章：
Android四大组件：Service史上最全面解析
\subsection{目录}
\label{sec-3-2}

\includegraphics[width=.9\linewidth]{./pic/service2.png}
\subsection{Service分类}
\label{sec-3-3}
\subsubsection{Service的类型}
\label{sec-3-3-1}
\begin{itemize}
\item 按运行地点分类
\begin{itemize}
\item 本地服务
\item 远程服务
\end{itemize}
\item 按运行类型分类
\begin{itemize}
\item 前台服务
\item 后台服务
\end{itemize}
\item 按功能分类
\begin{itemize}
\item 可通信服务
\item 不可通信服务
\end{itemize}
\end{itemize}
\subsubsection{特点}
\label{sec-3-3-2}
\begin{itemize}
\item 详见前一章的三个表格
\end{itemize}
\subsection{具体使用解析}
\label{sec-3-4}
\subsubsection{本地Service}
\label{sec-3-4-1}
\begin{itemize}
\item 这是最普通、最常用的后台服务Service。
\end{itemize}
\begin{enumerate}
\item 使用步骤
\label{sec-3-4-1-1}
\begin{itemize}
\item 步骤1：新建子类继承Service类
\begin{itemize}
\item 需重写父类的 onCreate()、onStartCommand()、onDestroy()和onBind()方法
\end{itemize}
\item 步骤2：构建用于启动Service的Intent对象
\item 步骤3：调用startService()启动Service、调用stopService()停止服务
\item 步骤4：在AndroidManifest.xml里注册Service
\end{itemize}
\item 实例Demo
\label{sec-3-4-1-2}
接下来我将用一个实例Demo进行本地Service说明
\begin{itemize}
\item 建议先下载Demo再进行阅读：（carson.ho的Github地址）Demo\_for\_Service
\begin{itemize}
\item \url{https://github.com/Carson-Ho/Demo_Service/tree/5e2a70cf2d75c56bbfa1abc0ead16c5ad8cae83f}
\end{itemize}
\item 步骤1：新建子类继承Service类
\begin{itemize}
\item 需重写父类的onCreate()、onStartCommand()、onDestroy()和onBind()
\item MyService.java
\end{itemize}
\begin{minted}[linenos=true]{java}
public class MyService extends Service {
    // 启动Service之后，
    // 就可以在onCreate()或onStartCommand()方法里去执行一些具体的逻辑
    // 由于这里作Demo用，所以只打印一些语句
    @Override
    public void onCreate() {
        super.onCreate();
        System.out.println("执行了onCreat()");
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        System.out.println("执行了onStartCommand()");
        return super.onStartCommand(intent, flags, startId);
    }
    @Override
    public void onDestroy() {
        super.onDestroy();
        System.out.println("执行了onDestory()");
    }
    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
}
\end{minted}
\item 步骤2：在主布局文件设置两个Button分别用于启动和停止Service
\begin{itemize}
\item activity\_main.xml
\end{itemize}
\begin{minted}[linenos=true]{xml}
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context="scut.carson_ho.demo_service.MainActivity">
    <Button
        android:layout_centerInParent="true"
        android:id="@+id/startService"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="启动服务" />
    <Button
        android:layout_centerInParent="true"
        android:layout_below="@+id/startService"
        android:id="@+id/stopService"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="停止服务" />
</RelativeLayout>
\end{minted}
\item 步骤3：构建Intent对象，并调用startService()启动Service、stopService停止服务
\begin{itemize}
\item MainActivity.java
\end{itemize}
\begin{minted}[linenos=true]{java}
public class MainActivity extends AppCompatActivity
    implements View.OnClickListener {

    private Button startService;
    private Button stopService;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        startService = (Button) findViewById(R.id.startService);
        stopService = (Button) findViewById(R.id.stopService);
        startService.setOnClickListener(this);
        startService.setOnClickListener(this);
    }
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            // 点击启动Service Button
            case R.id.startService:
                // 构建启动服务的Intent对象
                Intent startIntent = new Intent(this, MyService.class);
                // 调用startService()方法-传入Intent对象,以此启动服务
                startService(startIntent);
            // 点击停止Service Button
            case R.id.stopService:
                // 构建停止服务的Intent对象
                Intent stopIntent = new Intent(this, MyService.class);
                // 调用stopService()方法-传入Intent对象,以此停止服务
                stopService(stopIntent);
        }
    }
}
\end{minted}
\item 步骤4：在AndroidManifest.xml里注册Service
\begin{itemize}
\item AndroidManifest.xml
\end{itemize}
\begin{minted}[linenos=true]{xml}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="scut.carson_ho.demo_service">
    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        //注册Service服务
        <service android:name=".MyService">
        </service>
    </application>
</manifest>
\end{minted}
\item Androidmanifest里Service的常见属性说明
\end{itemize}
\begin{center}
\begin{tabular}{lll}
\hline
属性 & 说明 & 备注\\
\hline
android:name & Service的类名 & \\
android:label & Service的名字 & 若不设置，默认为Service类名\\
android:icon & Service的图标 & \\
\hline
android:permission & 申明此Service的权限 & 有提供了该权限的应用才能控制\\
 &  & 或连接此服务\\
\hline
android:process & 表示该服务是否在另一个进程中运行（远程服务) & 不设置默认为本地服务；\\
 &  & remote则设置成远程服务\\
\hline
android:enabled & 系统默认启动 & true：Service 将会默认被系统启动；\\
 &  & 不设置则默认为false\\
\hline
android:exported & 该服务是否能够被其他应用程序所控制或连接 & 不设置默认此项为 false\\
\hline
\end{tabular}
\end{center}

\item 测试结果
\label{sec-3-4-1-3}

\includegraphics[width=.9\linewidth]{./pic/log.png}
\item Demo地址
\label{sec-3-4-1-4}
\begin{itemize}
\item Carson.ho的Github地址：Demo\_for\_Service
\begin{itemize}
\item \url{https://github.com/Carson-Ho/Demo_Service/tree/5e2a70cf2d75c56bbfa1abc0ead16c5ad8cae83f}
\end{itemize}
\end{itemize}
\end{enumerate}
\subsubsection{可通信的服务Service}
\label{sec-3-4-2}
\begin{itemize}
\item 上面介绍的Service是最基础的，但只能单机使用，即无法与Activity通信
\item 接下来将在上面的基础用法上，增设"与Activity通信”的功能，即使用绑定Service服务（Binder类、bindService()、onBind(）、unbindService()、onUnbind()）
\end{itemize}
\begin{enumerate}
\item 实例Demo
\label{sec-3-4-2-1}
接下来我将用一个实例Demo进行可通信的服务Service说明
\begin{itemize}
\item 建议先下载Demo再进行阅读：（carson.ho的Github地址）Demo\_for\_Service
\begin{itemize}
\item \url{https://github.com/Carson-Ho/Demo_Service/tree/719e3b9ffd5017c334cdfdaf45b6a72776a2066a}
\end{itemize}
\item 步骤1：在新建子类继承Service类，并新建一个子类继承自Binder类、写入与Activity关联需要的方法、创建实例
\begin{minted}[linenos=true]{java}
public class MyService extends Service {
    private MyBinder mBinder = new MyBinder();
    @Override
    public void onCreate() {
        super.onCreate();
        System.out.println("执行了onCreat()");
    }
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        System.out.println("执行了onStartCommand()");
        return super.onStartCommand(intent, flags, startId);
    }
    @Override
    public void onDestroy() {
        super.onDestroy();
        System.out.println("执行了onDestory()");
    }
    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        System.out.println("执行了onBind()");
        //返回实例
        return mBinder;
    }
    @Override
    public boolean onUnbind(Intent intent) {
        System.out.println("执行了onUnbind()");
        return super.onUnbind(intent);
    }
    //新建一个子类继承自Binder类
    class MyBinder extends Binder {
        public void service_connect_Activity() {
            System.out.println("Service关联了Activity,并在Activity执行了Service的方法");
        }
    }
}
\end{minted}
\item 步骤2：在主布局文件再设置两个Button分别用于绑定和解绑Service
\begin{minted}[linenos=true]{xml}
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context="scut.carson_ho.demo_service.MainActivity">
    <Button
        android:layout_centerInParent="true"
        android:id="@+id/startService"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="启动服务" />
    <Button
        android:layout_centerInParent="true"
        android:layout_below="@+id/startService"
        android:id="@+id/stopService"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="停止服务" />
    <Button
        android:layout_centerInParent="true"
        android:layout_below="@id/stopService"
        android:id="@+id/bindService"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="绑定服务" />
    <Button
        android:layout_centerInParent="true"
        android:layout_below="@id/bindService"
        android:id="@+id/unbindService"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="解绑服务"
        />
</RelativeLayout>
\end{minted}
\item 步骤3：在Activity通过调用MyBinder类中的public方法来实现Activity与Service的联系
\begin{itemize}
\item 即实现了Activity指挥Service干什么Service就去干什么的功能
\item MainActivity.java
\end{itemize}
\begin{minted}[linenos=true]{java}
public class MainActivity extends AppCompatActivity implements View.OnClickListener {
    private Button startService;
    private Button stopService;
    private Button bindService;
    private Button unbindService;
    private MyService.MyBinder myBinder;
    
    // 创建ServiceConnection的匿名类
    private ServiceConnection connection = new ServiceConnection() {
            // 重写onServiceConnected()方法和onServiceDisconnected()方法
            // 在Activity与Service建立关联和解除关联的时候调用
            @Override
            public void onServiceDisconnected(ComponentName name) {
            }
            // 在Activity与Service解除关联的时候调用
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                // 实例化Service的内部类myBinder
                // 通过向下转型得到了MyBinder的实例
                myBinder = (MyService.MyBinder) service;
                // 在Activity调用Service类的方法
                myBinder.service_connect_Activity();
            }
        };
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        startService = (Button) findViewById(R.id.startService);
        stopService = (Button) findViewById(R.id.stopService);
        startService.setOnClickListener(this);
        stopService.setOnClickListener(this);
        bindService = (Button) findViewById(R.id.bindService);
        unbindService = (Button) findViewById(R.id.unbindService);
        bindService.setOnClickListener(this);
        unbindService.setOnClickListener(this);
    }
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            // 点击启动Service
        case R.id.startService:
            // 构建启动服务的Intent对象
            Intent startIntent = new Intent(this, MyService.class);
            // 调用startService()方法-传入Intent对象,以此启动服务
            startService(startIntent);
            break;
            // 点击停止Service
        case R.id.stopService:
            // 构建停止服务的Intent对象
            Intent stopIntent = new Intent(this, MyService.class);
            // 调用stopService()方法-传入Intent对象,以此停止服务
            stopService(stopIntent);
            break;
            // 点击绑定Service
        case R.id.bindService:
            // 构建绑定服务的Intent对象
            Intent bindIntent = new Intent(this, MyService.class);
            // 调用bindService()方法,以此停止服务
            bindService(bindIntent,connection,BIND_AUTO_CREATE);
            // 参数说明
            // 第一个参数:Intent对象
            // 第二个参数:上面创建的Serviceconnection实例
            // 第三个参数:标志位
            // 这里传入BIND_AUTO_CREATE表示在Activity和Service建立关联后自动创建Service
            // 这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行
            break;
            // 点击解绑Service
        case R.id.unbindService:
            // 调用unbindService()解绑服务
            // 参数是上面创建的Serviceconnection实例
            unbindService(connection);
            break;
        default:
            break;
        }
    }
}
\end{minted}
\end{itemize}

\item 测试结果
\label{sec-3-4-2-2}

\includegraphics[width=.9\linewidth]{./pic/log2.png}
\item Demo
\label{sec-3-4-2-3}
\begin{itemize}
\item carson.ho的Github地址：Demo\_for\_Service
\begin{itemize}
\item \url{https://github.com/Carson-Ho/Demo_Service/tree/719e3b9ffd5017c334cdfdaf45b6a72776a2066a}
\end{itemize}
\end{itemize}
\end{enumerate}
\subsubsection{前台Service}
\label{sec-3-4-3}
\begin{itemize}
\item 前台Service和后台Service（普通）最大的区别就在于：
\begin{itemize}
\item 前台Service在下拉通知栏有显示通知，但后台Service没有；
\item 前台Service优先级较高，不会由于系统内存不足而被回收；后台Service优先级较低，当系统出现内存不足情况时，很有可能会被回收
\end{itemize}
\end{itemize}
\begin{enumerate}
\item 具体使用
\label{sec-3-4-3-1}
\begin{itemize}
\item 用法很简单，只需要在原有的Service类对onCreate()方法进行稍微修改即可，如下图：
\begin{minted}[linenos=true]{java}
@Override
public void onCreate() {
    super.onCreate();
    System.out.println("执行了onCreat()");

    // 添加下列代码将后台Service变成前台Service
    // 构建"点击通知后打开MainActivity"的Intent对象
    Intent notificationIntent = new Intent(this,MainActivity.class);
    PendingIntent pendingIntent = PendingIntent.getActivity(this,0,notificationIntent,0);
    // 新建Builer对象
    Notification.Builder builer = new Notification.Builder(this);
    builer.setContentTitle("前台服务通知的标题");// 设置通知的标题
    builer.setContentText("前台服务通知的内容"); // 设置通知的内容
    builer.setSmallIcon(R.mipmap.ic_launcher); // 设置通知的图标
    builer.setContentIntent(pendingIntent);    // 设置点击通知后的操作
    Notification notification = builer.getNotification();// 将Builder对象转变成普通的notification
    startForeground(1, notification);// 让Service变成前台Service,并在系统的状态栏显示出来
}
\end{minted}
\end{itemize}
\item 测试结果
\label{sec-3-4-3-2}
\begin{itemize}
\item 运行后，当点击Start Service或Bind Service按钮，Service就会以前台Service的模式启动（通知栏上有通知），如下图

\includegraphics[width=.9\linewidth]{./pic/frontService.png}
\end{itemize}
\end{enumerate}
\subsubsection{远程Service}
\label{sec-3-4-4}
\begin{itemize}
\item 具体请看我写的另外一篇文章：Android：远程服务Service（含AIDL \& IPC讲解）
\begin{itemize}
\item \url{https://www.jianshu.com/p/34326751b2c6}
\end{itemize}
\end{itemize}
\subsection{使用场景}
\label{sec-3-5}
\begin{itemize}
\item 通过上述描述，你应该对Service类型及其使用非常了解；
\item 那么，我们该什么时候用哪种类型的Service呢？
\item 各种Service的使用场景请看下图：

\includegraphics[width=.9\linewidth]{./pic/use.png}
\end{itemize}

\begin{center}
\begin{tabular}{lllll}
\hline
类型 & 特点 & 优点 & 缺点 & 应用场景\\
\hline
本地 & -运行在主线程 & -节约资源 & -限制性大 & -需依附某个进程的服务\\
 & -主进程被禁止后，服务也会终止 & -通信方便： & 主进程被禁止后， & （最常用的服务类型如音乐播放）\\
 &  & 因在同一进程因此不需IPC和AIDL & 服务也会终止 & \\
\hline
远程 & -运行在独立进程 & -灵活： & -消耗资源：单独进程 & -系统级别服务\\
 & -服务常驻在后台， & 服务常驻在后台， & -使用AIDL进行IPC复杂 & \\
 & 不受其它activity影响 & 不受其它activity影响 &  & \\
\hline
\end{tabular}
\end{center}

\includegraphics[width=.9\linewidth]{./pic/location.png}
\begin{itemize}
\item 按运行类型分类

\includegraphics[width=.9\linewidth]{./pic/category.png}
\end{itemize}
\begin{center}
\begin{tabular}{llll}
\hline
类型 & 应用场景 & 备注 & \\
\hline
本地服务 & 需依附某个进程的服务，如音乐播放 & 最常用、最普通 & \\
远程服务 & 系统级别服务 &  & \\
\hline
前台服务 & 服务使用时需让用户知道并进行相关操作，如音乐播放 & 服务被终止时，通知栏的通知也会消失 & \\
后台服务 & 服务使用时不需让用户知道并进行相关操作，如天气更新、日期同步 & 服务被终止时，用户无法知道 & \\
\hline
不可通信服务 & 启动在后台长期运行的服务， & 使用startService()启动 & \\
 & \textbf{不} 需与Activity \& Service通信 &  & \\
\hline
可通信服务 & 启动在后台长期运行的服务, & 用bindService()启动 & \\
 & 需与Activity \& Service通信 & *备注 & \\
 & 需控制服务开启时刻 &  & \\
\hline
可通信服务 & 启动在后台长期运行的服务， & 使用startService()、bindService()启动 & \\
 & 需与Activity \& Service通信 &  & \\
 & \textbf{不} 需控制服务开启时刻 &  & \\
\hline
\end{tabular}
\end{center}
\begin{itemize}
\item 备注
\begin{itemize}
\item 用bindService()启动
\item 第一次bindService()时才会创建服务的实例并运行它，节约很多系统资源，特别是当服务是Remote Service时，该效果会更明显
\item 服务只是公开一个远程接口，供客户端Android、iOS远程调用执行方法
\item BroadcastReceiver也可完成需求,但使用BroadcastReceiver的缺点：若交互频繁，容易造成性能问题；且BroadcastReceiver本身执行代码的时间非常短且可能执行到一半,后面的代码便不会执行，而Service则没有这些问题
\end{itemize}
\end{itemize}


\section{Android 多线程 解析：IntentService（含源码解析）}
\label{sec-4}
\begin{itemize}
\item \url{https://www.jianshu.com/p/8a3c44a9173a}
\end{itemize}
\subsection{前言}
\label{sec-4-1}
\begin{itemize}
\item 多线程的应用在Android开发中是非常常见的，常用方法主要有：
\begin{itemize}
\item 继承Thread类
\item 实现Runnable接口
\item AsyncTask
\item Handler
\item HandlerThread
\item IntentService
\end{itemize}
\item 今天，我将全面解析多线程其中一种常见用法：IntentService
\end{itemize}
\subsection{定义}
\label{sec-4-2}
\begin{itemize}
\item Android里的一个封装类，继承四大组件之一的Service
\end{itemize}
\subsection{作用}
\label{sec-4-3}
\begin{itemize}
\item 处理异步请求 \& 实现多线程
\end{itemize}
\subsection{使用场景}
\label{sec-4-4}
\begin{itemize}
\item 线程任务 需 按顺序、在后台执行
\begin{itemize}
\item 最常见的场景：离线下载
\item 不符合多个数据同时请求的场景：所有的任务都在同一个Thread looper里执行
\end{itemize}
\end{itemize}
\subsection{使用步骤}
\label{sec-4-5}
\begin{itemize}
\item 步骤1：定义 IntentService的子类
\begin{itemize}
\item 需传入线程名称、复写onHandleIntent()方法
\end{itemize}
\item 步骤2：在Manifest.xml中注册服务
\item 步骤3：在Activity中开启Service服务
\end{itemize}
\subsection{实例应用}
\label{sec-4-6}
\begin{itemize}
\item 步骤1：定义 IntentService的子类
\begin{itemize}
\item 传入线程名称、复写onHandleIntent()方法
\end{itemize}
\begin{minted}[linenos=true]{java}
public class myIntentService extends IntentService {
    // 在构造函数中传入线程名字
    public myIntentService() {
        // 调用父类的构造函数
        // 参数 = 工作线程的名字
        super("myIntentService");
    }
   /** 
     * 复写onHandleIntent()方法
     * 根据 Intent实现 耗时任务 操作
     **/  
    @Override
    protected void onHandleIntent(Intent intent) {
        // 根据 Intent的不同，进行不同的事务处理
        String taskName = intent.getExtras().getString("taskName");
        switch (taskName) {
            case "task1":
                Log.i("myIntentService", "do task1");
                break;
            case "task2":
                Log.i("myIntentService", "do task2");
                break;
            default:
                break;
        }
    }
    @Override
    public void onCreate() {
        Log.i("myIntentService", "onCreate");
        super.onCreate();
    }
   /** 
     * 复写onStartCommand()方法
     * 默认实现 = 将请求的Intent添加到工作队列里
     **/  
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.i("myIntentService", "onStartCommand");
        return super.onStartCommand(intent, flags, startId);
    }
    @Override
    public void onDestroy() {
        Log.i("myIntentService", "onDestroy");
        super.onDestroy();
    }
}
\end{minted}
\item 步骤2：在Manifest.xml中注册服务
\begin{minted}[linenos=true]{xml}
<service android:name=".myIntentService">
            <intent-filter >
                <action android:name="cn.scu.finch"/>
            </intent-filter>
        </service>
\end{minted}
\item 步骤3：在Activity中开启Service服务
\begin{minted}[linenos=true]{java}
public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        // 同一服务只会开启1个工作线程
        // 在onHandleIntent（）函数里，依次处理传入的Intent请求
        // 将请求通过Bundle对象传入到Intent，再传入到服务里
        // 请求1
        Intent i = new Intent("cn.scu.finch");
        Bundle bundle = new Bundle();
        bundle.putString("taskName", "task1");
        i.putExtras(bundle);
        startService(i);
        // 请求2
        Intent i2 = new Intent("cn.scu.finch");
        Bundle bundle2 = new Bundle();
        bundle2.putString("taskName", "task2");
        i2.putExtras(bundle2);
        startService(i2);
        startService(i);  //多次启动
    }
}
\end{minted}
\item 测试结果
\begin{minted}[linenos=true]{java}
Tag Text
myIntentService onCreate
myIntentService onStartCommand
myIntentService onStartCommand
myIntentService do task1
myIntentService onStartCommand
myIntentService do task2
myIntentService do task1
myIntentService onDestory
\end{minted}
\end{itemize}

\subsection{源码分析}
\label{sec-4-7}
\begin{itemize}
\item IntentService的源码工作流程如下：

\includegraphics[width=.9\linewidth]{./pic/IntentService.png}
\item 特别注意：若启动IntentService 多次，那么 每个耗时操作 则 以队列的方式 在 IntentService的 onHandleIntent回调方法中依次执行，执行完自动结束
\item 接下来，我们将通过 源码分析 解决以下问题：
\begin{itemize}
\item IntentService 如何单独开启1个新的工作线程
\item IntentService 如何通过onStartCommand() 将Intent 传递给服务 \& 依次插入到工作队列中
\end{itemize}
\end{itemize}
\subsubsection{IntentService如何单独开启1个新的工作线程}
\label{sec-4-7-1}
\begin{itemize}
\item 主要分析内容  = IntentService源码中的 onCreate()方法
\begin{minted}[linenos=true]{java}
@Override
public void onCreate() {
    super.onCreate();
    
    // 1. 通过实例化andlerThread新建线程 & 启动；故 使用IntentService时，不需额外新建线程
    // HandlerThread继承自Thread，内部封装了 Looper
    HandlerThread thread = new HandlerThread("IntentService[" + mName + "]");
    thread.start();
  
    // 2. 获得工作线程的 Looper & 维护自己的工作队列
    mServiceLooper = thread.getLooper();
    // 3. 新建mServiceHandler & 绑定上述获得Looper
    // 新建的Handler 属于工作线程 ->>分析1
    mServiceHandler = new ServiceHandler(mServiceLooper); 
}
/** 
 * 分析1：ServiceHandler源码分析
 **/ 
 private final class ServiceHandler extends Handler {
     // 构造函数
     public ServiceHandler(Looper looper) {
     super(looper);
   }
    // IntentService的handleMessage（）把接收的消息交给onHandleIntent()处理
    @Override
     public void handleMessage(Message msg) {

      // onHandleIntent 方法在工作线程中执行
      // onHandleIntent() = 抽象方法，使用时需重写 ->>分析2
      onHandleIntent((Intent)msg.obj);
      // 执行完调用 stopSelf() 结束服务
      stopSelf(msg.arg1);
    }
}
/** 
 * 分析2： onHandleIntent()源码分析
 * onHandleIntent() = 抽象方法，使用时需重写
 **/ 
@WorkerThread
protected abstract void onHandleIntent(Intent intent);
\end{minted}
\end{itemize}
\subsubsection{IntentService 如何通过onStartCommand() 将Intent 传递给服务 \& 依次插入到工作队列中}
\label{sec-4-7-2}
\begin{minted}[linenos=true]{java}
/** 
 * onStartCommand（）源码分析
 * onHandleIntent() = 抽象方法，使用时需重写
 **/ 
public int onStartCommand(Intent intent, int flags, int startId) {
    // 调用onStart（）->>分析1
    onStart(intent, startId);
    return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;
}
/** 
  * 分析1：onStart(intent, startId)
  **/ 
  public void onStart(Intent intent, int startId) {
    // 1. 获得ServiceHandler消息的引用
    Message msg = mServiceHandler.obtainMessage();
    msg.arg1 = startId;
    // 2. 把 Intent参数 包装到 message 的 obj 发送消息中，
    //这里的Intent  = 启动服务时startService(Intent) 里传入的 Intent
    msg.obj = intent;
    // 3. 发送消息，即 添加到消息队列里
    mServiceHandler.sendMessage(msg);
}
\end{minted}
\subsection{总结}
\label{sec-4-8}
从上面源码可看出：IntentService本质 = Handler + HandlerThread：
\begin{itemize}
\item 通过HandlerThread 单独开启1个工作线程：IntentService
\item 创建1个内部 Handler ：ServiceHandler
\item 绑定 ServiceHandler 与 IntentService
\item 通过 onStartCommand() 传递服务intent 到ServiceHandler、依次插入Intent到工作队列中 \& 逐个发送给 onHandleIntent()
\item 通过onHandleIntent()依次处理所有Intent对象所对应的任务
\begin{itemize}
\item 因此我们通过复写onHandleIntent() \& 在里面 根据Intent的不同进行不同线程操作 即可
\end{itemize}
\end{itemize}

\subsection{注意事项}
\label{sec-4-9}
\begin{enumerate}
\item 工作任务队列 = 顺序执行
\label{sec-4-9-0-1}

即 若一个任务正在IntentService中执行，此时你再发送1个新的任务请求，这个新的任务会一直等待直到前面一个任务执行完毕后才开始执行
\begin{itemize}
\item 原因：
\begin{itemize}
\item 由于onCreate()只会调用一次 = 只会创建1个工作线程；
\item 当多次调用 startService(Intent)时（即 onStartCommand（）也会调用多次），其实不会创建新的工作线程，只是把消息加入消息队列中 \& 等待执行。
\item 所以，多次启动 IntentService 会按顺序执行事件
\end{itemize}
\end{itemize}

若服务停止，则会清除消息队列中的消息，后续的事件不执行
\item 不建议通过 bindService() 启动 IntentService
\label{sec-4-9-0-2}

原因：
\begin{minted}[linenos=true]{java}
// 在IntentService中，onBind()`默认返回null
@Override
public IBinder onBind(Intent intent) {
    return null;
}
\end{minted}
\begin{itemize}
\item 采用 bindService()启动 IntentService的生命周期如下：
\begin{minted}[linenos=true]{java}
onCreate() ->> onBind() ->> onUnbind()->> onDestory()
\end{minted}
\item 即，并不会调用onStart() 或 onStartcommand()，故不会将消息发送到消息队列，那么onHandleIntent()将不会回调，即无法实现多线程的操作
\begin{itemize}
\item 此时，你应该使用Service，而不是IntentService
\end{itemize}
\end{itemize}
\end{enumerate}
\subsection{对比}
\label{sec-4-10}
\subsubsection{IntentService与Service的区别}
\label{sec-4-10-1}
\begin{center}
\begin{tabular}{lll}
\hline
类型 & 运行线程 & 结束服务操作\\
\hline
Service & 主线程 & 需主动调用stopService()\\
 & 不能处理耗时操作，否则会出现ANR & \\
\hline
IntentService & 创建一个工作线程处理多线程任务 & 不需要\\
 &  & 在所有Intent被处理完后系统会自动关闭服务\\
\hline
\end{tabular}
\end{center}

\begin{itemize}
\item 备注：
\begin{itemize}
\item IntentService为Service的onBind()提供了默认实现：返回null
\item IntentService为Service的onStartCommand()提供了默认实现：将请求的intent添加到队列中
\end{itemize}
\end{itemize}
\subsubsection{IntentService与其他线程的区别}
\label{sec-4-10-2}

\includegraphics[width=.9\linewidth]{./pic/serviceIntentService.png}

\subsection{总结}
\label{sec-4-11}
\begin{itemize}
\item 本文主要 全面介绍了 多线程IntentService用法 \& 源码
\item 接下来，我会继续讲解Android开发中关于多线程的知识，包括继承Thread类、实现Runnable接口、Handler等等，有兴趣可以继续关注Carson\_Ho的安卓开发笔记
\end{itemize}



\section{Android：远程服务Service（含AIDL \& IPC讲解）}
\label{sec-5}
\begin{itemize}
\item \url{https://www.jianshu.com/p/34326751b2c6}
\end{itemize}
\subsection{前言}
\label{sec-5-1}
\begin{itemize}
\item Service作为Android四大组件之一，应用非常广泛
\item 本文将介绍Service其中一种常见用法：远程Service
\end{itemize}
\subsection{远程服务与本地服务的区别}
\label{sec-5-2}
\begin{itemize}
\item 远程服务与本地服务最大的区别是：远程Service与调用者不在同一个进程里（即远程Service是运行在另外一个进程）；而本地服务则是与调用者运行在同一个进程里
\item 二者区别的详细区别如下图：

\includegraphics[width=.9\linewidth]{./pic/diff2.png}
\end{itemize}
\begin{center}
\begin{tabular}{lllll}
\hline
类型 & 特点 & 优点 & 缺点 & 应用场景\\
\hline
本地 & 1运行在主线程 & 1节约资源 & 限制性大: & 需依附某个进程的服务\\
Local & 2主进程被禁止后， & 2通信方便： & 主进程被禁止后， & （如音乐播放）\\
Service & 服务也会终止 & 在同一进程=>不需IPC和AIDL & 服务也会终止 & \\
\hline
远程 & 1运行在独立进程 & 灵活： & 1消耗资源：单独进程 & 系统级别服务\\
Remote & 2服务常驻在后台， & 服务常驻在后台， & 2使用AIDL进行IPC复杂 & \\
Service & 不受其它activity影响 & 不受其它activity影响 &  & \\
\hline
\end{tabular}
\end{center}

\subsection{使用场景}
\label{sec-5-3}
\begin{itemize}
\item 多个应用程序共享同一个后台服务（远程服务）
\begin{itemize}
\item 即一个远程Service与多个应用程序的组件（四大组件）进行跨进程通信
\end{itemize}
\end{itemize}
\subsection{使用场景}
\label{sec-5-4}

\includegraphics[width=.9\linewidth]{./pic/remoteService.png}
\subsection{具体使用}
\label{sec-5-5}
\begin{itemize}
\item 为了让远程Service与多个应用程序的组件（四大组件）进行跨进程通信（IPC），需要使用AIDL
\begin{itemize}
\item \textbf{IPC} ： \textbf{Inter-Process Communication} ，即跨进程通信
\item \textbf{AIDL} ： \textbf{Android Interface Definition Language} ，即Android接口定义语言；
\begin{itemize}
\item 用于让某个Service与多个应用程序组件之间进行跨进程通信，从而可以实现多个应用程序共享同一个Service的功能。
\end{itemize}
\end{itemize}
\item 在多进程通信中，存在两个进程角色（以最简单的为例）：服务器端和客户端
\item 以下是两个进程角色的具体使用步骤：
\begin{itemize}
\item \textbf{服务器端（Service）}
\begin{itemize}
\item 步骤1：新建定义AIDL文件，并声明该服务需要向客户端提供的接口
\item 步骤2：在Service子类中实现AIDL中定义的接口方法，并定义生命周期的方法（onCreate()、onStartCommand()、onBind()、onUnbind()、onDestory()）
\item 步骤3：在AndroidMainfest.xml中注册服务 \& 声明为远程服务
\end{itemize}
\item \textbf{客户端（Client）}
\begin{itemize}
\item 步骤1：拷贝服务端的AIDL文件到目录下
\item 步骤2：使用Stub.asInterface接口获取服务器的Binder，根据需要调用服务提供的接口方法
\item 步骤3：通过Intent指定服务端的服务名称和所在包，绑定远程Service
\end{itemize}
\end{itemize}
\item 接下来，我将用一个具体实例来介绍远程Service的使用
\end{itemize}

\subsection{具体实例}
\label{sec-5-6}
\begin{itemize}
\item 实例描述：客户端远程调用服务器端的远程Service
\item 具体使用：
\end{itemize}
\subsubsection{服务器端（Service）}
\label{sec-5-6-1}

新建一个服务器端的工程：Service - server
\begin{itemize}
\item 先下Demo再看，效果会更好：Github\_RemoteService\_Server
\item 步骤1. 新建一个AIDL文件
\begin{itemize}
\item New ==> AIDL ==>　AIDL File
\end{itemize}
\item 步骤2. 在新建AIDL文件里定义Service需要与Activity进行通信的内容（方法），并进行编译（Make Project）
\begin{minted}[linenos=true]{java}
// 在新建的AIDL_Service1.aidl里声明需要与Activity进行通信的方法
package scut.carson_ho.demo_service;
interface AIDL_Service1 {
    void AIDL_Service();
}
//AIDL中支持以下的数据类型
//1. 基本数据类型
//2. String 和CharSequence
//3. List 和 Map ,List和Map 对象的元素必须是AIDL支持的数据类型;
//4. AIDL自动生成的接口（需要导入-import）
//5. 实现android.os.Parcelable 接口的类（需要导入-import)
\end{minted}
\end{itemize}

编译
\begin{itemize}
\item 步骤3：在Service子类中实现AIDL中定义的接口方法，并定义生命周期的方法（onCreate()、onBind()、onUnbind() etc）
\begin{itemize}
\item MyService.java
\end{itemize}
\begin{minted}[linenos=true]{java}
/** 
 * onStartCommand（）源码分析
 * onHandleIntent() = 抽象方法，使用时需重写
 **/ 
public int onStartCommand(Intent intent, int flags, int startId) {
    // 调用onStart（）->>分析1
    onStart(intent, startId);
    return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;
}
/** 
 * 分析1：onStart(intent, startId)
 **/ 
public void onStart(Intent intent, int startId) {
    // 1. 获得ServiceHandler消息的引用
    Message msg = mServiceHandler.obtainMessage();
    msg.arg1 = startId;
    // 2. 把 Intent参数 包装到 message 的 obj 发送消息中，
    //这里的Intent  = 启动服务时startService(Intent) 里传入的 Intent
    msg.obj = intent;
    // 3. 发送消息，即 添加到消息队列里
    mServiceHandler.sendMessage(msg);
}
\end{minted}
\item 步骤4：在AndroidMainfest.xml中注册服务 \& 声明为远程服务
\begin{minted}[linenos=true]{xml}
<service
    android:name=".MyService"
    android:process=":remote"  //将本地服务设置成远程服务
    android:exported="true"      //设置可被其他进程调用
    //该Service可以响应带有scut.carson_ho.service_server.AIDL_Service1这个action的Intent。
    //此处Intent的action必须写成"服务器端包名.aidl文件名”
    <intent-filter>
      <action android:name="scut.carson_ho.service_server.AIDL_Service1"/>
    </intent-filter>
</service>
\end{minted}
\item 至此，服务器端（远程Service）已经完成了。
\end{itemize}
\subsubsection{客户端（Client）}
\label{sec-5-6-2}

新建一个客户端的工程：Service - Client
\begin{itemize}
\item 先下Demo再看，效果会更好：Github\_RemoteService\_Client
\item 步骤1：将服务端的AIDL文件所在的包复制到客户端目录下（Project/app/src/main），并进行编译
\begin{itemize}
\item 注：记得要原封不动地复制！！什么都不要改！
\end{itemize}
\item 步骤2：在主布局文件定义"绑定服务”的按钮
\begin{itemize}
\item MainActivity.xml
\end{itemize}
\begin{minted}[linenos=true]{xml}
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context="scut.carson_ho.service_client.MainActivity">
    <Button
        android:layout_centerInParent="true"
        android:id="@+id/bind_service"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="绑定服务"
        />
</RelativeLayout>
\end{minted}
\item 步骤3：在MainActivity.java里
\begin{itemize}
\item 使用Stub.asInterface接口获取服务器的Binder；
\item 通过Intent指定服务端的服务名称和所在包，进行Service绑定；
\item 根据需要调用服务提供的接口方法。
\item MainActivity.java
\end{itemize}
\begin{minted}[linenos=true]{java}
public class MainActivity extends AppCompatActivity {
    private Button bindService;
    // 定义aidl接口变量
    private AIDL_Service1 mAIDL_Service;
    // 创建ServiceConnection的匿名类
    private ServiceConnection connection = new ServiceConnection() {
        // 重写onServiceConnected()方法和onServiceDisconnected()方法
        // 在Activity与Service建立关联和解除关联的时候调用
        @Override
        public void onServiceDisconnected(ComponentName name) {
        }
        // 在Activity与Service建立关联时调用
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            // 使用AIDLService1.Stub.asInterface()方法获取服务器端返回的IBinder对象
            // 将IBinder对象传换成了mAIDL_Service接口对象
            mAIDL_Service = AIDL_Service1.Stub.asInterface(service);
            try {
                // 通过该对象调用在MyAIDLService.aidl文件中定义的接口方法,从而实现跨进程通信
                mAIDL_Service.AIDL_Service();
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        bindService = (Button) findViewById(R.id.bind_service);
        // 设置绑定服务的按钮
        bindService.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {

                // 通过Intent指定服务端的服务名称和所在包，与远程Service进行绑定
                // 参数与服务器端的action要一致,即"服务器包名.aidl接口文件名"
                Intent intent = new Intent("scut.carson_ho.service_server.AIDL_Service1");

                // Android5.0后无法只通过隐式Intent绑定远程Service
                // 需要通过setPackage()方法指定包名
                intent.setPackage("scut.carson_ho.service_server");

                // 绑定服务,传入intent和ServiceConnection对象
                bindService(intent, connection, Context.BIND_AUTO_CREATE);
            }
        });
    }
}
\end{minted}
\end{itemize}
\subsubsection{测试结果}
\label{sec-5-6-3}

\includegraphics[width=.9\linewidth]{./pic/serverClient.png}
\begin{itemize}
\item 从上面测试结果可以看出：
\begin{itemize}
\item 打印的语句分别运行在不同进程（看语句前面的包名）；
\item 客户端调用了服务端Service的方法
\end{itemize}
\item 即客户端和服务端进行了跨进程通信
\end{itemize}
\subsubsection{Demo地址}
\label{sec-5-6-4}
\begin{itemize}
\item 客户端：Github\_RemoteService\_Client
\item 服务端：Github\_RemoteService\_Server
\end{itemize}

\section{Android 屏幕适配：最全面的解决方案}
\label{sec-6}
\begin{itemize}
\item \url{https://www.jianshu.com/p/ec5a1a30694b}
\end{itemize}
\subsection{前言}
\label{sec-6-1}
\begin{itemize}
\item Android的屏幕适配一直以来都在折磨着我们Android开发者，本文将结合：
\begin{itemize}
\item Google的官方权威适配文档
\item 郭霖： Android官方提供的支持不同屏幕大小的全部方法 
\begin{itemize}
\item \url{https://blog.csdn.net/guolin_blog/article/details/8830286}
\end{itemize}
\item Stormzhang：Android 屏幕适配
\item 鸿洋：Android 屏幕适配方案
\begin{itemize}
\item \url{https://blog.csdn.net/lmj623565791/article/details/45460089}
\end{itemize}
\item 凯子： Android屏幕适配全攻略(最权威的官方适配指导)
\begin{itemize}
\item \url{https://blog.csdn.net/zhaokaiqiang1992/article/details/45419023}
\end{itemize}
\item 自身的思考\&实践
\end{itemize}
\item 给你带来一种全新、全面而逻辑清晰的Android屏幕适配思路，只要你认真阅读，保证你能解决Android的屏幕适配问题！
\end{itemize}
\subsection{目录}
\label{sec-6-2}

\begin{figure}[htb]
\centering
\includegraphics[width=.9\linewidth]{./pic/screenAdapter.png}
\caption{Android屏幕适配解决方案}
\end{figure}

\subsection{定义}
\label{sec-6-3}
\begin{itemize}
\item 使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果
\end{itemize}
\subsection{相关重要概念}
\label{sec-6-4}
\subsubsection{屏幕尺寸}
\label{sec-6-4-1}
\begin{itemize}
\item 含义：手机对角线的物理尺寸
\item 单位：英寸（inch），1英寸=2.54cm
\begin{itemize}
\item Android手机常见的尺寸有5寸、5.5寸、6寸等等
\end{itemize}
\end{itemize}
\subsubsection{屏幕分辨率}
\label{sec-6-4-2}
\begin{itemize}
\item 含义：手机在横向、纵向上的像素点数总和
\begin{itemize}
\item 一般描述成屏幕的"宽x高"=AxB
\item 含义：屏幕在横向方向（宽度）上有A个像素点，在纵向方向（高）有B个像素点
\item 例子：1080x1920，即宽度方向上有1080个像素点，在高度方向上有1920个像素点
\end{itemize}
\item 单位：px（pixel），1px=1像素点
\begin{itemize}
\item UI设计师的设计图会以px作为统一的计量单位
\end{itemize}
\item Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920
\end{itemize}
\subsubsection{屏幕像素密度}
\label{sec-6-4-3}
\begin{itemize}
\item 含义：每英寸的像素点数
\item 单位：dpi（dots per ich）
\begin{itemize}
\item 假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi
\end{itemize}
\item 安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度：
\end{itemize}
\begin{center}
\begin{tabular}{lrr}
\hline
密度类型 & 代表的分辨率（px） & 屏幕像素密度（dpi）\\
\hline
低密度（ldpi） & 240x320 & 120\\
中密度（mdpi） & 320x480 & 160\\
高密度（hdpi） & 480x800 & 240\\
超高密度（xhdpi） & 720x1280 & 320\\
超超高密度（xxhdpi） & 1080x1920 & 480\\
\hline
\end{tabular}
\end{center}
\begin{enumerate}
\item 屏幕尺寸、分辨率、像素密度三者关系
\label{sec-6-4-3-1}
\begin{itemize}
\item 一部手机的分辨率是宽x高，屏幕大小是以寸为单位，那么三者的关系是：

\includegraphics[width=.9\linewidth]{./pic/density2.png}

\item 假设一部手机的分辨率是1080x1920（px），屏幕大小是5寸，问密度是多少？

\includegraphics[width=.9\linewidth]{./pic/density3.png}
\end{itemize}
\end{enumerate}

\subsubsection{密度无关像素}
\label{sec-6-4-4}
\begin{itemize}
\item 含义：density-independent pixel，叫dp或dip，与终端上的实际物理像素点无关。
\item 单位：dp，可以保证在不同屏幕像素密度的设备上显示相同的效果
\begin{itemize}
\item Android开发时用dp而不是px单位设置图片大小，是Android特有的单位
\item 场景：假如同样都是画一条长度是屏幕一半的线，如果使用px作为计量单位，那么在480x800分辨率手机上设置应为240px；在320x480的手机上应设置为160px，二者设置就不同了；如果使用dp为单位，在这两种分辨率下，160dp都显示为屏幕一半的长度。
\end{itemize}
\item dp与px的转换
\begin{itemize}
\item 因为ui设计师给你的设计图是以px为单位的，Android开发则是使用dp作为单位的，那么我们需要进行转换：
\end{itemize}
\end{itemize}
\begin{center}
\begin{tabular}{lrrlr}
\hline
密度类型 & 代表的分辨率（px） & 屏幕密度（dpi） & 换算（px/dp） & 比例\\
\hline
低密度（ldpi） & 240x320 & 120 & 1dp=0.75px & 3\\
中密度（mdpi） & 320x480 & 160 & 1dp=1px & 4\\
高密度（hdpi） & 480x800 & 240 & 1dp=1.5px & 6\\
超高密度（xhdpi） & 720x1280 & 320 & 1dp=2px & 8\\
超超高密度（xxhdpi） & 1080x1920 & 480 & 1dp=3px & 12\\
\hline
\end{tabular}
\end{center}
\begin{itemize}
\item 在Android中，规定以160dpi（即屏幕分辨率为320x480）为基准：1dp=1px
\end{itemize}

\subsubsection{独立比例像素}
\label{sec-6-4-5}
\begin{itemize}
\item 含义：scale-independent pixel，叫sp或sip
\item 单位：sp
\begin{itemize}
\item Android开发时用此单位设置文字大小，可根据字体大小首选项进行缩放
\item 推荐使用12sp、14sp、18sp、22sp作为字体设置的大小，不推荐使用奇数和小数，容易造成精度的丢失问题；小于12sp的字体会太小导致用户看不清
\end{itemize}
\end{itemize}

\subsection{为什么要进行Android屏幕适配}
\label{sec-6-5}

由于Android系统的开放性，任何用户、开发者、OEM厂商、运营商都可以对Android进行定制，于是导致：
\begin{itemize}
\item Android系统碎片化：小米定制的MIUI、魅族定制的flyme、华为定制的EMUI等等
\begin{itemize}
\item 当然都是基于Google原生系统定制的
\end{itemize}
\item Android机型屏幕尺寸碎片化：5寸、5.5寸、6寸等等
\item Android屏幕分辨率碎片化：320x480、480x800、720x1280、1080x1920
\begin{itemize}
\item 据友盟指数显示，统计至2015年12月，支持Android的设备共有27796种
\end{itemize}
\item 当Android系统、屏幕尺寸、屏幕密度出现碎片化的时候，就很容易出现同一元素在不同手机上显示不同的问题。
\begin{itemize}
\item 试想一下这么一个场景：
\item 为4.3寸屏幕准备的UI设计图，运行在5.0寸的屏幕上，很可能在右侧和下侧存在大量的空白；而5.0寸的UI设计图运行到4.3寸的设备上，很可能显示不下。
\end{itemize}
\end{itemize}

为了保证用户获得一致的用户体验效果：
\begin{itemize}
\item 使得某一元素在Android不同尺寸、不同分辨率的手机上具备相同的显示效果
\item 于是，我们便需要对Android屏幕进行适配。
\end{itemize}

\subsection{屏幕适配问题的本质}
\label{sec-6-6}
\begin{itemize}
\item 使得"布局"、"布局组件"、"图片资源"、"用户界面流程"匹配不同的屏幕尺寸
\begin{itemize}
\item 使得布局、布局组件自适应屏幕尺寸；
\item 根据屏幕的配置来加载相应的UI布局、用户界面流程
\end{itemize}
\item 使得"图片资源"匹配不同的屏幕密度
\end{itemize}

\subsubsection{屏幕尺寸匹配}
\label{sec-6-6-1}

问题：如何进行屏幕尺寸匹配？

\begin{figure}[htb]
\centering
\includegraphics[width=.9\linewidth]{./pic/screenSize.png}
\caption{屏幕尺寸适配解决方案}
\end{figure}

\begin{enumerate}
\item "布局"匹配
\label{sec-6-6-1-1}
\begin{itemize}
\item \textbf{本质1：使得布局元素自适应屏幕尺寸}
\end{itemize}
\begin{enumerate}
\item 使用相对布局（RelativeLayout），禁用绝对布局（AbsoluteLayout）
\label{sec-6-6-1-1-1}

开发中，我们使用的布局一般有：
\begin{itemize}
\item 线性布局（Linearlayout）
\item 相对布局（RelativeLayout）
\item 帧布局（FrameLayout）
\item 绝对布局（AbsoluteLayout）
\begin{itemize}
\item 由于绝对布局（AbsoluteLayout）适配性极差，所以极少使用。
\end{itemize}
\end{itemize}

对于线性布局（Linearlayout）、相对布局（RelativeLayout）和帧布局（FrameLayout）需要根据需求进行选择，但要记住：
\begin{itemize}
\item RelativeLayout
\begin{itemize}
\item 布局的子控件之间使用相对位置的方式排列，因为RelativeLayout讲究的是相对位置，即使屏幕的大小改变，视图之前的相对位置都不会变化，与屏幕大小无关，灵活性很强
\end{itemize}
\item LinearLayout
\begin{itemize}
\item 通过多层嵌套LinearLayout和组合使
\item 用"wrap\_content"和"match\_parent"已经可以构建出足够复杂的布局。但是LinearLayout无法准确地控制子视图之间的位置关系，只能简单的一个挨着一个地排列
\end{itemize}
\end{itemize}

所以，对于屏幕适配来说，使用相对布局（RelativeLayout）将会是更好的解决方案

\begin{itemize}
\item \textbf{本质2：根据屏幕的配置来加载相应的UI布局}
\begin{itemize}
\item 应用场景：需要为不同屏幕尺寸的设备设计不同的布局
\end{itemize}
\end{itemize}
\item 使用限定符
\label{sec-6-6-1-1-2}
\begin{itemize}
\item 作用：通过配置限定符使得程序在运行时根据当前设备的配置（屏幕尺寸）自动加载合适的布局资源
\end{itemize}

限定符类型：
\begin{itemize}
\item 尺寸（size）限定符
\item 最小宽度（Smallest-width）限定符
\item 布局别名
\item 屏幕方向（Orientation）限定符
\end{itemize}

\begin{enumerate}
\item 尺寸（size）限定符
\label{sec-6-6-1-1-2-1}

使用场景：当一款应用显示的内容较多，希望进行以下设置：
\begin{itemize}
\item 在平板电脑和电视的屏幕（>7英寸）上：实施"双面板"模式以同时显示更多内容
\item 在手机较小的屏幕上：使用单面板分别显示内容
\end{itemize}

因此，我们可以使用尺寸限定符（layout-large）通过创建一个文件

\begin{minted}[linenos=true]{xml}
res/layout-large/main.xml
\end{minted}

来完成上述设定：
\begin{itemize}
\item 让系统在屏幕尺寸>7英寸时采用适配平板的双面板布局
\item 反之（默认情况下）采用适配手机的单面板布局
\end{itemize}

文件配置如下：
\begin{itemize}
\item 适配手机的单面板（默认）布局：res/layout/main.xml
\begin{minted}[linenos=true]{xml}
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
      android:orientation="vertical"
      android:layout_width="match_parent"
      android:layout_height="match_parent">
      <fragment android:id="@+id/headlines"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.HeadlinesFragment"
          android:layout_width="match_parent"
      />
</LinearLayout>
\end{minted}
\item 适配尺寸>7寸平板的双面板布局：：res/layout-large/main.xml
\begin{minted}[linenos=true]{xml}
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="horizontal">
    <fragment android:id="@+id/headlines"
        android:layout_height="fill_parent"
        android:name="com.example.android.newsreader.HeadlinesFragment"
        android:layout_width="400dp"
        android:layout_marginRight="10dp"
    />
    <fragment android:id="@+id/article"
        android:layout_height="fill_parent"
        android:name="com.example.android.newsreader.ArticleFragment"
        android:layout_width="fill_parent"
    />
</LinearLayout>
\end{minted}
\end{itemize}

请注意：
\begin{itemize}
\item 两个布局名称均为main.xml，只有布局的目录名不同：第一个布局的目录名为：layout，第二个布局的目录名为：layout-large，包含了尺寸限定符（large）
\item 被定义为大屏的设备(7寸以上的平板)会自动加载包含了large限定符目录的布局，而小屏设备会加载另一个默认的布局
\end{itemize}

\textbf{但要注意的是，这种方式只适合Android 3.2版本之前。}

\item 最小宽度（Smallest-width）限定符
\label{sec-6-6-1-1-2-2}
\begin{itemize}
\item 背景：上述提到的限定符"large"具体是指多大呢？似乎没有一个定量的指标，这便意味着可能没办法准确地根据当前设备的配置（屏幕尺寸）自动加载合适的布局资源
\item 例子：比如说large同时包含着5寸和7寸，这意味着使用"large"限定符的话我没办法实现为5寸和7寸的平板电脑分别加载不同的布局
\end{itemize}

于是，在Android 3.2及之后版本，引入了最小宽度（Smallest-width）限定符
\begin{itemize}
\item 定义：通过指定某个最小宽度（以 dp 为单位）来精确定位屏幕从而加载不同的UI资源
\item 使用场景:
\begin{itemize}
\item 你需要为标准 7 英寸平板电脑匹配双面板布局（其最小宽度为 600 dp），在手机（较小的屏幕上）匹配单面板布局
\end{itemize}
\item 解决方案：
\begin{itemize}
\item 您可以使用上文中所述的单面板和双面板这两种布局，但您应使用 sw600dp 指明双面板布局仅适用于最小宽度为 600 dp 的屏幕，而不是使用 large 尺寸限定符。
\begin{itemize}
\item sw xxxdp，即small width的缩写，其不区分方向，即无论是宽度还是高度，只要大于 xxxdp，就采用次此布局
\end{itemize}
\end{itemize}
\item 例子：
\begin{itemize}
\item 使用了layout-sw 600dp的最小宽度限定符，即无论是宽度还是高度，只要大于600dp，就采用layout-sw 600dp目录下的布局
\end{itemize}
\end{itemize}

代码展示：
\begin{itemize}
\item 适配手机的单面板（默认）布局：res/layout/main.xml
\begin{minted}[linenos=true]{xml}
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <fragment android:id="@+id/headlines"
        android:layout_height="fill_parent"
        android:name="com.example.android.newsreader.HeadlinesFragment"
        android:layout_width="match_parent" />
</LinearLayout>
\end{minted}
\item 适配尺寸>7寸平板的双面板布局：res/layout-sw600dp/main.xml
\begin{minted}[linenos=true]{xml}
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="horizontal">
    <fragment android:id="@+id/headlines"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.HeadlinesFragment"
          android:layout_width="400dp"
          android:layout_marginRight="10dp"/>
    <fragment android:id="@+id/article"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.ArticleFragment"
          android:layout_width="fill_parent" />
</LinearLayout>
\end{minted}
\item 对于最小宽度≥ 600 dp 的设备
\begin{itemize}
\item 系统会自动加载 layout-sw600dp/main.xml（双面板）布局，否则系统就会选择 layout/main.xml（单面板）布局
\item （这个选择过程是Android系统自动选择的）
\end{itemize}
\end{itemize}
\item 使用布局别名
\label{sec-6-6-1-1-2-3}

\textbf{设想这么一个场景}

当你需要同时为Android 3.2版本前和Android 3.2版本后的手机进行屏幕尺寸适配的时候，由于尺寸限定符仅用于Android 3.2版本前，最小宽度限定符仅用于Android 3.2版本后，所以这会带来一个问题，为了很好地进行屏幕尺寸的适配，你需要同时维护layout-sw600dp和layout-large的两套main.xml平板布局，如下：
\begin{itemize}
\item 适配手机的单面板（默认）布局：res/layout/main.xml
\item 适配尺寸>7寸平板的双面板布局（Android 3.2前）：res/layout-large/main.xml
\item 适配尺寸>7寸平板的双面板布局（Android 3.2后）res/layout-sw600dp/main.xml
\end{itemize}

最后的两个文件的xml内容是完全相同的，这会带来：文件名的重复从而带来一些列后期维护的问题

\textbf{于是为了要解决这种重复问题，我们引入了--布局别名} 

还是上面的例子，你可以定义以下布局：
\begin{itemize}
\item 适配手机的单面板（默认）布局：res/layout/main.xml
\item 适配尺寸>7寸平板的双面板布局：res/layout/main\_twopanes.xml
\end{itemize}

然后加入以下两个文件，以便进行Android 3.2前和Android 3.2后的版本双面板布局适配：
\begin{itemize}
\item res/values-large/layout.xml（Android 3.2之前的双面板布局）
\begin{minted}[linenos=true]{xml}
<resources>
    <item name="main" type="layout">@layout/main_twopanes</item>
</resources>
\end{minted}
\item res/values-sw600dp/layout.xml（Android 3.2及之后的双面板布局）
\begin{minted}[linenos=true]{xml}
<resources>
    <item name="main" type="layout">@layout/main_twopanes</item>
</resources>
\end{minted}
\end{itemize}

注：
\begin{itemize}
\item 最后两个文件有着相同的内容，但是它们并没有真正去定义布局，它们仅仅只是将main设置成了@layout/main\_twopanes的别名
\item 由于这些文件包含 large 和 sw600dp 选择器，因此，系统会将此文件匹配到不同版本的>7寸平板上：
\begin{itemize}
\item a. 版本低于 3.2 的平板会匹配 large的文件
\item b. 版本高于 3.2 的平板会匹配 sw600dp的文件
\end{itemize}
\end{itemize}

这样两个layout.xml都只是引用了@layout/main\_twopanes，就避免了重复定义布局文件的情况

\item 屏幕方向（Orientation）限定符
\label{sec-6-6-1-1-2-4}
\begin{itemize}
\item 使用场景：根据屏幕方向进行布局的调整
\item 取以下为例子：
\begin{itemize}
\item 小屏幕, 竖屏: 单面板
\item 小屏幕, 横屏: 单面板
\item 7 英寸平板电脑，纵向：单面板，带操作栏
\item 7 英寸平板电脑，横向：双面板，宽，带操作栏
\item 10 英寸平板电脑，纵向：双面板，窄，带操作栏
\item 10 英寸平板电脑，横向：双面板，宽，带操作栏
\item 电视，横向：双面板，宽，带操作栏
\end{itemize}
\item 方法是
\begin{itemize}
\item 先定义类别：单/双面板、是否带操作栏、宽/窄
\begin{itemize}
\item 定义在 res/layout/ 目录下的某个 XML 文件中
\end{itemize}
\item 再进行相应的匹配：屏幕尺寸（小屏、7寸、10寸）、方向（横、纵）
\begin{itemize}
\item 使用布局别名进行匹配
\end{itemize}
\end{itemize}
\item \textbf{在 res/layout/ 目录下的某个 XML 文件中定义所需要的布局类别}
\begin{itemize}
\item （单/双面板、是否带操作栏、宽/窄）
\item res/layout/onepane.xml:(单面板)
\end{itemize}
\begin{minted}[linenos=true]{xml}
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
    android:orientation="vertical"  
    android:layout_width="match_parent"  
    android:layout_height="match_parent">  
    <fragment android:id="@+id/headlines"  
          android:layout_height="fill_parent"  
          android:name="com.example.android.newsreader.HeadlinesFragment"  
          android:layout_width="match_parent" />  
</LinearLayout>
\end{minted}
\begin{itemize}
\item res/layout/onepane\_with\_bar.xml:(单面板带操作栏)
\end{itemize}
\begin{minted}[linenos=true]{xml}
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"  
    android:orientation="vertical"  
    android:layout_width="match_parent"  
    android:layout_height="match_parent">  
    <LinearLayout android:layout_width="match_parent"   
          android:id="@+id/linearLayout1"    
          android:gravity="center"  
          android:layout_height="50dp">  
        <ImageView android:id="@+id/imageView1"   
               android:layout_height="wrap_content"  
               android:layout_width="wrap_content"  
               android:src="@drawable/logo"  
               android:paddingRight="30dp"  
               android:layout_gravity="left"  
               android:layout_weight="0" />  
        <View android:layout_height="wrap_content"   
              android:id="@+id/view1"  
              android:layout_width="wrap_content"  
              android:layout_weight="1" />  
        <Button android:id="@+id/categorybutton"  
            android:background="@drawable/button_bg"  
            android:layout_height="match_parent"  
            android:layout_weight="0"  
            android:layout_width="120dp"  
            style="@style/CategoryButtonStyle"/>  
    </LinearLayout>  
    <fragment android:id="@+id/headlines"   
          android:layout_height="fill_parent"  
          android:name="com.example.android.newsreader.HeadlinesFragment"  
          android:layout_width="match_parent" 
    />  
</LinearLayout>
\end{minted}
\begin{itemize}
\item res/layout/twopanes.xml:(双面板，宽布局)
\end{itemize}
\begin{minted}[linenos=true]{xml}
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="horizontal">
    <fragment android:id="@+id/headlines"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.HeadlinesFragment"
          android:layout_width="400dp"
          android:layout_marginRight="10dp"/>
    <fragment android:id="@+id/article"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.ArticleFragment"
          android:layout_width="fill_parent" />
</LinearLayout>
\end{minted}
\begin{itemize}
\item res/layout/twopanes\_narrow.xml:(双面板，窄布局)
\end{itemize}
\begin{minted}[linenos=true]{xml}
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="horizontal">
    <fragment android:id="@+id/headlines"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.HeadlinesFragment"
          android:layout_width="200dp"
          android:layout_marginRight="10dp"/>
    <fragment android:id="@+id/article"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.ArticleFragment"
          android:layout_width="fill_parent" />
</LinearLayout>
\end{minted}
\item \textbf{使用布局别名进行相应的匹配}
\begin{itemize}
\item (屏幕尺寸（小屏、7寸、10寸）、方向（横、纵）)
\item res/values/layouts.xml:（默认布局）
\end{itemize}
\begin{minted}[linenos=true]{xml}
<resources>  
    <item name="main_layout" type="layout">@layout/onepane_with_bar</item>  
    <bool name="has_two_panes">false</bool>  
</resources>
\end{minted}
\begin{itemize}
\item 可为resources设置bool，通过获取其值来动态判断目前已处在哪个适配布局
\item res/values-sw600dp-land/layouts.xml
\begin{itemize}
\item （大屏、横向、双面板、宽-Andorid 3.2版本后）
\end{itemize}
\end{itemize}
\begin{minted}[linenos=true]{xml}
<resources>
    <item name="main_layout" type="layout">@layout/twopanes</item>
    <bool name="has_two_panes">true</bool>
</resources>
\end{minted}
\begin{itemize}
\item res/values-sw600dp-port/layouts.xml
\begin{itemize}
\item （大屏、纵向、单面板带操作栏-Andorid 3.2版本后）
\end{itemize}
\end{itemize}
\begin{minted}[linenos=true]{xml}
<resources>
    <item name="main_layout" type="layout">@layout/onepane</item>
    <bool name="has_two_panes">false</bool>
</resources>
\end{minted}
\begin{itemize}
\item res/values-large-land/layouts.xml
\begin{itemize}
\item （大屏、横向、双面板、宽-Andorid 3.2版本前）
\end{itemize}
\end{itemize}
\begin{minted}[linenos=true]{xml}
<resources>
    <item name="main_layout" type="layout">@layout/twopanes</item>
    <bool name="has_two_panes">true</bool>
</resources>
\end{minted}
\begin{itemize}
\item res/values-large-port/layouts.xml
\begin{itemize}
\item （大屏、纵向、单面板带操作栏-Andorid 3.2版本前）
\end{itemize}
\end{itemize}
\begin{minted}[linenos=true]{xml}
<resources>
    <item name="main_layout" type="layout">@layout/onepane</item>
    <bool name="has_two_panes">false</bool>
</resources>
\end{minted}
\begin{itemize}
\item 这里没有完全把全部尺寸匹配类型的代码贴出来，大家可以自己去尝试把其补充完整
\end{itemize}
\end{itemize}
\end{enumerate}
\end{enumerate}

\item "布局组件"匹配
\label{sec-6-6-1-2}

\textbf{本质：使得布局组件自适应屏幕尺寸}
\begin{itemize}
\item 做法: 使用"wrap\_content"、"match\_parent"和"weight"来控制视图组件的宽度和高度
\begin{itemize}
\item "wrap\_content"
\begin{itemize}
\item 相应视图的宽和高就会被设定成所需的最小尺寸以适应视图中的内容
\end{itemize}
\item "match\_parent"(在Android API 8之前叫作"fill\_parent")
\begin{itemize}
\item 视图的宽和高延伸至充满整个父布局
\end{itemize}
\item "weight"
\begin{itemize}
\item 1.定义：是线性布局（Linelayout）的一个独特比例分配属性
\item 2.作用：使用此属性设置权重，然后按照比例对界面进行空间的分配，公式计算是：控件宽度=控件设置宽度+剩余空间所占百分比宽幅
\item 具体可以参考这篇文章，讲解得非常详细 \url{http://mobile.51cto.com/abased-375428.htm}
\end{itemize}
\end{itemize}
\end{itemize}

通过使用"wrap\_content"、"match\_parent"和"weight"来替代硬编码的方式定义视图大小\&位置，你的视图要么仅仅使用了需要的那边一点空间，要么就会充满所有可用的空间，即按需占据空间大小，能让你的布局元素充分适应你的屏幕尺寸

\item "图片资源"匹配
\label{sec-6-6-1-3}

\textbf{本质：使得图片资源在不同屏幕密度上显示相同的像素效果}
\begin{itemize}
\item 做法： \textbf{使用自动拉伸位图：Nine-Patch的图片类型}
\begin{itemize}
\item 假设需要匹配不同屏幕大小，你的图片资源也必须自动适应各种屏幕尺寸
\begin{itemize}
\item 使用场景：一个按钮的背景图片必须能够随着按钮大小的改变而改变。
\item 使用普通的图片将无法实现上述功能,因为运行时会均匀地拉伸或压缩你的图片
\end{itemize}
\end{itemize}
\item 解决方案：使用自动拉伸位图（nine-patch图片），后缀名是.9.png，它是一种被特殊处理过的PNG图片，设计时可以指定图片的拉伸区域和非拉伸区域；使用时，系统就会根据控件的大小自动地拉伸你想要拉伸的部分
\begin{itemize}
\item 1.必须要使用.9.png后缀名，因为系统就是根据这个来区别nine-patch图片和普通的PNG图片的；
\item 2.当你需要在一个控件中使用nine-patch图片时,如
\end{itemize}
\begin{minted}[linenos=true]{xml}
android:background="@drawable/button"
\end{minted}
\end{itemize}

系统就会根据控件的大小自动地拉伸你想要拉伸的部分

\item "用户界面流程"匹配
\label{sec-6-6-1-4}
\begin{itemize}
\item 使用场景：我们会根据设备特点显示恰当的布局，但是这样做，会使得用户界面流程可能会有所不同。
\item 例如，如果应用处于双面板模式下，点击左侧面板上的项即可直接在右侧面板上显示相关内容；而如果该应用处于单面板模式下，点击相关的内容应该跳转到另外一个Activity进行后续的处理。
\end{itemize}

\textbf{本质：根据屏幕的配置来加载相应的用户界面流程}
\begin{itemize}
\item 做法:进行用户界面流程的自适应配置：
\begin{itemize}
\item 确定当前布局
\item 根据当前布局做出响应
\item 重复使用其他活动中的片段
\item 处理屏幕配置变化
\end{itemize}
\item 步骤1：确定当前布局
\begin{itemize}
\item 由于每种布局的实施都会稍有不同，因此我们需要先确定当前向用户显示的布局。例如，我们可以先了解用户所处的是"单面板"模式还是"双面板"模式。要做到这一点，可以通过查询指定视图是否存在以及是否已显示出来。
\end{itemize}
\begin{minted}[linenos=true]{java}
public class NewsReaderActivity extends FragmentActivity {
    boolean mIsDualPane;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main_layout);
        View articleView = findViewById(R.id.article);
        mIsDualPane = articleView != null &&
                        articleView.getVisibility() == View.VISIBLE;
    }
}
\end{minted}
\begin{itemize}
\item 这段代码用于查询"报道"面板是否可用，与针对具体布局的硬编码查询相比，这段代码的灵活性要大得多。
\end{itemize}
\item 步骤2：根据当前布局做出响应
\begin{itemize}
\item 有些操作可能会因当前的具体布局而产生不同的结果。
\item 例如，在新闻阅读器示例中，如果用户界面处于双面板模式下，那么点击标题列表中的标题就会在右侧面板中打开相应报道；但如果用户界面处于单面板模式下，那么上述操作就会启动一个独立活动：
\end{itemize}
\begin{minted}[linenos=true]{java}
@Override
public void onHeadlineSelected(int index) {
    mArtIndex = index;
    if (mIsDualPane) {
        /* display article on the right pane */
        mArticleFragment.displayArticle(mCurrentCat.getArticle(index));
    } else {
        /* start a separate activity */
        Intent intent = new Intent(this, ArticleActivity.class);
        intent.putExtra("catIndex", mCatIndex);
        intent.putExtra("artIndex", index);
        startActivity(intent);
    }
}
\end{minted}
\item 步骤3：重复使用其他活动中的片段
\begin{itemize}
\item 多屏幕设计中的重复模式是指，对于某些屏幕配置，已实施界面的一部分会用作面板；但对于其他配置，这部分就会以独立活动的形式存在。
\begin{itemize}
\item 例如，在新闻阅读器示例中，对于较大的屏幕，新闻报道文本会显示在右侧面板中；但对于较小的屏幕，这些文本就会以独立活动的形式存在。
\end{itemize}
\item 在类似情况下，通常可以在多个活动中重复使用相同的 Fragment 子类以避免代码重复。例如，在双面板布局中使用了 ArticleFragment：
\end{itemize}
\begin{minted}[linenos=true]{xml}
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="horizontal">
    <fragment android:id="@+id/headlines"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.HeadlinesFragment"
          android:layout_width="400dp"
          android:layout_marginRight="10dp"/>
    <fragment android:id="@+id/article"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.ArticleFragment"
          android:layout_width="fill_parent" />
</LinearLayout>
\end{minted}
\begin{itemize}
\item 然后又在小屏幕的Activity布局中重复使用了它 ：
\end{itemize}
\begin{minted}[linenos=true]{java}
ArticleFragment frag = new ArticleFragment();
getSupportFragmentManager().beginTransaction().
    add(android.R.id.content, frag).commit();
\end{minted}
\item 步骤4：处理屏幕配置变化
\begin{itemize}
\item 如果我们使用独立Activity实施界面的独立部分，那么请注意，我们可能需要对特定配置变化（例如屏幕方向的变化）做出响应，以便保持界面的一致性。
\begin{itemize}
\item 例如，在运行 Android 3.0 或更高版本的标准 7 英寸平板电脑上，如果新闻阅读器示例应用运行在纵向模式下，就会在使用独立活动显示新闻报道；但如果该应用运行在横向模式下，就会使用双面板布局。
\end{itemize}
\item 也就是说，如果用户处于纵向模式下且屏幕上显示的是用于阅读报道的活动，那么就需要在检测到屏幕方向变化（变成横向模式）后执行相应操作，即停止上述活动并返回主活动，以便在双面板布局中显示相关内容：
\end{itemize}
\begin{minted}[linenos=true]{java}
public class ArticleActivity extends FragmentActivity {
    int mCatIndex, mArtIndex;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mCatIndex = getIntent().getExtras().getInt("catIndex", 0);
        mArtIndex = getIntent().getExtras().getInt("artIndex", 0);
        // If should be in two-pane mode, finish to return to main activity
        if (getResources().getBoolean(R.bool.has_two_panes)) {
            finish();
            return;
        }
        ...
}
\end{minted}
\end{itemize}

通过上面一系列步骤，我们就完全可以建立一个可以根据用户界面配置进行自适应的应用程序App了。
\end{enumerate}

\subsubsection{屏幕密度匹配}
\label{sec-6-6-2}

问题：如何进行屏幕密度匹配？

\begin{figure}[htb]
\centering
\includegraphics[width=.9\linewidth]{./pic/density.png}
\caption{屏幕密度匹配解决方案}
\end{figure}

\begin{enumerate}
\item "布局控件"匹配
\label{sec-6-6-2-1}

\textbf{本质：使得布局组件在不同屏幕密度上显示相同的像素效果}
\begin{enumerate}
\item 使用密度无关像素作为计量单位
\label{sec-6-6-2-1-1}
\begin{itemize}
\item 由于各种屏幕的像素密度都有所不同，因此相同数量的像素在不同设备上的实际大小也有所差异，这样使用像素（px）定义布局尺寸就会产生问题。
\item 因此，请务必使用密度无关像素 dp 或**独立比例像素 sp **单位指定尺寸。
\end{itemize}

\textbf{密度无关像素}
\begin{itemize}
\item 含义：density-independent pixel，叫dp或dip，与终端上的实际物理像素点无关。
\item 单位：dp，可以保证在不同屏幕像素密度的设备上显示相同的效果
\begin{itemize}
\item Android开发时用dp而不是px单位设置图片大小，是Android特有的单位
\item 场景：假如同样都是画一条长度是屏幕一半的线，如果使用px作为计量单位，那么在480x800分辨率手机上设置应为240px；在320x480的手机上应设置为160px，二者设置就不同了；如果使用dp为单位，在这两种分辨率下，160dp都显示为屏幕一半的长度。
\end{itemize}
\item dp与px的转换
\begin{itemize}
\item 因为ui给你的设计图是以px为单位的，Android开发则是使用dp作为单位的，那么该如何转换呢？
\end{itemize}
\end{itemize}
\begin{center}
\begin{tabular}{lrrlr}
\hline
密度类型 & 代表的分辨率（px） & 屏幕密度（dpi） & 换算（px/dp） & 比例\\
\hline
低密度（ldpi） & 240x320 & 120 & 1dp=0.75px & 3\\
中密度（mdpi） & 320x480 & 160 & 1dp=1px & 4\\
高密度（hdpi） & 480x800 & 240 & 1dp=1.5px & 6\\
超高密度（xhdpi） & 720x1280 & 320 & 1dp=2px & 8\\
超超高密度（xxhdpi） & 1080x1920 & 480 & 1dp=3px & 12\\
\hline
\end{tabular}
\end{center}

在Android中，规定以160dpi（即屏幕分辨率为320x480）为基准：1dp=1px

\textbf{独立比例像素}
\begin{itemize}
\item 含义：scale-independent pixel，叫sp或sip
\item 单位：sp
\begin{itemize}
\item Android开发时用此单位设置文字大小，可根据用户的偏好文字大小/字体大小首选项进行缩放
\item 推荐使用12sp、14sp、18sp、22sp作为字体设置的大小，不推荐使用奇数和小数，容易造成精度的丢失问题；小于12sp的字体会太小导致用户看不清
\end{itemize}
\end{itemize}

所以，为了能够进行不同屏幕像素密度的匹配，我们推荐：
\begin{itemize}
\item 使用dp来代替px作为控件长度的统一度量单位
\item 使用sp作为文字的统一度量单位
\end{itemize}

可是，请看以下一种场景：
\begin{itemize}
\item Nexus5的总宽度为360dp，我们现在在水平方向上放置两个按钮，一个是150dp左对齐，另外一个是200dp右对齐，那么中间留有10dp间隔；但假如同样地设置在Nexus S（屏幕宽度是320dp），会发现，两个按钮会重叠，因为320dp<200+150dp
\end{itemize}

从上面可以看出，由于Android屏幕设备的多样性，如果使用dp来作为度量单位，并不是所有的屏幕的宽度都具备相同的dp长度
\begin{itemize}
\item 再次明确， \textbf{屏幕宽度和像素密度没有任何关联关系}
\end{itemize}

所以说，dp解决了同一数值在不同分辨率中展示相同尺寸大小的问题（即屏幕像素密度匹配问题），但却没有解决设备尺寸大小匹配的问题。（即屏幕尺寸匹配问题）
\begin{itemize}
\item 当然，我们一开始讨论的就是屏幕尺寸匹配问题，使用match\_parent、wrap\_content和weight，尽可能少用dp来指定控件的具体长宽，大部分的情况我们都是可以做到适配的。
\end{itemize}

\textbf{那么该如何解决控件的屏幕尺寸和屏幕密度的适配问题呢？}

从上面可以看出：
\begin{itemize}
\item 因为屏幕密度（分辨率）不一样，所以不能用固定的px
\item 因为屏幕宽度不一样，所以要小心的用dp
\end{itemize}

因为本质上是希望使得布局组件在不同屏幕密度上显示相同的像素效果，那么，之前是绕了个弯使用dp解决这个问题，那么到底能不能直接用px解决呢？
\begin{itemize}
\item 即根据不同屏幕密度，控件选择对应的像素值大小
\end{itemize}

\item 百分比适配方法
\label{sec-6-6-2-1-2}
\begin{itemize}
\item 以某一分辨率为基准，生成所有分辨率对应像素数列表
\item 将生成像素数列表存放在res目录下对应的values文件下
\item 根据UI设计师给出设计图上的尺寸，找到对应像素数的单位，然后设置给控件即可
\end{itemize}

\begin{enumerate}
\item 步骤1：以某一分辨率为基准，生成所有分辨率对应像素数列表
\label{sec-6-6-2-1-2-1}

现在我们以320x480的分辨率为基准：
\begin{itemize}
\item 将屏幕的宽度分为320份，取值为x1\textasciitilde{}x320
\item 将屏幕的高度分为480份，取值为y1\textasciitilde{}y480
\end{itemize}

然后生成该分辨率对应像素数的列表，如下图：
\begin{itemize}
\item lay\_x.xml（宽）
\begin{minted}[linenos=true]{xml}
<?xml version="1.0" encoding="utf-8"?>
<resources><dimen name="x1">1.0px</dimen>
    <dimen name="x2">2.0px</dimen>
    <dimen name="x3">3.0px</dimen>
    <dimen name="x4">4.0px</dimen>
    <dimen name="x5">5.0px</dimen>
    <dimen name="x6">6.0px</dimen>
    <dimen name="x7">7.0px</dimen>
    <dimen name="x8">8.0px</dimen>
    <dimen name="x9">9.0px</dimen>
    <dimen name="x10">10.0px</dimen>
    ...
    <dimen name="x300">300.0px</dimen>
    <dimen name="x301">301.0px</dimen>
    <dimen name="x302">302.0px</dimen>
    <dimen name="x303">303.0px</dimen>
    <dimen name="x304">304.0px</dimen>
    <dimen name="x305">305.0px</dimen>
    <dimen name="x306">306.0px</dimen>
    <dimen name="x307">307.0px</dimen>
    <dimen name="x308">308.0px</dimen>
    <dimen name="x309">309.0px</dimen>
    <dimen name="x310">310.0px</dimen>
    <dimen name="x311">311.0px</dimen>
    <dimen name="x312">312.0px</dimen>
    <dimen name="x313">313.0px</dimen>
    <dimen name="x314">314.0px</dimen>
    <dimen name="x315">315.0px</dimen>
    <dimen name="x316">316.0px</dimen>
    <dimen name="x317">317.0px</dimen>
    <dimen name="x318">318.0px</dimen>
    <dimen name="x319">319.0px</dimen>
    <dimen name="x320">320px</dimen>
</resources>
\end{minted}
\item lay\_y.xml（高）
\begin{minted}[linenos=true]{xml}
<?xml version="1.0" encoding="utf-8"?>
<resources><dimen name="y1">1.0px</dimen>
    <dimen name="y2">2.0px</dimen>
    <dimen name="y3">3.0px</dimen>
    <dimen name="y4">4.0px</dimen>
    ...
    <dimen name="y480">480px</dimen>
</resources>
\end{minted}
\end{itemize}

找到基准后，是时候把其他分辨率补全了，现今以写1080x1920的分辨率为例：
\begin{itemize}
\item 因为基准是320x480，所以1080/320=3.375px，1920/480=4px，所以相应文件应该是
\begin{itemize}
\item lay\_x.xml
\end{itemize}
\begin{minted}[linenos=true]{xml}
<?xml version="1.0" encoding="utf-8"?>
<resources><dimen name="x1">3.375px</dimen>
    <dimen name="x2">6.65px</dimen>
    <dimen name="x3">10.125px</dimen>
    ...
    <dimen name="x320">1080px</dimen>
</resources>
\end{minted}
\begin{itemize}
\item lay\_y.xml
\end{itemize}
\begin{minted}[linenos=true]{xml}
<?xml version="1.0" encoding="utf-8"?>
<resources><dimen name="y1">4px</dimen>
    <dimen name="y2">8px</dimen>
    <dimen name="y3">12px</dimen>
    <dimen name="y4">16px</dimen>
    ...
    <dimen name="y480">1920px</dimen>
</resources>
\end{minted}
\end{itemize}

用上面的方法把你需要适配的分辨率的像素列表补全吧\textasciitilde{}

作为程序猿的我们当然不会做手写的这些蠢事！！！多谢 @鸿洋大神 提供了自动生成工具（内置了常用的分辨率），大家可以直接点击这里下载

注：工具默认基准为400*320，当然对于特殊需求，通过命令行指定即可：

\begin{minted}[linenos=true]{xml}
java -jar 文件名.jar 基准宽 基准高 额外支持尺寸1的宽，额外支持尺寸1的高_额外支持尺寸2的宽,额外支持尺寸2的高：
\end{minted}

例如：需要设置的基准是800x1280，额外支持尺寸：735x1152 ；3200x4500；

\begin{minted}[linenos=true]{xml}
java -jar 文件名.jar 800 1280 735，1152_3200,4500
\end{minted}

\item 步骤2：把生成的各像素数列表放到对应的资源文件
\label{sec-6-6-2-1-2-2}

将生成像素数列表（lay\_x.xml和lay\_y.xml）存放在res目录下对应的values文件（注意宽、高要对应），如下图：

\begin{figure}[htb]
\centering
\includegraphics[width=.9\linewidth]{./pic/res.png}
\caption{res目录下对应的values文件}
\end{figure}

注：
\begin{itemize}
\item 分辨率为480x320的资源文件应放在res/values-480x320文件夹中；同理分辨率为1920x1080的资源文件应放在res/values-1920x1080文件夹中。（其中values-480x320是分辨率限定符）
\item 必须在默认values里面也创建对应默认lay\_x.xml和lay\_y.xml文件，如下图
\begin{itemize}
\item lay\_x.xml
\end{itemize}
\begin{minted}[linenos=true]{xml}
<?xml version="1.0" encoding="utf-8">
<resources>
    <dimen name="x1">1.0dp</dimen>
    <dimen name="x2">2.0dp</dimen>
    ...
</resources>
\end{minted}
\item 因为对于没有生成对应分辨率文件的手机，会使用默认values文件夹，如果默认values文件夹没有（即没有对应的分辨率、没有对应dimen）就会报错，从而无法进行屏幕适配。
\begin{itemize}
\item （注意对应单位改为dp，而不同于上面的px。因为不知道机型的分辨率，所以默认分辨率文件只好默认为x1=1dp以保证尽量兼容（又回到dp老方法了），这也是这个解决方案的一个弊端）
\end{itemize}
\end{itemize}

\item 步骤3：根据UI设计师给出某一分辨率设计图上的尺寸，找到对应像素数的单位，然后设置给控件即可
\label{sec-6-6-2-1-2-3}

如下图：
\begin{minted}[linenos=true]{xml}
<FrameLayout >
    <Button
        android:layout_gravity="center"
        android:gravity="center"
        android:text="@string/hello_world"
        android:layout_width="@dimen/x160"
        android:layout_height="@dimen/y160"/>
</FrameLayout>
\end{minted}

使用上述的适配方式，应该能进行90\%的适配了，但其缺点还是很明显：
\begin{itemize}
\item 由于实际上还是使用px作为长度的度量单位，所以和google的要求使用dp作为度量单位会有所背离
\item 必须尽可能多的包含所有分辨率，因为这个是使用这个方案的基础，如果有某个分辨率缺少，将无法完成该屏幕的适配
\item 过多的分辨率像素描述xml文件会增加软件包的大小和维护的难度
\end{itemize}
\end{enumerate}
\end{enumerate}

\item "图片资源"匹配
\label{sec-6-6-2-2}
\textbf{本质：使得图片资源在不同屏幕密度上显示相同的像素效果}

\begin{itemize}
\item 做法：提供备用位图（符合屏幕尺寸的图片资源）
\begin{itemize}
\item 由于 Android 可在各种屏幕密度的设备上运行，因此我们提供的位图资源应该始终可以满足各类密度的要求：
\end{itemize}
\end{itemize}
\begin{center}
\begin{tabular}{lrr}
\hline
密度类型 & 代表的分辨率（px） & 系统密度（dpi）\\
\hline
低密度（ldpi） & 240x320 & 120\\
中密度（mdpi） & 320x480 & 160\\
高密度（hdpi） & 480x800 & 240\\
超高密度（xhdpi） & 720x1280 & 320\\
超超高密度（xxhdpi） & 1080x1920 & 480\\
\hline
\end{tabular}
\end{center}
\begin{itemize}
\item 步骤1：根据以下尺寸范围针对各密度生成相应的图片。
\begin{itemize}
\item 比如说，如果我们为 xhdpi 设备生成了 200x200 px尺寸的图片，就应该按照相应比例地为 hdpi、mdpi 和 ldpi 设备分别生成 150x150、100x100 和 75x75 尺寸的图片
\end{itemize}
\end{itemize}

\textbf{即一套分辨率=一套位图资源} （这个当然是Ui设计师做了）
\begin{itemize}
\item 步骤2：将生成的图片文件放在 res/ 下的相应子目录中(mdpi、hdpi、xhdpi、xxhdpi)，系统就会根据运行您应用的设备的屏幕密度自动选择合适的图片
\item 步骤3：通过引用 @drawable/id，系统都能根据相应屏幕的 屏幕密度（dpi）自动选取合适的位图。
\end{itemize}

注：
\begin{itemize}
\item 如果是.9图或者是不需要多个分辨率的图片，放在drawable文件夹即可
\item 对应分辨率的图片要正确的放在合适的文件夹，否则会造成图片拉伸等问题。
\end{itemize}

\textbf{更好地方案解决"图片资源"适配问题}

上述方案是常见的一种方案，这固然是一种解决办法，但缺点在于：
\begin{itemize}
\item 每套分辨率出一套图，为美工或者设计增加了许多工作量
\item 对Android工程文件的apk包变的很大
\end{itemize}

那么，有没有一种方法：
\begin{itemize}
\item 保证屏幕密度适配
\item 可以最小占用设计资源
\item 使得apk包不变大（只使用一套分辨率的图片资源）
\end{itemize}

下面我们就来介绍这个方法：

\begin{itemize}
\item 只需选择唯一一套分辨率规格的图片资源
\end{itemize}

方法介绍

\begin{enumerate}
\item 先来理解下Android 加载资源过程
\end{enumerate}

Android SDK会根据屏幕密度自动选择对应的资源文件进行渲染加载（自动渲染）
\begin{itemize}
\item 比如说，SDK检测到你手机的分辨率是320x480（dpi=160），会优先到drawable-mdpi文件夹下找对应的图片资源；但假设你只在xhpdi文件夹下有对应的图片资源文件（mdpi文件夹是空的），那么SDK会去xhpdi文件夹找到相应的图片资源文件，然后将原有大像素的图片自动缩放成小像素的图片，于是大像素的图片照样可以在小像素分辨率的手机上正常显示。
\item 具体请看\url{http://blog.csdn.net/xiebudong/article/details/37040263}
\end{itemize}

所以理论上来说只需要提供一种分辨率规格的图片资源就可以了。

那么应该提供哪种分辨率规格呢？
\begin{itemize}
\item 如果只提供ldpi规格的图片，对于大分辨率（xdpi、xxdpi）的手机如果把图片放大就会不清晰
\end{itemize}

所以需要提供一套你需要支持的最大dpi分辨率规格的图片资源，这样即使用户的手机分辨率很小，这样图片缩小依然很清晰。那么这一套最大dpi分辨率规格应该是哪种呢？是现在市面手机分辨率最大可达到1080X1920的分辨率（dpi=xxdpi=480）吗？

\begin{enumerate}
\item xhdpi应该是首选
\end{enumerate}

原因如下：
\begin{itemize}
\item xhdpi分辨率以内的手机需求量最旺盛
\begin{itemize}
\item 目前市面上最普遍的高端机的分辨率还多集中在720X1080范围内（xhdpi），所以目前来看xhpdi规格的图片资源成为了首选
\end{itemize}
\item 节省设计资源\&工作量
\begin{itemize}
\item 在现在的App开发中（iOS和Android版本），有些设计师为了保持App不同版本的体验交互一致，可能会以iPhone手机为基础进行设计，包括后期的切图之类的。
\item 设计师们一般都会用最新的iPhone6和iPhone5s（5s和5的尺寸以及分辨率都一样）来做原型设计，所有参数请看下图
\end{itemize}
\end{itemize}
\begin{center}
\begin{tabular}{lrrr}
\hline
机型 & 分辨率（px） & 屏幕尺寸（inch） & 系统密度（dpi）\\
\hline
iPhone 5s & 640X1164 & 4 & 332\\
iPhone 6 & 1334x750 & 4.7 & 326\\
iPhone 6 Plus & 1080x1920 & 5 & 400\\
\hline
\end{tabular}
\end{center}

iPhone主流的屏幕dpi约等于320, 刚好属于xhdpi，所以选择xhdpi作为唯一一套dpi图片资源，可以让设计师不用专门为Android端切图，直接把iPhone的那一套切好的图片资源放入drawable-xhdpi文件夹里就好，这样大大减少的设计师的工作量！

\textbf{额外小tips}
\begin{itemize}
\item ImageView的ScaleType属性
\begin{itemize}
\item 设置不同的ScaleType会得到不同的显示效果，一般情况下，设置为centerCrop能获得较好的适配效果。
\end{itemize}
\item 动态设置
\begin{itemize}
\item 使用场景：有些情况下，我们需要动态的设置控件大小或者是位置，比如说popwindow的显示位置和偏移量等
\end{itemize}
\end{itemize}

这时我们可以动态获取当前的屏幕属性，然后设置合适的数值
\begin{minted}[linenos=true]{java}
public class ScreenSizeUtil { 
    public static int getScreenWidth(Activity activity) { 
        return activity.getWindowManager().getDefaultDisplay().getWidth(); 
} 
    public static int getScreenHeight(Activity activity) { 
      return activity.getWindowManager().getDefaultDisplay().getHeight(); 
   }
}
\end{minted}
\end{enumerate}
% Emacs 25.3.1 (Org mode 8.2.7c)
\end{document}