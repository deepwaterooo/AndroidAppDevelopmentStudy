#+latex_class: cn-article
#+title: C# Interview Questions
#+author: Jenny Huang

* C# Interview Questions
** 100道C#面试题
*** .NET和C#有什么区别
- .NET一般指 .NET FrameWork框架，它是一种平台，一种技术。
- C#是一种编程语言，可以基于.NET平台的应用。
*** 一列数的规则如下: 1、1、2、3、5、8、13、21、34...... 求第30位数是多少，用递归算法实现。
  #+BEGIN_SRC csharp
public class MainClass  { 
    public static void Main()  { 
        Console.WriteLine(Foo(30)); 
    } 
    public static int Foo(int i)  { 
        if (i <= 0) 
            return 0; 
        else if (i > 0 && i <= 2) 
            return 1; 
        else
            return Foo(i -1) + Foo(i - 2); 
    } 
}
  #+END_SRC
*** C#中的委托是什么？事件是不是一种委托？
- 委托可以把一个方法作为参数代入另一个方法。
- 委托可以理解为指向一个函数的引用。
- 是，是一种特殊的委托
*** 简述 private、 protected、 public、internal 修饰符的访问权限。
- private : 私有成员, 在类的内部才可以访问。
- protected: 保护成员，该类内部和继承类中可以访问。
- public: 公共成员，完全公开，没有访问限制。
- internal:在同一命名空间内可以访问。
*** override与重载的区别
- override 与重载的区别。重载是方法的名称相同。参数或参数类型不同，进行多次重载以适应不同的需要
- Override是进行基类中函数的重写。为了适应需要。
*** 如果在一个B/S结构的系统中需要传递变量值，但是又不能使用Session、Cookie、Application，您有几种方法进行处理？
- this.Server.Transfer
*** 请编程遍历页面上所有TextBox控件并给它赋值为string.Empty？
  #+BEGIN_SRC csharp
foreach (System.Windows.Forms.Control control in this.Controls) {
    if (control is System.Windows.Forms.TextBox) {
        System.Windows.Forms.TextBox tb = (System.Windows.Forms.TextBox)control ; 
        tb.Text = String.Empty ;
    }
}
  #+END_SRC
*** 请编程实现一个选择排序算法？
  #+BEGIN_SRC csharp
public static int min;
public static void SelectionSort(int[] arr) { // 选择排序， 从左往右依次增大
    for (int i = 0; i < arr.Length - 1; i++) {
        min = i;
        for (int j = i + 1; j < arr.Length; j++) {
            if (arr[j] < arr[min])
                min = j;
        }
        int tmp = arr[i];
        arr[i] = arr[min];
        arr[min] = tmp;
    }
}
  #+END_SRC
*** 请编程实现一个冒泡排序算法？
  #+BEGIN_SRC csharp
// int [] array = new int [*] ; // 为什么需要这样一行 ？
public static int tmp;
public static void BubbleSort(int [] A) {
    for (int j = 0; j < A.Length - 1; j++) {
        for (int i = j + 1; i < A.Length; i++) {
            if (A[i] < A[j]) {
                tmp = A[i];
                A[i] = A[j];
                A[j] = tmp;
            }
        }
    }
}
  #+END_SRC

*** 描述一下C#中索引器的实现过程，是否只能根据数字进行索引？
- 不是。可以用任意类型。
*** 求以下表达式的值，写出您想到的一种或几种实现方法：1-2+3-4+……+m
  #+BEGIN_SRC csharp
int Num = this.TextBox1.Text.ToString() ;
int Sum = 0 ;
for (int i = 0 ; i < Num + 1 ; i++) {
    if (i % 2 == 0) {
        Sum += i ;
    } else { // i % 2 == 1
        Sum = Sum - i ;
    }
}
System.Console.WriteLine(Sum.ToString());
System.Console.ReadLine() ;
  #+END_SRC
*** 在下面的例子里
  #+BEGIN_SRC csharp
using System;
class A {
    public A() {
        //System.Console.WriteLine("A constructor: ");
        PrintFields();
    }
    public virtual void PrintFields() {
        //System.Console.WriteLine("A PrintFields: ");
    }
}
class B: A {
    int x = 1;
    int y;
    public B() {
        //System.Console.WriteLine("B constructor: ");
        y = -1;
        PrintFields(); // 需要这一行， 要不然结果不一样
    }
    public override void PrintFields() {
        //System.Console.WriteLine("B: PrintFields");
        Console.WriteLine("x = {0}, y = {1}", x, y);
    }
}
  #+END_SRC
- 当使用new B()创建B的实例时，产生什么输出？
- X = 1, Y = 0; x =  1, y = -1
- 代码执行顺序如下：

  #+BEGIN_SRC csharp
A constructor: 
B: PrintFields
x = 1, y = 0
B constructor: 
B: PrintFields
x = 1, y = -1
  #+END_SRC
*** 下面这段代码的执行结果是什么1
  #+BEGIN_SRC csharp
public class A {
    public virtual void Fun1(int i) {
        //Console.WriteLine("A Fun1: ");
        Console.WriteLine(i);
    }
    public void Fun2(A a) {
        //Console.WriteLine("A Fun2: ");
        a.Fun1(1);
        Fun1(5);
    }
}
public class B : A {
    public override void Fun1(int i) {
        //Console.WriteLine("B Fun1: ");
        base.Fun1(i + 1);
    }
    public static void Main() {
        A a = new A(); 
        B b = new B();
        a.Fun2(b);
        b.Fun2(a);
        Console.Read();
    }
}
  #+END_SRC
- 2， 5， 1， 6
  #+BEGIN_SRC csharp
A Fun2: 
B Fun1: 
A Fun1: 
2
A Fun1: 
5
A Fun2: 
A Fun1: 
1
B Fun1: 
A Fun1: 
6
  #+END_SRC
*** 下面这段代码的执行结果是什么2 
  #+BEGIN_SRC csharp
class Class1  {
    private string str = "Class1.str";
    private int i = 0;
    static void StringConvert(string str)  {
        str = "string being converted.";
    }
    static void StringConvert(Class1 c)  {
        c.str = "string being converted.";
    }
    static void Add(int i)  {
        i++;
    }
    static void AddWithRef(ref int i)  {
        i++;
    }
    static void Main()  {
        int i1 = 10;
        int i2 = 20;
        string str = "str";
        Class1 c = new Class1();
        Add(i1);
        //Console.WriteLine("i1: " + i1);
        AddWithRef(ref i2);
        //Console.WriteLine("i2: " + i2);
        Add(c.i); // c.i = 1
        //Console.WriteLine("c.i: " + c.i);
        StringConvert(str);
        //Console.WriteLine("str: " + str);
        StringConvert(c);
        //Console.WriteLine("c.str: " + c.str);
        Console.WriteLine(i1); 
        Console.WriteLine(i2);
        Console.WriteLine(c.i);
        Console.WriteLine(str);
        Console.WriteLine(c.str);
    }  
}    
  #+END_SRC
- 10，21，0，str，string being converted.
  #+BEGIN_SRC csharp
i1: 10
i2: 21
c.i: 0
str: str
c.str: string being converted.
10
21
0
str
string being converted.
  #+END_SRC

*** CTS、CLS、CLR分别作何解释？
- CTS：Common Type System, 通用语言系统。
- CLS：Common Language Specification, 通用语言规范。
- CLR：Common Language Runtime, 公共语言运行库。
*** 什么是装箱和拆箱？
- 从值类型接口转换到引用类型装箱。从引用类型转换到值类型拆箱。
*** 什么是受管制的代码？
- unsafe：非托管代码。不经过CLR运行。
*** 什么是强类型系统？
- RTTI：类型识别系统。
*** NET中读写数据库需要用到那些类？他们的作用？
- DataSet:数据存储器。
- DataCommand:执行语句命令。
- DataAdapter:数据的集合，用语填充。
*** 列举ASP.Net页面之间传递值的几种方式。 
- 1).使用QueryString, 如....?id=1; response. Redirect().... 
- 2).使用Session变量 
- 3).使用Server.Transfer
*** 什么是Code-Behind技术？
- 代码后植。
*** 在.net中，配件的意思是？
- 程序集。（中间语言，源数据，资源，装配清单）
*** 常用的调用WebService的方法有哪些？
- 1.使用WSDL.exe命令行工具。
- 2.使用VS.NET中的Add Web Reference菜单选项
*** .NET Remoting 的工作原理是什么？
- 服务器端向客户端发送一个进程编号，一个程序域编号，以确定对象的位置。
*** 在C＃中，string str = null 与 string str = “” 请尽量使用文字或图象说明其中的区别。
- string str = null 是不给他分配内存空间,
- string str = "" 给它分配长度为空字符串的内存空间。
*** 请详述在.NET中类(class)与结构(struct)的异同？
- Class可以被实例化,属于引用类型,是分配在内存的堆上的
- Struct属于值类型,是分配在内存的栈上的
*** 分析以下代码，完成填空
  #+BEGIN_SRC csharp
string strTmp = "abcdefg某某某";
int i = System.Text.Encoding.Default.GetBytes(strTmp).Length;
int j = strTmp.Length;
  #+END_SRC
- 以上代码执行完后，i= j=
  #+BEGIN_SRC csharp
i: 16 // 我的运行结果 
j: 10
// i = 13, j = 10 // 为什么会是这样呢？
  #+END_SRC
*** SQLSERVER服务器中，给定表table1 中有两个字段 ID、LastUpdateDate，ID表示更新的事务号，LastUpdateDate表示更新时的服务器时间，请使用一句SQL语句获得最后更新的事务号
  #+BEGIN_SRC sql
Select ID FROM table1 
Where LastUpdateDate = (Select MAX(LastUpdateDate) FROM table1)
  #+END_SRC
*** 简要谈一下您对微软.NET构架下remoting和webservice两项技术的理解以及实际中的应用。
- WS主要是可利用HTTP，穿透防火墙。
- 而Remoting可以利用TCP/IP，二进制传送提高效率。
*** 公司要求开发一个继承System.Windows.Forms.ListView类的组件，要求达到以下的特殊功能：点击ListView各列列头时，能按照点击列的每行值进行重排视图中的所有行 (排序的方式如DataGrid相似)。根据您的知识，请简要谈一下您的思路
- 根据点击的列头,包该列的ID取出,按照该ID排序后, 再给绑定到ListView中。
*** 写出一条Sql语句：取出表A中第31到第40记录（SQLServer,以自动增长的ID作为主键,注意：ID可能不是连续的。
  #+BEGIN_SRC sql
select top 10 * from A 
where id not in (select top 30 id from A)
  #+END_SRC
  #+BEGIN_SRC sql
select top 10 * from A 
where id > (select max(id) from (select top 30 id from A ) as A)
  #+END_SRC
*** 面向对象的语言具有___封装_____性、___继承______性、___多态_____性
- 封装、继承、多态。
*** 能用foreach遍历访问的对象需要实现 __IEnumerable__接口或声明__GetEnumerator__方法的类型。
- IEnumerable 、 GetEnumerator。
*** GC是什么? 为什么要有GC?
- GC是垃圾收集器。程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：
  - System.gc()
  - Runtime.getRuntime().gc()
*** Strings = new String("xyz");创建了几个String Object?
- 两个对象，一个是“xyx”,一个是指向“xyx”的引用对象s。
*** 启动一个线程是用run()还是start()?
- 启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。
*** 接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)?
- 接口可以继承接口。
- 抽象类可以实现(implements)接口，
- 抽象类是可以继承实体类，但前提是实体类必须有明确的构造函数。
*** 构造器Constructor是否可被override?
- 构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading。
*** 是否可以继承String类?
- String类是final类故不可以继承。
*** try{}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?
- 会执行，在return前执行。
*** 两个对象值相同(x.equals(y)== true)，但却可有不同的hash code，这句话对不对?
- 不对，有相同的hash code。
*** swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?
- switch（expr1）中，expr1是一个整数表达式。因此传递给 switch 和 case语句的参数应该是 int、 short、 char 或者 byte。
- long, string 都不能作用于swtich。
*** 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
- 不能，一个对象的一个synchronized方法只能由一个线程访问。
*** abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?
- 都不能。
*** List,Set, Map是否继承自Collection接口?
- List 和 Set 是, Map 不是
*** Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()?它们有何区别?
- Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。
- equals()是判读两个Set是否相等。
- equals()和==方法决定引用值是否指向同一对象
- equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。
*** 数组有没有length()这个方法? String有没有length()这个方法？
- 数组没有length()这个方法，有 Length 的属性。
- String有有length()这个方法。
*** sleep()和 wait() 有什么区别?
- sleep()方法是使线程停止一段时间的方法。在sleep 时间间隔期满后，线程不一定立即恢复执行。这是因为在那个时刻，其它线程可能正在运行而且没有被调度为放弃执行，除非
  - (a) “醒来”的线程具有更高的优先级
  - (b) 正在运行的线程因为其它原因而阻塞。
- wait()是线程交互时，如果线程对一个同步对象x 发出一个wait()调用，该线程会暂停执行，被调对象进入等待状态，直到被唤醒或等待时间到。
*** short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1; 有什么错?
- 有错，s1是short型，s1+1是int型, 不能显式转化为short型。
  #+BEGIN_SRC csharp
short s1 = 1; s1 = s1 + 1; 
  #+END_SRC
  #+BEGIN_SRC csharp
short s1 = 1;
// Cannot implicitly convert type 'int' to 'short'.
// An explicit conversion exists (are you missing a cast?)
// s1 = s1 + 1;
s1 = (short)(s1 + 1); 
System.Console.WriteLine("s1: " + s1);
short s2 = 1;
s2 += 1;
System.Console.WriteLine("s2: " + s2);
  #+END_SRC
- 可修改为
  #+BEGIN_SRC csharp
s1 =(short)(s1 + 1) 

short s1 = 1; 
s1 += 1 // 正确。
  #+END_SRC  
*** 谈谈final,finally, finalize的区别。
- final — 修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中 不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为 final的方法也同样只能使用，不能重载
- finally — 在异常处理时提供finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会 执行，然后控制就会进入 finally 块（如果有的话）。
- finalize — 方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的 ，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。
*** 如何处理几十万条并发数据？
- 用存储过程或事务。取得最大标识的时候同时更新..注意主键不是自增量方式这种方法并发的时候是不会有重复主键的..取得最大标识要有一个存储过程来获取.
*** Session有什么重大BUG，微软提出了什么方法加以解决？
- 是iis中由于有进程回收机制，系统繁忙的话Session会丢失，可以用Sate server或SQL Server数据库的方式存储Session不过这种方式比较慢，而且无法捕获Session的END事件。
*** 进程和线程的区别？
- 进程是系统进行资源分配和调度的单位；
- 线程是CPU调度和分派的单位，
- 一个进程可以有多个线程，这些线程共享这个进程的资源。
*** 堆和栈的区别？
- 栈：由编译器自动分配、释放。在函数体中定义的变量通常在栈上。
- 堆：一般由程序员分配释放。用new、malloc等分配内存函数分配得到的就是在堆上。
*** 成员变量和成员函数前加static的作用？
- 它们被称为常成员变量和常成员函数，又称为类成员变量和类成员函数。分别用来反映类的状态。比如类成员变量可以用来统计类实例的数量，类成员函数负责这种统计的动作。
*** ASP。NET与ASP相比，主要有哪些进步？
- asp解释形，aspx编译型，性能提高，有利于保护源码。
*** 请说明在.net中常用的几种页面间传递参数的方法，并说出他们的优缺点。
- session(viewstate) 简单，但易丢失
- application全局
- cookie简单，但可能不支持，可能被伪造
- inputtype = "hidden" 简单，可能被伪造
- url参数 简单，显示于地址栏，长度有限
- 数据库 稳定，安全，但性能相对弱
*** 请指出GAC的含义？
- GAC: Global Assembly Cache
- 全局程序集缓存。
*** 向服务器发送请求有几种方式？
- get, post。get一般为链接方式，post一般为按钮方式。
*** DataReader与Dataset有什么区别？
- 一个是只能向前的只读游标，一个是内存中虚拟的数据库。
*** 软件开发过程一般有几个阶段？每个阶段的作用？
- 需求分析，架构设计，代码编写，QA，部署
*** 在c#中using和new这两个关键字有什么意义，请写出你所知道的意义？using指令 和语句 new 创建实例 new 隐藏基类中方法。
- using 引入名称空间或者使用非托管资源
- new新建实例或者隐藏父类方法
*** 需要实现对一个字符串的处理,首先将该字符串首尾的空格去掉,如果字符串中间还有连续空格的话,仅保留一个空格,即允许字符串中间有多个空格,但连续的空格数不可超过一个.
  #+BEGIN_SRC csharp
using System.Text.RegularExpressions;
string inputStr = "  xx    xx  ";
inputStr = Regex.Replace(inputStr.Trim(),"\\s+", " ");
// System.Console.WriteLine("inputStr: A" + inputStr + "A;");
// inputStr: Axx xxA;

string input = "This is   text with   far  too   much   " + "whitespace.";
string pattern = "\\s+";
string replacement = " ";
Regex rgx = new Regex(pattern);
string result = rgx.Replace(input, replacement);
Console.WriteLine("Original String: {0}", input);
Console.WriteLine("Replacement String: {0}", result);                             
// The example displays the following output:
// Original String:    This is   text with   far  too   much   whitespace.
// Replacement String: This is text with far too much whitespace.
  #+END_SRC
- 正则表达式符号描述： http://www.jb51.net/article/73929.htm
  - \S	匹配任何非空白字符
  - \t	匹配一个制表符
  - \v	匹配一个垂直制表符。等价于\x0b和\cK
  - \w	匹配包括下划线的任何单词字符。等价于 '[A-Za-z0-9_]'
  - \W	匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'
*** 什么叫做SQL注入，如何防止？请举例说明。
- 利用sql关键字对网站进行攻击。过滤关键字等
- 利用sql语言漏洞获得合法身份登陆系统。如身份验证的程序设计成：

  #+BEGIN_SRC csharp
SqlCommand com = new SqlCommand("Select * from users where username = ‘"+t_name.text+"‘ and pwd=‘"+t_pwd.text+"‘");
object obj=com.ExcuteScale();
if (obj!=null) {
    // 通过验证
}
  #+END_SRC
- 这段代码容易被sql注入。如用户在t_name中随便输入，在t_pwd中输入1‘ and 1=‘1 就可以进入系统了。
*** 什么是反射？
- 动态获取程序集信息
*** 用Singleton如何写设计模式
- static属性里面new ,构造函数private
*** 什么是Application Pool？
- Web应用，类似Thread Pool，提高并发性能。
*** 什么是虚函数？什么是抽象函数？
- 虚函数：没有实现的，可由子类继承并重写的函数。
- 抽象函数：规定其非虚子类必须实现的函数，必须被重写。
*** 什么是XML？
- XML即可扩展标记语言。eXtensible Markup Language.
- 标记是指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。
- 如何定义这些标记，即可以选择国际通用的标记语言，比如HTML，也可以使用象XML这样由相关人士自由决定的标记语言，这就是语言的可扩展性。
- XML是从SGML中简化修改出来的。它主要用到的有XML、XSL和XPath等。
*** 什么是WebService？UDDI？
- Web Service便是基于网络的、分布式的模块化组件，它执行特定的任务，遵守具体的技术规范，这些规范使得Web Service能与其他兼容的组件进行互操作。
- UDDI的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为WebService提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。
*** 什么是ASP.net中的用户控件？
- 用户控件一般用在内容多为静态,或者少许会改变的情况下..用的比较大..类似ASP中的include..但是功能要强大的多。
*** 列举一下你所了解的XML技术及其应用
- xml用于配置,用于保存静态数据类型.接触XML最多的是web Services..和config
*** ADO.net中常用的对象有哪些？分别描述一下。
- Connection 数据库连接对象
- Command数据库命令
- DataReader数据读取器
- DataSet数据集
*** 什么是code-Behind技术。
- ASPX, RESX 和 CS 三个后缀的文件，这个就是代码分离.实现了HTML代码和服务器代码分离.方便代码编写和整理.
*** 什么是SOAP,有哪些应用。
- simple object access protocal,简单对象接受协议.以xml为基本编码结构,建立在已有通信协议上(如http,不过据说ms在搞最底层的架构在tcp/ip上的soap)的一种规范WebService使用的协议..
- SOAP（Simple Object Access Protocol ）简单对象访问协议是在分散或分布式的环境中交换信息并执行远程过程调用的协议，是一个基于XML的协议。使用SOAP，不用考虑任何特定的传输协议（最常用的还是HTTP协议），可以允许任何类型的对象或代码，在任何平台上，以任何一直语言相互通信。这种相互通信采用的是XML格式的消息。
- SOAP也被称作XMLP，为两个程序交换信息提供了一种标准的工作机制。在各类机构之间通过电子方式相互协作的情况下完全有必要为此制定相应的标准。
- SOAP描述了把消息捆绑为XML的工作方式。它还说明了发送消息的发送方、消息的内容和地址以及发送消息的时间。SOAP是Web Service的基本通信协议。SOAP规范还定义了怎样用XML来描述程序数据（Program Data）,怎样执行RPC（Remote Procedure Call）。大多数SOAP解决方案都支持RPC-style应用程序。SOAP还支持 Document-style应用程序（SOAP消息只包含XML文本信息）。
- 最后SOAP规范还定义了HTTP消息是怎样传输SOAP消息的。MSMQ、SMTP、TCP/IP都可以做SOAP的传输协议。
- SOAP 是一种轻量级协议，用于在分散型、分布式环境中交换结构化信息。 SOAP 利用 XML 技术定义一种可扩展的消息处理框架，它提供了一种可通过多种底层协议进行交换的消息结构。 这种框架的设计思想是要独立于任何一种特定的编程模型和其他特定实现的语义。
- SOAP 定义了一种方法以便将 XML 消息从 A 点传送到 B 点。 为此，它提供了一种基于 XML 且具有以下特性的消息处理框架： 1) 可扩展， 2) 可通过多种底层网络协议使用， 3) 独立于编程模型。

*** C#中 property 与 attribute的区别，他们各有什么用处，这种机制的好处在哪里？
- 一个是属性，用于存取类的字段，一个是特性，用来标识类，方法等的附加性质
*** XML与 HTML 的主要区别
- 1. XML是区分大小写字母的，HTML不区分。
- 2.在HTML中，如果上下文清楚地显示出段落或者列表键在何处结尾，那么你可以省略</p>或者</li>之类的结束标记。在XML中，绝对不能省略掉结束标记。
- 3.在XML中，拥有单个标记而没有匹配的结束标记的元素必须用一个 / 字符作为结尾。这样分析器就知道不用查找结束标记了。
- 4.在XML中，属性值必须分装在引号中。在HTML中，引号是可用可不用的。
- 5.在HTML中，可以拥有不带值的属性名。在XML中，所有的属性都必须带有相应的值。
*** c#中的三元运算符是？
- ？：
*** 当整数a赋值给一个object对象时，整数a将会被？
- 装箱。
*** 类成员有_____种可访问形式？
- this.;new Class().Method;
*** public static const int A = 1; 这段代码有错误么？是什么？
- const不能用static修饰。
*** float f = -123.567F; int i = (int)f; i的值现在是_____?
- -123。
*** 委托声明的关键字是__delegate__?
- delegate.
*** 用sealed修饰的类有什么特点？
- 密封，不能继承。
*** 在Asp.net中所有的自定义用户控件都必须继承自__Control__?
- Control。
*** 在.Net中所有可序列化的类都被标记为__[serializable]__?
- [serializable]
*** 在.Net托管代码中我们不用担心内存漏洞，这是因为有了__GC__?
- GC。
*** 当类T只声明了私有实例构造函数时，则在T的程序文本外部，___不可以___（可以 or 不可以）从T派生出新的类，__不可以__（可以 or 不可以）直接创建T的任何实例。
- 不可以，不可以。
*** 下面这段代码有错误么？
  #+BEGIN_SRC csharp
switch(i){
case(): // case()条件不能为空
    CaseZero();
    break;
case1:
    CaseOne();
    break;
case2:
default:
    //dufault; //wrong，格式不正确
    CaseTwo();
    break;
}
  #+END_SRC
*** 在.Net中，类System.Web.UI.Page 可以被继承么？
- 可以。
*** .net的错误处理机制是什么？
- net错误处理机制采用 try -> catch -> finally 结构，发生错误时，层层上抛，直到找到匹配的Catch为止。
*** 利用operator声明且仅声明了==，有什么错误么?
- 要同时修改Equale和GetHash() ? 
- 重载了 "==" 就必须重载 "!="
*** 在.net（C# or vb.net）中如何取消一个窗体的关闭。
  #+BEGIN_SRC csharp
private void Form1_Closing(object sender,
                           System.ComponentModel.CancelEventArgse) {
    e.Cancel = true;
}
  #+END_SRC
*** 在.net（C# or vb.net）中，Appplication.Exit 还是 Form.Close有什么不同？
- 一个是退出整个应用程序，一个是关闭其中一个form。
*** 某一密码仅使用K、L、M、N、O共5个字母，密码中的单词从左向右排列，密码单词必须遵循如下规则：
- （1） 密码单词的最小长度是两个字母，可以相同，也可以不同
- （2） K不可能是单词的第一个字母
- （3） 如果L出现，则出现次数不止一次
- （4） M不能是最后一个,也不能是倒数第二个字母
- （5） K出现，则N就一定出现
- （6） O如果是最后一个字母，则L一定出现
- 问题一：下列哪一个字母可以放在LO中的O后面，形成一个3个字母的密码单词？
  - A)K B)L C) M D) N
  - 答案:B
- 问题二：如果能得到的字母是K、L、M，那么能够形成的两个字母长的密码单词的总数是多少？
  - A)1个 B)3个 C)6个 D）9个
  - 答案:A
- 问题三：下列哪一个是单词密码？
  - A)KLLN B) LOML C) MLLO D)NMKO
  - 答案:C
*** 62-63=1 等式不成立，请移动一个数字（不可以移动减号和等于号），使得等式成立，如何移动？
- 62移动成2的6次方 2^6 - 63 = 1
*** C#中 property 与 attribute的区别，他们各有什么用处，这种机制的好处在哪里？
- attribute: 自定义属性的基类;
- property: 类中的属性
*** 在C＃中，string str = null 与 string str = "" 请尽量使用文字或图象说明其中的区别。
- null是没有空间引用的；
- "" 是空间为0的字符串；
*** abstract class和interface有什么区别?
- 声明方法的存在而不去实现它的类被叫做抽像类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。
  - 不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽像类，并让它指向具体子类的一个实例。
  - 不能有抽像构造函数或抽像静态方法。
  - Abstract 类的子类为它们父类中的所有抽像方法提供实现，否则它们也是抽像类。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。
- 接口（interface）是抽像类的变体。
  - 在接口中，所有方法都是抽像的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽像的，没有一个有程序体。
  - 接口只可以定义static final成员变量。
  - 接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对像上调用接口的方法。
  - 由于有抽像类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。
*** <%# %> 和 <% %> 有什么区别？
- <%# %>表示绑定的数据源
- <%%>是服务器端代码块
*** 重载 overloading 与 覆盖 overriding 的区别？
- 1、方法的覆盖是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关系，是水平关系
- 2、覆盖只能由一个方法，或只能由一对方法产生关系；方法的重载是多个方法之间的关系。
*** Overloaded的方法是否可以改变返回值的类型?
- Overloaded的方法是可以改变返回值的类型。
*** C#可否对内存进行直接的操作？
- 在.net下，.net引用了垃圾回收（GC）功能，它替代了程序员.
- 不过在C#中，不能直接实现Finalize方法，而是在析构函数中调用基类的Finalize()方法
*** 根据线程安全的相关知识，分析以下代码，当调用test方法时i>10时是否会引起死锁?并简要说明理由。
  #+BEGIN_SRC csharp
    public void test(int i) {
        lock (this) {
            if (i > 10) {
                i--;
                test(i);
            }
        }
    }
  #+END_SRC
- 不会发生死锁，（但有一点int是按值传递的，所以每次改变的都只是一个副本，因此不会出现死锁。但如果把int换做一个object，那么死锁就会发生）
*** 给定以下XML文件，完成算法流程图。 < DriverC > 请画出遍历所有文件名（FileName）的流程图(请使用递归算法)。
  #+BEGIN_SRC csharp
void FindFile (Directory d) {
    FileOrFolders = d.GetFileOrFolders();
    foreach (FileOrFolder fof in FileOrFolders) {
        if( fof is File )
            You Found a file;
        else if (fof is Directory )
            FindFile (fof);
    }
}
  #+END_SRC
*** 产生一个int数组，长度为100，并向其中随机插入1-100，并且不能重复。
  #+BEGIN_SRC csharp
using System.Collections;
int[] intArr = new int[100];
ArrayList myList = new ArrayList();
Random rnd = new Random();
while (myList.Count < 100) {
    int num = rnd.Next(1,101);
    if (!myList.Contains(num))
        myList.Add(num);
}
for (int i = 0; i < 100; i++) {
    intArr[i] = (int)myList[i];
    System.Console.WriteLine("intArr[i]: " + intArr[i]);
}
  #+END_SRC
*** 下面的代码中有什么错误吗？_______
  #+BEGIN_SRC csharp
using System;
class A {
    public virtual void F(){
        Console.WriteLine("A.F");
    }
}
abstract class B: A {
    public abstract override void F(); // abstract override 是不可以一起修饰.
} // new public abstract void F(); 什么意思
  #+END_SRC
*** 对于这样的一个枚举类型：
  #+BEGIN_SRC csharp
enum Color: byte {
    Red,
    Green,
    Blue,
    orange
}
  #+END_SRC
#+BEGIN_SRC csharp
string[] ss = Enum.GetNames(typeof(Color));
byte[] bb = Enum.GetValues(typeof(Color));
#+END_SRC
*** 写一个HTML页面，实现以下功能，左键点击页面时显示“您好”，右键点击时显示“禁止右键”。并在2分钟后自动关闭页面。
  #+BEGIN_SRC csharp
setTimeout(‘window.close();‘, 3000);
function show() {
    if (window.event.button == 1) {
        alert("左");
    } else if (window.event.button == 2) {
        alert("右");
    }
}
  #+END_SRC
*** 大概描述一下ASP。NET服务器控件的生命周期
- 初始化 加载视图状态 处理回发数据 加载 发送回发更改通知 处理回发事件 预呈现 保存状态 呈现 处置 卸载
*** Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?
- 不能，可以实现接口
*** Static Nested Class 和 Inner Class的不同，说得越多越好
- Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。
- 而通常的内部类需要在外部类实例化后才能实例化。
*** &和&&的区别。
- &是位运算符，表示按位与运算，
- &&是逻辑运算符，表示逻辑与（and）.
*** HashMap和Hashtable的区别。
- HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，
- 主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable.
*** error和exception有什么区别?
- error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。
- exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。
*** 你觉得ASP.NET 2.0（VS2005）和你以前使用的开发工具（.Net 1.0或其他）有什么最大的区别？你在以前的平台上使用的哪些开发思想（pattern / architecture）可以移植到ASP.NET 2.0上 (或者已经内嵌在ASP.NET 2.0中)
- 1 ASP.NET 2.0 把一些代码进行了封装打包,所以相比1.0相同功能减少了很多代码.
- 2 同时支持代码分离和页面嵌入服务器端代码两种模式,以前1.0版本,.NET提示帮助只有在分离的代码文件,无 法 在页面嵌入服务器端代码获得帮助提示,
- 3 代码和设计界面切换的时候,2.0支持光标定位.这个我比较喜欢
- 4 在绑定数据,做表的分页.Update,Delete,等操作都可以可视化操作,方便了初学者
- 5 在ASP.NET中增加了40多个新的控件,减少了工作量
*** 描述一下C#中索引器的实现过程，是否只能根据数字进行索引？
- 不是。可以用任意类型。
*** 分析以下代码。
  #+BEGIN_SRC csharp
public static void test(string ConnectString) {
    System.Data.OleDb.OleDbConnection conn = new System.Data.OleDb.OleDbConnection();
    conn.ConnectionString = ConnectString;
    try {
        conn.Open();
        //…….
    } catch(Exception Ex) {
        MessageBox.Show(Ex.ToString());
    } finally {
        if (!conn.State.Equals(ConnectionState.Closed))
            conn.Close();
    }
}
  #+END_SRC
- 请问1)以上代码可以正确使用连接池吗？
- 回如果传入的connectionString是一模一样的话，可以正确使用连接池。不过一模一样的意思是，连字符的空格数，顺序完全一致。
*** 什么是WSE？目前最新的版本是多少？
- WSE (Web Service Extension) 包来提供最新的WEB服务安全保证，目前最新版本2.0。
*** 下面的例子中
#+BEGIN_SRC csharp
class A {
    public static int X;
    static A() {
        //System.Console.WriteLine("A constructor: ");
        X = B.Y + 1;
        //System.Console.WriteLine("X: " + X);
    }
}
class B {
    public static int Y = A.X + 1;
    static B() {
        //System.Console.WriteLine("B constructor: ");
        //System.Console.WriteLine("Y: " + Y);

    }
    static void Main() {
        Console.WriteLine("X = {0}, Y = {1}", A.X, B.Y);
    }
}
#+END_SRC
- 产生的输出结果是什么？
- x = 1,y = 2

  #+BEGIN_SRC csharp
A constructor: 
X: 1
B constructor: 
Y: 2
X = 1, Y = 2
  #+END_SRC

** 125/135个基本的C#面试问答
- http://blog.jobbole.com/74515/
*** 什么是值类型和引用类型？
- 值类型存储在堆栈中。
  - 例如: bool, byte, chat, decimal, double, enum, float, int, long, sbyte, short, strut, uint, ulong, ushort。
- 引用类型存储在托管堆中。
  - 例如: class, delegate, interface, object, string。
*** 有哪些缓存的种类？
- 有三种类型的缓存：
  - 输出缓存(Output Caching):存储asp.net页面的应答信息。
  - 片段缓存(Fragment Caching):仅缓存/存储部分页面内容(用户控制)。
  - 数据缓存(Data Caching):为了性能通过编程的方式来缓存对象。
*** 自定义控件和用户控件之间的区别是什么？
- 自定义控件是编译后的代码(Dlls)，容易使用，创建困难，可以放在工具箱。拖拉使用的控件。
- 属性可以直观地在设计时指定。可以被多个应用程序使用(如果共享Dlls)，即使是私有的也能拷贝到web应用程序的bin目录，添加引用和使用。通常是用来为独立的消费应用程序提供公用功能。
- 用户控件和ASP的include文件，轻松创建，不能放置在箱中来拖拉放置它。用户控件在单个应用程序文件之间共享。
*** 什么是方法？
- 方法是由对象或者类执行来实现计算或者操作的成员。静态方法通过类访问。实例方法通过类的实例来访问。
*** 什么是域？
- 域是类或者类的实例相关的变量。
*** 什么是事件？
- 事件是使一个类或对象能够提供通知的成员。事件声明像域声明一样，除了声明包含event关键字并且类型必须为委托类型。
*** 什么是文本和它们的类型？
- 文本是程序分配给变量的值常量。C#支持的几种文本类型是
  - 整数(Integer literals)
  - 实数(Real literals)
  - 布尔值(Boolean literals)
  - 单字符(Single character literals)
  - 字符串(String literals)
  - 反斜线(Backslash character literals)
*** C#有什么特性？
- C#是一个简单而强大的编程语言，用于编写企业版的应用程序。
- 它是C++和VB的混合体。它保留了许多C++特性，如语句，表达式和运算符并结合了VB的生产力。
- C#帮助开发者轻易地构建网络服务，能够通过任何语言，任何平台来访问Internet。
- C#帮助开发者用更少的代码完成开发，从而在代码中错误更少。
- C#引入了相当大的改进和创新，如类型安全，版本控制，事件和垃圾收集这些领域。
*** 错误的类型是什么？
- 语法错误(Syntax error)
- 逻辑错误(Logic error)
- 运行时错误(Runtime error)
*** break和continue语句之间有什么区别？
- break语句是用来终止当前封闭循环或者它所在的条件语句的。我们已经使用break语句跳出switch语句。
- continue语句是用来改变执行顺序的。和break语句那样跳出循环相反，continue语句停止当前迭代并且只将控制返回到循环顶部。
*** 定义命名空间？
- 命名空间被称为容器，用来组织分层的.NET类。
*** 什么是代码组？
- 代码组是一组共享安全上下文的套件。
*** C#中什么是密封类？
- sealed修饰符用来阻止从一个类派生。如果一个密封类被指定为另一个类的基类时会发生编译时错误。
*** 静态方法和实例方法的区别是什么？
- 以static修饰符声明的方法是静态方法。静态方法不操作具体的实例，并且只能被静态成员访问。
- 没有以static修饰符声明的方法是实例方法。实例方法操作一个具体的实例并且可以被静态和实例成员访问。在其上调用实例方法的实例可以像这样显示访问。在静态方法中这么调用是错误的。
*** C#中有哪些变量的类型？
- C#中不同的变量类型是：
  - 静态变量(static variables)
  - 实例变量(instance variable)
  - 值参数(value parameters)
  - 引用参数(reference parameters)
  - 数组元素(array elements)
  - 输出参数(output parameters)
  - 局部变量(local variables)
*** C#中有什么特殊的运算符？
- C#支持一下特殊运算符。
- is (关系运算符)
- as (关系运算符)
- typeof (类型运算符)
- sizeof (大小运算符，用于获取非托管类的大小)
- new (对象运算符)
*** dot (成员访问运算符)
- checked (溢出检查)
- unchecked?(防止溢出检查)
*** C#中运算符的含义是什么？
- 运算符是界定了对类实例应用特定的运算表达式内涵的成员。可以定义三种类型的运算符：一元运算符，二元运算符和转换运算符。所有的运算符必须声明为public和static的。
*** 什么是类型参数化？
- 类型参数化是一个类型在另一个值或者类型之上参数化。
*** 抽象类的特性是什么？
- 抽象类不能被实力化，在抽象类上使用new操作符是错误的。
- 抽象类允许(但不必要)包含抽象方法和入口。
- 抽象类不能用scaled修饰符。
*** 控制台应用程序和窗口应用程序有什么区别？
- 控制台应用程序，设计用来在没有用户界面的命令行中运行。
- 窗口应用程序，设计用来通过用户界面在用户桌面执行。
*** C#有throws子句吗？
- 不，不像Java，C#不需要开发者指定方法可以抛出的异常。
*** C#支持可变数目的参数吗？
- 是的，使用params关键字。该参数指定为特定类型的参数列表。
*** 可以重写私有虚方法吗？
- 不可以，私有方法不能在类外访问。
*** 什么是多播委托？
- 每个委托对象保持对一个单独方法的引用。但是，一个委托对象保持对多个方法的引用并调用它们是可能的。这样的委托对象成为多播委托或者组合委托。
*** 什么是C#独有的特性？
- XML文档.
*** 在C#中使用异常是推荐的吗？
- 是的，在.NET框架中异常是推荐的错误处理机制。
*** 什么是智能导航？
- 因为服务端验证和页面被刷新导致页面刷新时，光标位置保持不变。
*** CONST和READONLY的区别是什么？
- 都是为了定义常量值。const字段只能在声明这个域的时候初始化。readonly字段可以在声明时或者构造函数中定义。
*** C#有throws子句吗？
- 不，不像Java，C#不需要(甚至不允许)开发者指定方法可以抛出的异常。
*** 方法可以重载的不同方式是什么？
- 不同的参数类型，不同的参数个数，不同的参数顺序。
*** 事件有返回值吗？
- 没有，事件没有返回类型。
*** 事件是什么？
- 事件是一个基于另一个程序方法执行的动作。
- 事件是被对象或者类使用来通知其他对象发生的事件的委托类型类成员。
- 事件可以通过event关键字来声明。
*** C#和C++的区别是什么？
- C#不支持#include语句。它只用using语句。
- C#中，类定义在最后不使用分号。
- C#不支持多重继承。
- 数据类型的显示转换在C#中比C++中安全很多。
- C#中switch也可用于字符串值。
- 命令行参数数组的行为在C#中和C++中不一样。
*** C#提供拷贝构造函数吗？
- 不，C#不提供拷贝构造函数。
*** 类或者结构可以有多个构造函数吗？
- 可以，类或者结构可以有多个构造函数。C#中构造函数可以被重载。
*** 可以创建接口的实例吗？
- 不可以，你不可以创建接口的实例。
*** 接口可以包含字段吗？
- 不可以，接口不能包含字段。
*** 类可以有静态构造函数吗？
- 是的，类可以有静态构造函数。静态构造函数在任何静态字段被访问之前被立即自动调用，并且通常用来初始化静态类成员。它在第一个实例被创建或者任何静态成员被引用之前自动调用。静态构造函数在实例构造函数之前调用。一个例子如下所示。
*** C#中委托的主要作用是什么？
- 委托主要用于定义回调方法。
*** 投影(Shadowing)和重写(overriding)的区别是什么？
- 重写仅仅重定义实现而投影重定义整个元素。
- 重写派生类可以通过“ME”关键字引用父类元素，但投影中你可以通过”MYBASE”访问父类元素。
*** 事件可以用访问修饰符吗？
- 可以，你可以在事件中用访问修饰符。你可以对事件使用portected关键字，这样只允许继承类访问。你可以使用private修饰事件，仅可以供当前类对象访问。
*** 什么是构造函数和析构函数？
- 构造函数和析构函数是特殊的方法。
- 构造函数和析构函数是每个类的特殊方法。
- 每个类都有自己的构造函数和析构函数，并且在类实例被创建或者销毁时自动调用。
- 每当你访问类的时候，构造函数就初始化所有类成员。当对象不想再需要的时候，析构函数就销毁它们。
*** 我们怎么抑制finalize方法？
- GC.SuppressFinalize()。
*** C#支持可变数目的参数吗？
- 是的，使用params关键字。
- 该参数指定为特定类型的参数列表，例如，int。为了最大的灵活性，类型可以是object。
- 使用这种方法的标准例子是System.console.writeLine()。
*** 哪个方法用来启动一个线程？
- Start。
*** 什么是泛型？
- 泛型帮助我们创建灵活的强类型集合。
- 泛型基本上从数据类型中分离了逻辑，以保持更好的可重用性，更好的可维护性等等。
*** 有哪些不同种类的多态性？
- 有两种类型的多态，它们是：
- 编译时多态性
- 运行时多态性
*** 编译时多态性和运行时多态性的区别是什么？
- 编译时多态性
- 编译时多态性也被称为方法重载。
- 方法重载是指有两个或更多同名但含有不同签名的方法。
- 运行时多态性
- 运行时多态性也被称为方法重写。
- 方法重写是指有两个或更多的同名方法，含有相同的方法签名但对应不同的实现。
*** 哪一个命名空间使XML中多线程编程可行？
- System.Threading。
*** 在C#中可以声明一个静态块吗？
- 不可以，因为C#不支持静态块，但它支持静态方法。
*** 方法可以声明为密封(sealed)吗？
- 在C#中方法不可以声明为sealed。但当我们在派生类重写一个方法的时候，我们可以将重写的方法定义为sealed。通过其sealed，我们就可以避免对该方法的进一步重写。
*** C#中什么是密封类？
- sealed修饰符用来阻止从一个类派生。如果一个密封类被指定为另一个类的基类时会发生编译时错误。
*** 类和接口的区别是什么？
- 抽象类可以实现它的一些成员，但接口不能实现它的任何成员。
- 接口不能有字段，而抽象类可以有字段。
- 接口仅可以从另一个接口继承并且不能继承抽象类，而抽象类可以继承另一个抽象类或另一个接口。
- 类可以同时继承多个接口，而类不能同时继承多个类。
- 抽象类的成员可以定义访问修饰符而接口成员不能定义访问修饰符。
*** 抽象方法和虚方法之间的区别是什么？
- 抽象方法不提供实现，并且强制派生类重写该方法(除非派生类也是个抽象类)，而虚方法可以有实现并且在派生类中重写与否是可选的。因此虚方法可以实现并提供了派生类重写的选择。抽象方法不能提供实现并且强制派生类重写该方法。
*** const和readonly之间有什么区别？
- const声明的字段不能使用static修饰符，而readonly可以使用static修饰符。
- const字段只能在声明时初始化，而readonly可以在声明时或在构造函数中初始化。
- const字段的值在设计时就计算出来了，而readonly的值在运行时计算。
*** C#.NET中使用的命名空间有哪些？
- 命名空间是类型的逻辑分组。
- using System;
- using System.Collections.Generic;
- using System.Windows.Forms;
*** C#有哪些特点？
- C#有以下特点：
  - 简单
  - 类型安全
  - 灵活
  - 面向对象
  - 兼容
  - 持久化
  - 互操作性
  - 有别于传统
*** 继承有哪些不同的类别？
- 在面向对象编程中继承的四种类型：
  - 单继承：包括一个基类和一个派生类。
  - 多层继承(Hierarchical inheritance) :包括一个基类和继承自同一个基类的派生类。
  - 多级继承(Multilevel inheritance):包括从一个派生类派生出来的类。
  - 多重继承(Multiple inheritance):包括多个基类和一个派生类。
*** C#中的修饰符有哪些？
- Abstract
- Sealed
- Virtual
- Const
- Event
- Extern
- Override
- Readonly
- Static
- New
*** C#中访问修饰符的种类有哪些？
- C#中的访问修饰符是：
- public
- protect
- private
- internal
- internal protect
*** Define destructors?定义析构函数？
- 当类对象超出作用域或者被明确删除的时候，析构函数被调用。析构函数，顾名思义是用来销毁由构造函数创建的对象的。正如构造函数，析构函数是一个类成员方法，方法名和类名相同，只是由波浪号开头。
*** 枚举数据类型怎么用？
- 枚举类型是另一种用户定义类型，它提供了一种连接名字为数字的方式，从而提高了代码的可理解性。enum关键字自动地枚举一组词，赋予它们的值为0,1,2并以此类推。
*** 定义构造函数？
- 构造函数是和它的类同名的成员方法。每当创建其关联的类的对象时构造函数都会被调用。它之所以被称为构造函数是因为它构造了类的数据成员的值。
*** 什么是交错数组？
- 交错数组是元素为数组的数组。
- 交错数组元素的维度和大小可以不同。
- 交错数组有时称为“数组的数组”。
*** ref和out参数之间的区别是什么？
- 传递给ref参数的参数必须先初始化。与此相比，对out参数来说，在参数传递给out参数之前不需要显示初始化。
*** C#中using语句怎么用？
- using语句通常是获取资源，执行语句，然后释放该资源。
*** 什么是序列化？
- 序列化(Serialization)是将对象转换为字节流的过程。
- 反序列化(De-serialization)是从字节流创建对象这样相反的过程。
- 序列化/反序列化常用于传递对象。
*** 结构和类之间有什么区别？
- 结构是值类型，类是引用类型。
- 结构不能有构造函数和析构函数。
- 类可以同时有构造函数和析构函数。
- 结构不支持继承，而类支持继承。
*** 类和接口之间有什么区别？
- 类(Class)是对象的逻辑表示。它是数据集合和相关子过程的定义。
- 接口(Interface)也是一个类，包含没有任何方法体定义的方法。类不支持多重继承，但是接口支持。
*** 什么是委托？
- 委托是类型安全，面向对象的函数指针的实现，并且在许多一个组件需要回调到使用它的组件这样的情况下使用。
*** 什么是认证与授权？
- 认证是识别用户的过程。认证是以证书(用户名和密码)来识别/验证用户。
- 授权在认证之后执行。授权是一个基于这些用户身份授予访问权限的过程。
- 授权允许用户对特定资源的访问。
*** “this”可以在静态方法中用吗？
- 不，‘This’不能在静态方法中使用。仅仅只有静态变量/方法可以在静态方法中使用。
*** constants、readonly和static之间的区别是什么？
- Constants: 值不能变。
- Read-only: 值在类的构造函数中仅仅初始化一次。
- Static: 值可以被初始化一次。
*** C#中支持哪些语句类型？
- C#支持的几种不同的语句类型是
  - 块语句
  - 声明语句
  - 表达式语句
  - 选择语句
  - 迭代语句
  - 跳转语句
  - 异常处理语句
  - 检查和未检查
  - Lock语句
*** C#是否可以对内存直接进行操作?
- 这个问题比较难回答，也是个很大的问题。但是可以这样问答。C#是可以对内存进行直接操作的，虽然很少用到指针，但是C#是可以使用指针的，在用的时候需要在前边加unsafe,，在.net中使用了垃圾回收机制(GC)功能，它替代了程序员，不过在C#中不可以直接使用finalize方法，而是在析构函数中调用基类的finalize()方法。
*** Collection和Collections的区别?
- Collection是集合类的上级接口，Collections是针对集合类的一个帮助类，它提供一系列静态方法来实现对各种集合的搜索，排序，线程安全化操作。
*** New有种用法?
- 有3种，第一种是，实例化如：New Class()
- 第二种是，public new 隐藏基类的方法
- 第三种是，在泛型类申明中的任何类型参数都必须有公共的无参构造函数。
- 17，任何把一个Array复制到Arraylist中?
- Foreach (object o in Array), ArrayList.Add (0)
- 等有好多中种方法。自己想。
*** 概述反射和序列化?
- 反射：要给发射下一个定义还是比较难的，这里先说说我的理解。反射提供了封装程序集，模块和类型对象，可以用反射动态地创建类型的实例，将类型绑定到现有对象，或者从现有对象类型里获取类型，然后调用类型的方法或访问字段和属性。
- 序列化：将对象转换为另一种媒介传输的格式过程。如，序列化一个对象，用Http通过internet在客户端和服务器之间传递该对象，在另一端用反序列化从该流中重新得到对象。
*** UDP和TCP连接有和异同?
- TCP是传输控制协议，提供的是面向连接的，是可靠的，字节流服务，当用户和服务器彼此进行数据交互的时候，必须在他们数据交互前要进行TCP连接之后才能传输数据。TCP提供超时重拨，检验数据功能。UDP是用户数据报协议，是一个简单的面向数据报的传输协议，是不可靠的连接。
*** 进程和线程分别该怎么理解?
- 进程是比线程大的程序运行单元，都是由操作系统所体会的系统运行单元，一个程序中至少要有一个进程，有一个进程中，至少要有一个线程，线程的划分尺度要比进程要小，进程拥有独立的内存单元，线程是共享内存，从而极大的提高了程序的运行效率同一个进程中的多个线程可以并发执行。
*** ASP.NET页面之间传递值的几种方式?
- QueryString,session,cookies,application,server.Transfer,respose.redictor.
*** 什么叫应用程序域?什么是托管代码?什么是强类型系统?什么是装箱和拆箱?什么是重载?CTS、CLS和CLR分别作何解释?
- 应用程序域：就是为安全性，可靠性，隔离性，和版本控制，及卸载程序提供的隔离边界。它通常由运行库宿主创建，应用程序域提供了一个更安全，用途更广的处理单元。
- 托管代码：使用CLR编译语言编辑器开发编写的代码就叫托管代码。
- 装箱和拆箱：是把值类型转换为引用类型的过程，是隐式的，相反的过程就是拆箱，是显式的。
- CTS是公共类型系统，CLS是公共语言规范，CLR公共语言运行库。
- 强类型系统：每个变量和对象都必须具有申明类型。
*** ASP.net的身份验证方式有哪些?
- windows,forms,passport
*** 解释一下UDDI、WSDL的意义及其作用?
- UDDI是统一描述集成协议，是一套基于Web的，分布式的，为WEB服务提供的信息注册的实现标准规范，同时为也是为企业本身提供的Web服务注册以让别的企业能够发现并访问的协议标准。提供了基于标准的规范，用于描述和发现服务，还提供了一组基于因特网的实现。
- WSDL这是一个基于XML的描述WEB服务的接口。
*** 什么是SOAP?
- 是简单访问协议。是在分布式环境中，交换信息并实现远程调用的协议。是一个基于XML的协议。使用SOAP，可以不考虑任何传输协议，但通常还是HTTP协议，可以允许任何类型的对象或代码，在任何平台上，以任一种语言相互通信。它是一种轻量级协议。
*** 如何部署一个ASP.net页面?
- vs2003,vs2005里边都有发表机制，vs2003可以发布然后在复制部署。
- Vs2005可以直接部署到对应的位置。
*** 如何理解.net中的垃圾回收机制?
- .NET中的垃圾回收机制是引用程序对内存的回收和释放。当每次用new关键字创建一个对象时，运行库都要从托管堆中为其分配内存，因为空间是有限的，最终垃圾回收机制是要回收不用的内存的。已释放内存，重新使用。
*** C#是一门托管语言，那么是不是说明只要用C#，就能保证不会出现内存泄露和其他资源泄漏？如果不是，在哪些情况下可能会出现泄漏？
- C#不能保证没有资源泄漏。比如如下几种情况可能会造成资源泄漏：
  - （1） 调用Native code，比如用P/Invoke或者调用COM；
  - （2） 读写文件时的，没有及时close stream, 或者ADO.NET连数据库时，没有及时关闭连接，也算资源泄漏？
  - （3）注册事件后没有remove，导致publisher和subscriber的强依 赖，垃圾回收可能会被推迟；
  - （4）.NET还定义了一些方法直接申请非托管内存，比如Marshal.AllocHGlobal和Marshal.AllocCoTaskMem。通过这种方式得到的内存，如果没有及时释放，也会造成内存泄露。
*** 下面的两段C#有哪些不同？
  #+BEGIN_SRC csharp
static void CatchException1() {
    try {
        Function();
    } catch {
        throw;
    }
}
 
static void CatchException2() {
    try {
        Function();
    } catch (Exception e) {
        throw e;
    }
}
  #+END_SRC
- 两个函数的catch都是重新抛出截获的exception，但抛出的exception的call stack是不一样的。对于第一种方法，exception的call stack是从最开始的抛出地点开始的。对于第二种方法，exception的call stack是从CatchException2开始的，最初抛出的地方相关的信息被隐藏了。
*** 运行下图中的C++代码，打印出的结果是什么？
  #+BEGIN_SRC csharp
bool Fun1(char* str) {
    printf("%s\n", str);
    return false;
}
bool Fun2(char* str) {
    printf("%s\n", str);
    return true;
}
int _tmain(int argc, _TCHAR* argv[]) {
    bool res1, res2;
    res1 = (Fun1("a") && Fun2("b")) || (Fun1("c") || Fun2("d"));
    res2 = (Fun1("a") && Fun2("b")) && (Fun1("c") || Fun2("d"));
    return res1 || res2;
}
  #+END_SRC
- 打印出4行，分别是a、c、d、a。
- 在C/C++中，与、或运算是从左到右的顺序执行的。在计算rest1时，先计算Fun1(“a”) && Func2(“b”)。首先Func1(“a”)打印出内容为a的一行。由于Fun1(“a”)返回的是false, 无论Func2(“b”)的返回值是true还是false，Fun1(“a”) && Func2(“b”)的结果都是false。由于Func2(“b”)的结果无关重要，因此Func2(“b”)会略去而不做计算。接下来计算Fun1(“c”) || Func2(“d”)，分别打印出内容c和d的两行。
- 在计算rest2时，首先Func1(“a”)打印出内容为a的一行。由于Func1(“a”)返回false，和前面一样的道理，Func2(“b”)会略去不做计算。由于Fun1(“a”) && Func2(“b”)的结果是false，不管Fun1(“c”) && Func2(“d”)的结果是什么，整个表达式得到的结果都是false，因此Fun1(“c”) && Func2(“d”)都将被忽略。
*** 运行下面的C#代码，打印出来的结果是什么？
  #+BEGIN_SRC csharp
struct Person {
    public string Name;
    public override string ToString() {
        return Name;
    }
}
class Program {
    static void Main(string[] args) {
        ArrayList array = new ArrayList();
        Person jim = new Person() {Name = "Jim"};
        array.Add(jim);
        Person first = (Person)array[0];
        first.Name = "Peter";
        Console.WriteLine(array[0].ToString());
    }
}
  #+END_SRC
- Person的定义是一个struct，因此是一个值类型。在运行到语句Person first = (Person)array[0]的时候，first是array[0]的一个拷贝，first和array[0]不是一个实例。因此修改first对array[0]没有影响。
*** 运行下面的C++代码，打印的结果是什么？
  #+BEGIN_SRC csharp
class Base {
    public:
    void print() { doPrint();}
    private:
    virtual void doPrint() {cout << "Base::doPrint" << endl;}
};
 
class Derived : public Base {
    private:
    virtual void doPrint() {cout << "Derived::doPrint" << endl;}
};
int _tmain(int argc, _TCHAR* argv[]) {
    Base b;
    b.print();
    Derived d;
    d.print();
    return 0;
}
  #+END_SRC
- 输出两行，分别是Base::doPrint和Derived::doPrint。在print中调用doPrint时，doPrint()的写法和this->doPrint()是等价的，因此将根据实际的类型调用对应的doPrint。所以结果是分别调用的是Base::doPrint和Derived::doPrint2。如果感兴趣，可以查看一下汇编代码，就能看出来调用doPrint是从虚函数表中得到函数地址的。
*** 维护数据库的完整性、一致性、你喜欢用触发器还是自写业务逻辑？为什么?
- 尽可能用约束（包括CHECK、主键、唯一键、外键、非空字段）实现，这种方式的效率最好；其次用触发器，这种方式可以保证无论何种业务系统访问数据库都能维持数据库的完整性、一致性；最后再考虑用自写业务逻辑实现，但这种方式效率最低、编程最复杂，当为下下之策。
*** 什么是事务？什么是锁？
- 事务是指一个工作单元，它包含了一组数据操作命令，并且所有的命令作为一个整体一起向系统提交或撤消请求操作，即这组命令要么都执行，要么都不执行。
- 锁是在多用户环境中对数据的访问的限制。SqlServer自动锁定特定记录、字段或文件，防止用户访问，以维护数据安全或防止并发数据操作问题，锁可以保证事务的完整性和并发性。
*** 什么是索引，有什么优点？
- 索引象书的目录类似，索引使数据库程序无需扫描整个表，就可以在其中找到所需要的数据，索引包含了一个表中包含值的列表，其中包含了各个值的行所存储的位置，索引可以是单个或一组列，索引提供的表中数据的逻辑位置，合理划分索引能够大大提高数据库性能。
*** 视图是什么？游标是什么？
- 视图是一种虚拟表，虚拟表具有和物理表相同的功能，可以对虚拟表进行增该查操作;
- 视图通常是一个或多个表的行或列的子集;
- 视图的结果更容易理解（修改视图对基表不影响），获取数据更容易（相比多表查询更方便），限制数据检索（比如需要隐藏某些行或列），维护更方便。
- 游标对查询出来的结果集作为一个单元来有效的处理，游标可以定位在结果集的特定行、从结果集的当前位置检索一行或多行、可以对结果集中当前位置进行修改、
*** 什么是存储过程？有什么优点？
- 存储过程是一组予编译的SQL语句
- 它的优点：
  - 1.允许模块化程序设计，就是说只需要创建一次过程，以后在程序中就可以调用该过程任意次。
  - 2.允许更快执行，如果某操作需要执行大量SQL语句或重复执行，存储过程比SQL语句执行的要快。
  - 3.减少网络流量，例如一个需要数百行的SQL代码的操作有一条执行语句完成，不需要在网络中发送数百行代码。
  - 4.更好的安全机制，对于没有权限执行存储过程的用户，也可授权他们执行存储过程。
*** 什么是触发器？
- 触发器是一种特殊类型的存储过程，出发器主要通过事件触发而被执行的，
- 触发器的优点：
  - 1.强化约束，触发器能够提供比CHECK约束;
  - 2.跟踪变化，触发器可以跟踪数据库内的操作，从而不允许未经允许许可的更新和变化;
  - 3.联级运算，比如某个表上的触发器中包含对另一个表的数据操作，而该操作又导致该表上的触发器被触发
*** 简单介绍下http://ADO.NET和ADO主要有什么改进？ 
- ADO以Recordset存储,而http://ADO.NET则以DataSet表示，http://ADO.NET提供了数据集和数据适配器，有利于实现分布式处理，降低了对数据库服务器资源的消耗。
*** http://ASP.NET与ASP相比，主要有哪些进步？ 
- http://ASP.NET实现了面向对象编程，预编译的服务器端代码而不像ASP那样解释执行提高了性能，代码分离易于管理，可订制和扩展性，功能强大的开发工作，更好的安全机制。 
*** C#中的委托是什么？事件是不是一种委托？
- 委托本质上是一种“方法接口”，它相当于C/C++中的函数指针，当然它比函数指针安全，在C#中通常用于事件处理。事件不是委托，不过由于事件的性质决定了处理它的程序逻辑能访问的参数，因此，在C#中处理事件的逻辑都包装为委托。
*** 列举http://ADO.NET中的五个主要对象，并简单描述 
- Connection连接对象，Command执行命令和存储过程，DataReader向前只读的数据流，DataAdapter适配器，支持增删查询，DataSet数据级对象，相当与内存里的一张或多张表。 
*** 概述三层结构体系 
- 表示层(UI),业务逻辑层(BLL),数据访问层(DAL) 
*** 什么是装箱和拆箱？什么是重载？ 
- 装箱就是把值类型转成引用类型，拆箱相反把引用转换成值类型。
- 重载就是指一个方法名相同,参数个数不相同,返回值可以相同的方法。 
*** 简述WebService 
- WebService服务可以描述为可以在web上部署并可以被任何应用程序或其他服务调用的功能。所谓服务就是系统提供一组接口，并通过接口使用系统提供的功能，WebService服务可以提供任何企业到客户，企业到企业，点对点或部门对部门通讯所需的服务，比如一个公司可以通过网络连接到另一个公司的服务，从而直接传递订购单。
*** DataGrid的Datasouse可以连接什么数据源
- DataTabe，DataView，DataSet，DataViewManager，任何实现IListSource接口的组件，任何实现IList接口的组件
*** 概述反射和序列化
- 反射：公共语言运行库加载器管理应用程序域。这种管理包括将每个程序集加载到相应的应用程序域以及控制每个程序集中类型层次结构的内存布局。程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。
- 序列化：序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。
*** 概述O/R Mapping 的原理
- 利用反射，配置将对象和数据库表映射。
*** 列举http://ADO.NET中的共享类和数据库特定类
- 共享类：DataSet，DataTable，DataRow，DataColumn，DataRealtion，Constraint，DataColumnMapping，DataTableMapping
- 特定类：(x)Connection，(x)Command，(x)CommandBuilder，(x)DataAdapter，(x)DataReader，(x)Parameter，(x)Transaction
*** 详述.NET里class和struct的异同
- 结构与类共享几乎所有相同的语法，但结构比类受到的限制更多：尽管结构的静态字段可以初始化，结构实例字段声明还是不能使用初始值设定项。
- 结构不能声明默认构造函数（没有参数的构造函数）或析构函数。
- 结构的副本由编译器自动创建和销毁，因此不需要使用默认构造函数和析构函数。实际上，编译器通过为所有字段赋予默认值（参见默认值表）来实现默认构造函数。
- 结构不能从类或其他结构继承。
- 结构是值类型 -- 如果从结构创建一个对象并将该对象赋给某个变量，变量则包含结构的全部值。复制包含结构的变量时，将复制所有数据，对新副本所做的任何修改都不会改变旧副本的数据。
- 由于结构不使用引用，因此结构没有标识 -- 具有相同数据的两个值类型实例是无法区分的。C# 中的所有值类型本质上都继承自ValueType，后者继承自 Object。编译器可以在一个称为装箱的过程中将值类型转换为引用类型。
- 结构具有以下特点：
  - 结构是值类型，而类是引用类型。
  - 向方法传递结构时，结构是通过传值方式传递的，而不是作为引用传递的。
  - 与类不同，结构的实例化可以不使用 new 运算符。
  - 结构可以声明构造函数，但它们必须带参数。
  - 一个结构不能从另一个结构或类继承，而且不能作为一个类的基。所有结构都直接继承自 System.ValueType，后者继承自 System.Object。
  - 结构可以实现接口。
  - 在结构中初始化实例字段是错误的。
*** 什么叫应用程序域？什么是托管代码？什么是强类型系统？什么是装箱和拆箱？什么是重载？ CTS、CLS和CLR分别作何解释？
- 应用程序域：应用程序域为安全性、可靠性、版本控制以及卸载程序集提供了隔离边界。应用程序域通常由运行库宿主创建，运行库宿主负责在运行应用程序之前引导公共语言运行库。应用程序域提供了一个更安全、用途更广的处理单元，公共语言运行库可使用该单元提供应用程序之间的隔离。
- 托管代码：使用基于公共语言运行库的语言编译器开发的代码称为托管代码；托管代码具有许多优点，例如：跨语言集成、跨语言异常处理、增强的安全性、版本控制和部署支持、简化的组件交互模型、调试和分析服务等。
- 强类型：C# 是强类型语言；因此每个变量和对象都必须具有声明类型。
- 装箱和拆箱：装箱和拆箱使值类型能够被视为对象。对值类型装箱将把该值类型打包到 Object 引用类型的一个实例中。这使得值类型可以存储于垃圾回收堆中。拆箱将从对象中提取值类型。
- 重载：每个类型成员都有一个唯一的签名。方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成。只要签名不同，就可以在一种类型内定义具有相同名称的多种方法。当定义两种或多种具有相同名称的方法时，就称作重载。
- CTS通用类型系统 (common type system) ：一种确定公共语言运行库如何定义、使用和管理类型的规范。
- CLR公共语言运行库：.NET Framework 提供了一个称为公共语言运行库的运行时环境，它运行代码并提供使开发过程更轻松的服务。
- CLS公共语言规范：要和其他对象完全交互，而不管这些对象是以何种语言实现的，对象必须只向调用方公开那些它们必须与之互用的所有语言的通用功能。为此定义了公共语言规范 (CLS)，它是许多应用程序所需的一套基本语言功能。
*** 如何理解委托
- 委托类似于 C++ 函数指针，但它是类型安全的。委托允许将方法作为参数进行传递。委托可用于定义回调方法。委托可以链接在一起；例如，可以对一个事件调用多个方法。方法不需要与委托签名精确匹配。有关更多信息，请参见协变和逆变。C# 2.0 版引入了匿名方法的概念，此类方法允许将代码块作为参数传递，以代替单独定义的方法。
*** http://26.ASP.net的身份验证方式有哪些？
- Windows 身份验证提供程序：提供有关如何将Windows 身份验证与Microsoft Internet 信息服务 (IIS) 身份验证结合使用来确保 The Official Microsoft ASP.NET Site 应用程序安全的信息。
- Forms 身份验证提供程序：提供有关如何使用您自己的代码创建应用程序特定的登录窗体并执行身份验证的信息。使用 Forms 身份验证的一种简便方法是使用 The Official Microsoft ASP.NET Site 成员资格和 The Official Microsoft ASP.NET Site 登录控件，它们一起提供了一种只需少量或无需代码就可以收集、验证和管理用户凭据的方法。
- Passport 身份验证提供程序：提供有关由Microsoft 提供的集中身份验证服务的信息，该服务为成员站点提供单一登录和核心配置
*** 活动目录的作用
- Active Directory存储了有关网络对象的信息，并且让管理员和用户能够轻松地查找和使用这些信息。
- Active Directory使用了一种结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻辑的分层组织。
*** 解释一下UDDI、WSDL的意义及其作用
- UDDI：统一描述、发现和集成协议(UDDI, Universa Description, Discovery and Integration)是一套基于Web的、分布式的、为Web服务提供的信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web服务注册以使得别的企业能够发现的访问协议的实现标准。UDDI 提供了一组基于标准的规范用于描述和发现服务，还提供了一组基于因特网的实现。
- WSDL：WSDL描述Web服务的公共接口。这是一个基于XML的关于如何与Web服务通讯和使用的服务描述；
- 作用： 服务 URL 和命名空间 ：网络服务的类型（可能还包括SOAP 的函数调用，正像我所说过的，WSDL足够自如地去描述网络服务的广泛内容）。有效函数列表，每个函数的参数，每个参数的类型 ，每个函数的返回值及其数据类型。
*** 什么是SOAP？
- SOAP（Simpe Object Access Protoco ）简单对象访问协议是在分散或分布式的环境中交换信息并执行远程过程调用的协议，是一个基于XML的协议。使用SOAP，不用考虑任何特定的传输协议（最常用的还是HTTP协议），可以允许任何类型的对象或代码，在任何平台上，以任何一直语言相互通信。
- SOAP 是一种轻量级协议，用于在分散型、分布式环境中交换结构化信息。 SOAP 利用 XML 技术定义一种可扩展的消息处理框架，它提供了一种可通过多种底层协议进行交换的消息结构。这种框架的设计思想是要独立于任何一种特定的编程模型和其他特定实现的语义。
- SOAP 定义了一种方法以便将 XML 消息从 A 点传送到 B 点。为此，它提供了一种基于 XML且具有以下特性的消息处理框架：1) 可扩展，2) 可通过多种底层网络协议使用，3) 独立于编程模型。 
*** 如何部署一个http://ASP.net页面？
- VS 2005和VS 2003都有发布机制。2003可以发布然后再复制部署。VS2005基本上可以直接部署到对应位置。
*** 如何理解.net中的垃圾回收机制？
- .NETFramework 的垃圾回收器管理应用程序的内存分配和释放。每次您使用 new 运算符创建对象时，运行库都从托管堆为该对象分配内存。只要托管堆中有地址空间可用，运行库就会继续为新对象分配空间。但是，内存不是无限大的。最终，垃圾回收器必须执行回收以释放一些内存。垃圾回收器优化引擎根据正在进行的分配情况确定执行回收的最佳时间。当垃圾回收器执行回收时，它检查托管堆中不再被应用程序使用的对象并执行必要的操作来回收它们占用的内存。 
*** 概述.NET中的GC机制。
- GC的全称是garbage collection，中文名称垃圾回收，是.NET中对内存管理的一种功能。垃圾回收器跟踪并回收托管内存中分配的对象，定期执行垃圾回收以回收分配给没有有效引用的对象的内存。当使用可用内存不能满足内存请求时，GC会自动进行。 
- 在进行垃圾回收时，垃圾回收器会首先搜索内存中的托管对象，然后从托管代码中搜索被引用的对象并标记为有效，接着释放没有被标记为有效的对象并收回内存，最后整理内存将有效对象挪动到一起
- http://33.ASP.NET中常见内置对象？
- Response、Request、Server、Session、Application、Cookie
*** 死锁的必要条件？怎么克服？
- 系统的资源不足，进程的推进的顺序不合适，资源分配不当，一个资源每次只能被一个进程使用，一个资源请求资源时，而此时这个资源已阻塞，对已获得资源不放，进程获得资源时，未使用完前，不能强行剥夺。
*** 简要谈您对微软.NET 构架下remoting和webservice两项技术的理解以及实际中的应用。
- WS主要是可利用HTTP，穿透防火墙。而Remoting可以利用TCP/IP，二进制传送提高效率。
- remoting是.net中用来跨越machine,process, appdomain进行方法调用的技术,对于三成结构的程序，就可以使用remoting技术来构建．它是分布应用的基础技术.相当于以前的DCOM。
- Web Service是一种构建应用程序的普通模型，并能在所有支持internet网通讯的操作系统上实施。Web Service令基于组件的开发和web的结合达到最佳，基于组件的对象模型。
*** 公司要求开发一个继承System.Windows.Forms.ListView类的组件，要求达到以下的特殊功能：点击ListView各列列头时，能按照点击列的每行值进行重排视图中的所有行 (排序的方式如DataGrid相似)。根据您的知识，请简要谈一下您的思路
- 根据点击的列头,包该列的ID取出,按照该ID排序后,在给绑定到ListView中。
*** 给定以下XML文件，完成算法流程图。
  #+BEGIN_SRC xml
<FileSystem> 
　　< DriverC > 
　　　　<Dir DirName=”MSDOS622”> 
    　　　　　　<File FileName =” Redirecting to Command Brand”></File>
    　　　　</Dir> 
    　　　　<File FileName =”MSDOS.SYS” ></File>
    　　　　<File FileName =” IO.SYS”></File> 
    　　</DriverC> 
    </FileSystem> 
  #+END_SRC
- 请画出遍历所有文件名（FileName）的流程图(请使用递归算法)。
  #+BEGIN_SRC csharp
void FindFile(Directory d) { 
    FileOrFolders = d.GetFileOrFolders(); 
    foreach ( FileOrFolder fof in FileOrFolders) {
        if (fof  is  File) {
            // You Found a file; 
        } else if (fof is Directory) 
            FindFile(fof);                       　　
        }
    }
}
  #+END_SRC
*** http://109.ADO.NET相对于ADO等主要有什么改进？
- 1:http://ado.net不依赖于ole db提供程序,而是使用.net托管提供的程序,
- 2:不使用com
- 3:不在支持动态游标和服务器端游 
- 4:,可以断开connection而保留当前数据集可用
- 5:强类型转换
- 6:xml支持
*** 你觉得ASP.NET 2.0（VS2005）和你以前使用的开发工具（.Net 1.0或其他）有什么最大的区别？你在以前的平台上使用的哪些开发思想（pattern/ architecture）可以移植到ASP.NET2.0上 (或者已经内嵌在ASP.NET 2.0中)
- 1、ASP.NET2.0把一些代码进行了封装打包,所以相比1.0相同功能减少了很多代码。
- 2、同时支持代码分离和页面嵌入服务器端代码两种模式,以前1.0版本,.NET提示帮助只有在分离的代码文件,无 法 在页面嵌入服务器端代码获得帮助提示。
- 3、代码和设计界面切换的时候,2.0支持光标定位.这个我比较喜欢。
- 4、在绑定数据,做表的分页.UPDATE,DELETE,等操作都可以可视化操作,方便了初学者。
- 5、在http://ASP.NET中增加了40多个新的控件,减少了工作量。
*** 重载与覆盖的区别？
- 1、方法的覆盖是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关系，是水平关系。
- 2、覆盖只能由一个方法，或只能由一对方法产生关系；方法的重载是多个方法之间的关系。
- 3、覆盖要求参数列表相同；重载要求参数列表不同。
- 4、覆盖关系中，调用那个方法体，是根据对象的类型（对像对应存储空间类型）来决定；重载关系，是根据调用时的实参表与形参表来选择方法体的。
*** 什么是WSE？目前最新的版本是多少？
- WSE (WebService Extension)包来提供最新的WEB服务安全保证，最新版本2.0。
*** a=10,b=15，在不用第三方变量的前提下，把a,b的值互换
- a=a+b;b=a-b;a=a-b;
*** 还有变态要求，需要代码最短呢。有两个结果：
- 1) a^=b^(b^=a^b); // 13个字节
- 2) a=b+(b=a)*0; // 11个字节
*** 请简述面向对象的多态的特性及意义！
- 面向对象的编程使用了派生继承以及虚函数机制.一个本来指向基类的对象指针可以指向其派生类的.并访问从基类继承而来的成员变量和函数.而虚函数是专门为这个特性设计的,这个函数在每个基类的派生类中都是同一个名字,但函数体却并不一定相同,派生类往往为实现自己的功能而修改这个虚函数.这样用一个指针就能够实现对多种不同的派生类的访问, 并实现其派生类的特定功能(代码 )
*** session喜欢丢值且占内存，Cookis不安全，请问用什么办法代替这两种原始的方法
- 用ViewState，stateserver
*** 对数据的并发采用什么办法进行处理较好。
- 可以控制连接池的连接数量,条件好的话可以用负载平衡
- http://123.ADO.NET处理数据并发的方法和步骤?
- 开放式并发，没有用到数据库的锁，而依靠SQL语句判断数据是否已经变化了。
-  步骤：通常使用VS提供的工具生成SQL语句，工具生成的结果实在不符合要求，才手工写SQL语句。
*** 动态创建的控件PostBack后是否可以保存下来,为什么? 
- http://ASP.NET框架不会为你保存，但可以手工保存到ViewState
*** 要点：1. 联动效果，运行代码只要执行Cat.Cryed()方法。2. 对老鼠和主人进行抽象
- 评分标准: 
  - <1>.构造出Cat、Mouse、Master三个类，并能使程序运行(2分)
  - <2>从Mouse和Master中提取抽象（5分）
  - <3>联动效应，只要执行Cat.Cryed()就可以使老鼠逃跑，主人惊醒。(3分)
  #+BEGIN_SRC csharp
public interface Observer {
    void Response();           // 观察者的响应，如是老鼠见到猫的反映
}
public interface Subject {
    void AimAt(Observer obs);  // 针对哪些观察者，这里指猫的要扑捉的对象---老鼠
}
public class Mouse : Observer {
    private string name;
    public Mouse(string name, Subject subj) {           
        this.name = name;
        subj.AimAt(this);
    }
    public void Response() {
        Console.WriteLine(name + " attempt to escape!");
    }
}
public class Master : Observer {   
    public Master(Subject subj) {           
        subj.AimAt(this);
    }
    public void Response() {
        Console.WriteLine("Host waken!");
    }  
}
public class Cat : Subject {
    private ArrayList observers;
    public Cat() {   
        this.observers = new ArrayList();
    }
    public void AimAt(Observer obs) {
        this.observers.Add(obs);
    }
    public void Cry() {
        Console.WriteLine("Cat cryed!");
        foreach (Observer obs in this.observers) {
            obs.Response();
        }
    }
}
class MainClass {       
    static void Main(string[] args) {
        Cat cat = new Cat();
        Mouse mouse1 = new Mouse("mouse1", cat);
        Mouse mouse2 = new Mouse("mouse2", cat);
        Master master = new Master(cat);
        cat.Cry();
    }
}

//---------------------------------------------------------------------------------------------
// 设计方法二: 使用event -- delegate设计..
//---------------------------------------------------------------------------------------------
public delegate void SubEventHandler();
public abstract class Subject {
    public event SubEventHandler SubEvent;
    protected void FireAway() {
        if (this.SubEvent != null)
            this.SubEvent();
    }   
}
public class Cat : Subject {  
    public void Cry() {
        Console.WriteLine("cat cryed.");
        this.FireAway();
    }
}
public abstract class Observer {
    public Observer(Subject sub) {
        sub.SubEvent += new SubEventHandler(Response);
    }
    public abstract void Response();    
}
public class Mouse : Observer {
    private string name;
    public Mouse(string name, Subject sub) : base(sub) {   
        this.name = name;
    }
    public override void Response() {
        Console.WriteLine(name + " attempt to escape!");
    }
}
public class Master : Observer {
    public Master(Subject sub) : base(sub){}
    public override void Response() {
        Console.WriteLine("host waken");
    }
}
class Class1 {
    static void Main(string[] args) {
        Cat cat = new Cat();
        Mouse mouse1 = new Mouse("mouse1", cat);
        Mouse mouse2 = new Mouse("mouse2", cat);
        Master master = new Master(cat);
        cat.Cry();
    }
}
  #+END_SRC

** C#中的Static, readonly和const之间的比较
- http://www.cnblogs.com/suizhikuo/p/4739388.html

** C#中的委托和事件 - Part.1 （讲叙得非常透彻~！）
- http://www.tracefact.net/tech/009.html

** C# 事件和Unity3D （讲叙得非常透彻~！）
- http://zijan.iteye.com/blog/871207

