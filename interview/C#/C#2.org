#+latex_class: cn-article
#+title: C# Interview Questions
#+author: Jenny Huang

* C# Interview Questions - Part II
** 125/135个基本的C#面试问答
- http://blog.jobbole.com/74515/
*** 什么是值类型和引用类型？
- 值类型存储在堆栈中。
  - 例如: bool, byte, chat, decimal, double, enum, float, int, long, sbyte, short, strut, uint, ulong, ushort。
- 引用类型存储在托管堆中。
  - 例如: class, delegate, interface, object, string。
*** 有哪些缓存的种类？
- 有三种类型的缓存：
  - 输出缓存(Output Caching):存储asp.net页面的应答信息。
  - 片段缓存(Fragment Caching):仅缓存/存储部分页面内容(用户控制)。
  - 数据缓存(Data Caching):为了性能通过编程的方式来缓存对象。
*** 自定义控件和用户控件之间的区别是什么？
- 自定义控件是编译后的代码(Dlls)，容易使用，创建困难，可以放在工具箱。拖拉使用的控件。
- 属性可以直观地在设计时指定。可以被多个应用程序使用(如果共享Dlls)，即使是私有的也能拷贝到web应用程序的bin目录，添加引用和使用。通常是用来为独立的消费应用程序提供公用功能。
- 用户控件和ASP的include文件，轻松创建，不能放置在箱中来拖拉放置它。用户控件在单个应用程序文件之间共享。
*** 什么是方法？
- 方法是由对象或者类执行来实现计算或者操作的成员。静态方法通过类访问。实例方法通过类的实例来访问。
*** 什么是域？
- 域是类或者类的实例相关的变量。
*** 什么是事件？
- 事件是使一个类或对象能够提供通知的成员。事件声明像域声明一样，除了声明包含event关键字并且类型必须为委托类型。
*** 什么是文本和它们的类型？
- 文本是程序分配给变量的值常量。C#支持的几种文本类型是
  - 整数(Integer literals)
  - 实数(Real literals)
  - 布尔值(Boolean literals)
  - 单字符(Single character literals)
  - 字符串(String literals)
  - 反斜线(Backslash character literals)
*** C#有什么特性？
- C#是一个简单而强大的编程语言，用于编写企业版的应用程序。
- 它是C++和VB的混合体。它保留了许多C++特性，如语句，表达式和运算符并结合了VB的生产力。
- C#帮助开发者轻易地构建网络服务，能够通过任何语言，任何平台来访问Internet。
- C#帮助开发者用更少的代码完成开发，从而在代码中错误更少。
- C#引入了相当大的改进和创新，如类型安全，版本控制，事件和垃圾收集这些领域。
*** 错误的类型是什么？
- 语法错误(Syntax error)
- 逻辑错误(Logic error)
- 运行时错误(Runtime error)
*** break和continue语句之间有什么区别？
- break语句是用来终止当前封闭循环或者它所在的条件语句的。我们已经使用break语句跳出switch语句。
- continue语句是用来改变执行顺序的。和break语句那样跳出循环相反，continue语句停止当前迭代并且只将控制返回到循环顶部。
*** 定义命名空间？
- 命名空间被称为容器，用来组织分层的.NET类。
*** 什么是代码组？
- 代码组是一组共享安全上下文的套件。
*** C#中什么是密封类？
- sealed修饰符用来阻止从一个类派生。如果一个密封类被指定为另一个类的基类时会发生编译时错误。
*** 静态方法和实例方法的区别是什么？
- 以static修饰符声明的方法是静态方法。静态方法不操作具体的实例，并且只能被静态成员访问。
- 没有以static修饰符声明的方法是实例方法。实例方法操作一个具体的实例并且可以被静态和实例成员访问。在其上调用实例方法的实例可以像这样显示访问。在静态方法中这么调用是错误的。
*** C#中有哪些变量的类型？
- C#中不同的变量类型是：
  - 静态变量(static variables)
  - 实例变量(instance variable)
  - 值参数(value parameters)
  - 引用参数(reference parameters)
  - 数组元素(array elements)
  - 输出参数(output parameters)
  - 局部变量(local variables)
*** C#中有什么特殊的运算符？
- C#支持一下特殊运算符。
- is (关系运算符)
- as (关系运算符)
- typeof (类型运算符)
- sizeof (大小运算符，用于获取非托管类的大小)
- new (对象运算符)
*** dot (成员访问运算符)
- checked (溢出检查)
- unchecked?(防止溢出检查)
*** C#中运算符的含义是什么？
- 运算符是界定了对类实例应用特定的运算表达式内涵的成员。可以定义三种类型的运算符：一元运算符，二元运算符和转换运算符。所有的运算符必须声明为public和static的。
*** 什么是类型参数化？
- 类型参数化是一个类型在另一个值或者类型之上参数化。
*** 抽象类的特性是什么？
- 抽象类不能被实力化，在抽象类上使用new操作符是错误的。
- 抽象类允许(但不必要)包含抽象方法和入口。
- 抽象类不能用scaled修饰符。
*** 控制台应用程序和窗口应用程序有什么区别？
- 控制台应用程序，设计用来在没有用户界面的命令行中运行。
- 窗口应用程序，设计用来通过用户界面在用户桌面执行。
*** C#有throws子句吗？
- 不，不像Java，C#不需要开发者指定方法可以抛出的异常。
*** C#支持可变数目的参数吗？
- 是的，使用params关键字。该参数指定为特定类型的参数列表。
*** 可以重写私有虚方法吗？
- 不可以，私有方法不能在类外访问。
*** 什么是多播委托？
- 每个委托对象保持对一个单独方法的引用。但是，一个委托对象保持对多个方法的引用并调用它们是可能的。这样的委托对象成为多播委托或者组合委托。
*** 什么是C#独有的特性？
- XML文档.
*** 在C#中使用异常是推荐的吗？
- 是的，在.NET框架中异常是推荐的错误处理机制。
*** 什么是智能导航？
- 因为服务端验证和页面被刷新导致页面刷新时，光标位置保持不变。
*** CONST和READONLY的区别是什么？
- 都是为了定义常量值。const字段只能在声明这个域的时候初始化。readonly字段可以在声明时或者构造函数中定义。
*** C#有throws子句吗？
- 不，不像Java，C#不需要(甚至不允许)开发者指定方法可以抛出的异常。
*** 方法可以重载的不同方式是什么？
- 不同的参数类型，不同的参数个数，不同的参数顺序。
*** 事件有返回值吗？
- 没有，事件没有返回类型。
*** 事件是什么？
- 事件是一个基于另一个程序方法执行的动作。
- 事件是被对象或者类使用来通知其他对象发生的事件的委托类型类成员。
- 事件可以通过event关键字来声明。
*** C#和C++的区别是什么？
- C#不支持#include语句。它只用using语句。
- C#中，类定义在最后不使用分号。
- C#不支持多重继承。
- 数据类型的显示转换在C#中比C++中安全很多。
- C#中switch也可用于字符串值。
- 命令行参数数组的行为在C#中和C++中不一样。
*** C#提供拷贝构造函数吗？
- 不，C#不提供拷贝构造函数。
*** 类或者结构可以有多个构造函数吗？
- 可以，类或者结构可以有多个构造函数。C#中构造函数可以被重载。
*** 可以创建接口的实例吗？
- 不可以，你不可以创建接口的实例。
*** 接口可以包含字段吗？
- 不可以，接口不能包含字段。
*** 类可以有静态构造函数吗？
- 是的，类可以有静态构造函数。静态构造函数在任何静态字段被访问之前被立即自动调用，并且通常用来初始化静态类成员。它在第一个实例被创建或者任何静态成员被引用之前自动调用。静态构造函数在实例构造函数之前调用。一个例子如下所示。
*** C#中委托的主要作用是什么？
- 委托主要用于定义回调方法。
*** 投影(Shadowing)和重写(overriding)的区别是什么？
- 重写仅仅重定义实现而投影重定义整个元素。
- 重写派生类可以通过“ME”关键字引用父类元素，但投影中你可以通过”MYBASE”访问父类元素。
*** 事件可以用访问修饰符吗？
- 可以，你可以在事件中用访问修饰符。你可以对事件使用portected关键字，这样只允许继承类访问。你可以使用private修饰事件，仅可以供当前类对象访问。
*** 什么是构造函数和析构函数？
- 构造函数和析构函数是特殊的方法。
- 构造函数和析构函数是每个类的特殊方法。
- 每个类都有自己的构造函数和析构函数，并且在类实例被创建或者销毁时自动调用。
- 每当你访问类的时候，构造函数就初始化所有类成员。当对象不想再需要的时候，析构函数就销毁它们。
*** 我们怎么抑制finalize方法？
- GC.SuppressFinalize()。
*** C#支持可变数目的参数吗？
- 是的，使用params关键字。
- 该参数指定为特定类型的参数列表，例如，int。为了最大的灵活性，类型可以是object。
- 使用这种方法的标准例子是System.console.writeLine()。
*** 哪个方法用来启动一个线程？
- Start。
*** 什么是泛型？
- 泛型帮助我们创建灵活的强类型集合。
- 泛型基本上从数据类型中分离了逻辑，以保持更好的可重用性，更好的可维护性等等。
*** 有哪些不同种类的多态性？
- 有两种类型的多态，它们是：
- 编译时多态性
- 运行时多态性
*** 编译时多态性和运行时多态性的区别是什么？
- 编译时多态性
- 编译时多态性也被称为方法重载。
- 方法重载是指有两个或更多同名但含有不同签名的方法。
- 运行时多态性
- 运行时多态性也被称为方法重写。
- 方法重写是指有两个或更多的同名方法，含有相同的方法签名但对应不同的实现。
*** 哪一个命名空间使XML中多线程编程可行？
- System.Threading。
*** 在C#中可以声明一个静态块吗？
- 不可以，因为C#不支持静态块，但它支持静态方法。
*** 方法可以声明为密封(sealed)吗？
- 在C#中方法不可以声明为sealed。但当我们在派生类重写一个方法的时候，我们可以将重写的方法定义为sealed。通过其sealed，我们就可以避免对该方法的进一步重写。
*** C#中什么是密封类？
- sealed修饰符用来阻止从一个类派生。如果一个密封类被指定为另一个类的基类时会发生编译时错误。
*** 类和接口的区别是什么？
- 抽象类可以实现它的一些成员，但接口不能实现它的任何成员。
- 接口不能有字段，而抽象类可以有字段。
- 接口仅可以从另一个接口继承并且不能继承抽象类，而抽象类可以继承另一个抽象类或另一个接口。
- 类可以同时继承多个接口，而类不能同时继承多个类。
- 抽象类的成员可以定义访问修饰符而接口成员不能定义访问修饰符。
*** 抽象方法和虚方法之间的区别是什么？
- 抽象方法不提供实现，并且强制派生类重写该方法(除非派生类也是个抽象类)，而虚方法可以有实现并且在派生类中重写与否是可选的。因此虚方法可以实现并提供了派生类重写的选择。抽象方法不能提供实现并且强制派生类重写该方法。
*** const和readonly之间有什么区别？
- const声明的字段不能使用static修饰符，而readonly可以使用static修饰符。
- const字段只能在声明时初始化，而readonly可以在声明时或在构造函数中初始化。
- const字段的值在设计时就计算出来了，而readonly的值在运行时计算。
*** C#.NET中使用的命名空间有哪些？
- 命名空间是类型的逻辑分组。
- using System;
- using System.Collections.Generic;
- using System.Windows.Forms;
*** C#有哪些特点？
- C#有以下特点：
  - 简单
  - 类型安全
  - 灵活
  - 面向对象
  - 兼容
  - 持久化
  - 互操作性
  - 有别于传统
*** 继承有哪些不同的类别？
- 在面向对象编程中继承的四种类型：
  - 单继承：包括一个基类和一个派生类。
  - 多层继承(Hierarchical inheritance) :包括一个基类和继承自同一个基类的派生类。
  - 多级继承(Multilevel inheritance):包括从一个派生类派生出来的类。
  - 多重继承(Multiple inheritance):包括多个基类和一个派生类。
*** C#中的修饰符有哪些？
- Abstract
- Sealed
- Virtual
- Const
- Event
- Extern
- Override
- Readonly
- Static
- New
*** C#中访问修饰符的种类有哪些？
- C#中的访问修饰符是：
- public
- protect
- private
- internal
- internal protect
*** Define destructors?定义析构函数？
- 当类对象超出作用域或者被明确删除的时候，析构函数被调用。析构函数，顾名思义是用来销毁由构造函数创建的对象的。正如构造函数，析构函数是一个类成员方法，方法名和类名相同，只是由波浪号开头。
*** 枚举数据类型怎么用？
- 枚举类型是另一种用户定义类型，它提供了一种连接名字为数字的方式，从而提高了代码的可理解性。enum关键字自动地枚举一组词，赋予它们的值为0,1,2并以此类推。
*** 定义构造函数？
- 构造函数是和它的类同名的成员方法。每当创建其关联的类的对象时构造函数都会被调用。它之所以被称为构造函数是因为它构造了类的数据成员的值。
*** 什么是交错数组？
- 交错数组是元素为数组的数组。
- 交错数组元素的维度和大小可以不同。
- 交错数组有时称为“数组的数组”。
*** ref和out参数之间的区别是什么？
- 传递给ref参数的参数必须先初始化。与此相比，对out参数来说，在参数传递给out参数之前不需要显示初始化。
*** C#中using语句怎么用？
- using语句通常是获取资源，执行语句，然后释放该资源。
*** 什么是序列化？
- 序列化(Serialization)是将对象转换为字节流的过程。
- 反序列化(De-serialization)是从字节流创建对象这样相反的过程。
- 序列化/反序列化常用于传递对象。
*** 结构和类之间有什么区别？
- 结构是值类型，类是引用类型。
- 结构不能有构造函数和析构函数。
- 类可以同时有构造函数和析构函数。
- 结构不支持继承，而类支持继承。
*** 类和接口之间有什么区别？
- 类(Class)是对象的逻辑表示。它是数据集合和相关子过程的定义。
- 接口(Interface)也是一个类，包含没有任何方法体定义的方法。类不支持多重继承，但是接口支持。
*** 什么是委托？
- 委托是类型安全，面向对象的函数指针的实现，并且在许多一个组件需要回调到使用它的组件这样的情况下使用。
*** 什么是认证与授权？
- 认证是识别用户的过程。认证是以证书(用户名和密码)来识别/验证用户。
- 授权在认证之后执行。授权是一个基于这些用户身份授予访问权限的过程。
- 授权允许用户对特定资源的访问。
*** “this”可以在静态方法中用吗？
- 不，‘This’不能在静态方法中使用。仅仅只有静态变量/方法可以在静态方法中使用。
*** constants、readonly和static之间的区别是什么？
- Constants: 值不能变。
- Read-only: 值在类的构造函数中仅仅初始化一次。
- Static: 值可以被初始化一次。
*** C#中支持哪些语句类型？
- C#支持的几种不同的语句类型是
  - 块语句
  - 声明语句
  - 表达式语句
  - 选择语句
  - 迭代语句
  - 跳转语句
  - 异常处理语句
  - 检查和未检查
  - Lock语句
*** C#是否可以对内存直接进行操作?
- 这个问题比较难回答，也是个很大的问题。但是可以这样问答。C#是可以对内存进行直接操作的，虽然很少用到指针，但是C#是可以使用指针的，在用的时候需要在前边加unsafe,，在.net中使用了垃圾回收机制(GC)功能，它替代了程序员，不过在C#中不可以直接使用finalize方法，而是在析构函数中调用基类的finalize()方法。
*** Collection和Collections的区别?
- Collection是集合类的上级接口，Collections是针对集合类的一个帮助类，它提供一系列静态方法来实现对各种集合的搜索，排序，线程安全化操作。
*** New有种用法?
- 有3种，第一种是，实例化如：New Class()
- 第二种是，public new 隐藏基类的方法
- 第三种是，在泛型类申明中的任何类型参数都必须有公共的无参构造函数。
- 17，任何把一个Array复制到Arraylist中?
- Foreach (object o in Array), ArrayList.Add (0)
- 等有好多中种方法。自己想。
*** 概述反射和序列化?
- 反射：要给发射下一个定义还是比较难的，这里先说说我的理解。反射提供了封装程序集，模块和类型对象，可以用反射动态地创建类型的实例，将类型绑定到现有对象，或者从现有对象类型里获取类型，然后调用类型的方法或访问字段和属性。
- 序列化：将对象转换为另一种媒介传输的格式过程。如，序列化一个对象，用Http通过internet在客户端和服务器之间传递该对象，在另一端用反序列化从该流中重新得到对象。
*** UDP和TCP连接有和异同?
- TCP是传输控制协议，提供的是面向连接的，是可靠的，字节流服务，当用户和服务器彼此进行数据交互的时候，必须在他们数据交互前要进行TCP连接之后才能传输数据。TCP提供超时重拨，检验数据功能。UDP是用户数据报协议，是一个简单的面向数据报的传输协议，是不可靠的连接。
*** 进程和线程分别该怎么理解?
- 进程是比线程大的程序运行单元，都是由操作系统所体会的系统运行单元，一个程序中至少要有一个进程，有一个进程中，至少要有一个线程，线程的划分尺度要比进程要小，进程拥有独立的内存单元，线程是共享内存，从而极大的提高了程序的运行效率同一个进程中的多个线程可以并发执行。
*** ASP.NET页面之间传递值的几种方式?
- QueryString,session,cookies,application,server.Transfer,respose.redictor.
*** 什么叫应用程序域?什么是托管代码?什么是强类型系统?什么是装箱和拆箱?什么是重载?CTS、CLS和CLR分别作何解释?
- 应用程序域：就是为安全性，可靠性，隔离性，和版本控制，及卸载程序提供的隔离边界。它通常由运行库宿主创建，应用程序域提供了一个更安全，用途更广的处理单元。
- 托管代码：使用CLR编译语言编辑器开发编写的代码就叫托管代码。
- 装箱和拆箱：是把值类型转换为引用类型的过程，是隐式的，相反的过程就是拆箱，是显式的。
- CTS是公共类型系统，CLS是公共语言规范，CLR公共语言运行库。
- 强类型系统：每个变量和对象都必须具有申明类型。
*** ASP.net的身份验证方式有哪些?
- windows,forms,passport
*** 解释一下UDDI、WSDL的意义及其作用?
- UDDI是统一描述集成协议，是一套基于Web的，分布式的，为WEB服务提供的信息注册的实现标准规范，同时为也是为企业本身提供的Web服务注册以让别的企业能够发现并访问的协议标准。提供了基于标准的规范，用于描述和发现服务，还提供了一组基于因特网的实现。
- WSDL这是一个基于XML的描述WEB服务的接口。
*** 什么是SOAP?
- 是简单访问协议。是在分布式环境中，交换信息并实现远程调用的协议。是一个基于XML的协议。使用SOAP，可以不考虑任何传输协议，但通常还是HTTP协议，可以允许任何类型的对象或代码，在任何平台上，以任一种语言相互通信。它是一种轻量级协议。
*** 如何部署一个ASP.net页面?
- vs2003,vs2005里边都有发表机制，vs2003可以发布然后在复制部署。
- Vs2005可以直接部署到对应的位置。
*** 如何理解.net中的垃圾回收机制?
- .NET中的垃圾回收机制是引用程序对内存的回收和释放。当每次用new关键字创建一个对象时，运行库都要从托管堆中为其分配内存，因为空间是有限的，最终垃圾回收机制是要回收不用的内存的。已释放内存，重新使用。
*** C#是一门托管语言，那么是不是说明只要用C#，就能保证不会出现内存泄露和其他资源泄漏？如果不是，在哪些情况下可能会出现泄漏？
- C#不能保证没有资源泄漏。比如如下几种情况可能会造成资源泄漏：
  - （1） 调用Native code，比如用P/Invoke或者调用COM；
  - （2） 读写文件时的，没有及时close stream, 或者ADO.NET连数据库时，没有及时关闭连接，也算资源泄漏？
  - （3）注册事件后没有remove，导致publisher和subscriber的强依 赖，垃圾回收可能会被推迟；
  - （4）.NET还定义了一些方法直接申请非托管内存，比如Marshal.AllocHGlobal和Marshal.AllocCoTaskMem。通过这种方式得到的内存，如果没有及时释放，也会造成内存泄露。
*** 下面的两段C#有哪些不同？
  #+BEGIN_SRC csharp
static void CatchException1() {
    try {
        Function();
    } catch {
        throw;
    }
}
 
static void CatchException2() {
    try {
        Function();
    } catch (Exception e) {
        throw e;
    }
}
  #+END_SRC
- 两个函数的catch都是重新抛出截获的exception，但抛出的exception的call stack是不一样的。对于第一种方法，exception的call stack是从最开始的抛出地点开始的。对于第二种方法，exception的call stack是从CatchException2开始的，最初抛出的地方相关的信息被隐藏了。
*** 运行下图中的C++代码，打印出的结果是什么？
  #+BEGIN_SRC csharp
bool Fun1(char* str) {
    printf("%s\n", str);
    return false;
}
bool Fun2(char* str) {
    printf("%s\n", str);
    return true;
}
int _tmain(int argc, _TCHAR* argv[]) {
    bool res1, res2;
    res1 = (Fun1("a") && Fun2("b")) || (Fun1("c") || Fun2("d"));
    res2 = (Fun1("a") && Fun2("b")) && (Fun1("c") || Fun2("d"));
    return res1 || res2;
}
  #+END_SRC
- 打印出4行，分别是a、c、d、a。
- 在C/C++中，与、或运算是从左到右的顺序执行的。在计算rest1时，先计算Fun1(“a”) && Func2(“b”)。首先Func1(“a”)打印出内容为a的一行。由于Fun1(“a”)返回的是false, 无论Func2(“b”)的返回值是true还是false，Fun1(“a”) && Func2(“b”)的结果都是false。由于Func2(“b”)的结果无关重要，因此Func2(“b”)会略去而不做计算。接下来计算Fun1(“c”) || Func2(“d”)，分别打印出内容c和d的两行。
- 在计算rest2时，首先Func1(“a”)打印出内容为a的一行。由于Func1(“a”)返回false，和前面一样的道理，Func2(“b”)会略去不做计算。由于Fun1(“a”) && Func2(“b”)的结果是false，不管Fun1(“c”) && Func2(“d”)的结果是什么，整个表达式得到的结果都是false，因此Fun1(“c”) && Func2(“d”)都将被忽略。
*** 运行下面的C#代码，打印出来的结果是什么？
  #+BEGIN_SRC csharp
struct Person {
    public string Name;
    public override string ToString() {
        return Name;
    }
}
class Program {
    static void Main(string[] args) {
        ArrayList array = new ArrayList();
        Person jim = new Person() {Name = "Jim"};
        array.Add(jim);
        Person first = (Person)array[0];
        first.Name = "Peter";
        Console.WriteLine(array[0].ToString());
    }
}
  #+END_SRC
- Person的定义是一个struct，因此是一个值类型。在运行到语句Person first = (Person)array[0]的时候，first是array[0]的一个拷贝，first和array[0]不是一个实例。因此修改first对array[0]没有影响。
*** 运行下面的C++代码，打印的结果是什么？
  #+BEGIN_SRC csharp
class Base {
    public:
    void print() { doPrint();}
    private:
    virtual void doPrint() {cout << "Base::doPrint" << endl;}
};
 
class Derived : public Base {
    private:
    virtual void doPrint() {cout << "Derived::doPrint" << endl;}
};
int _tmain(int argc, _TCHAR* argv[]) {
    Base b;
    b.print();
    Derived d;
    d.print();
    return 0;
}
  #+END_SRC
- 输出两行，分别是Base::doPrint和Derived::doPrint。在print中调用doPrint时，doPrint()的写法和this->doPrint()是等价的，因此将根据实际的类型调用对应的doPrint。所以结果是分别调用的是Base::doPrint和Derived::doPrint2。如果感兴趣，可以查看一下汇编代码，就能看出来调用doPrint是从虚函数表中得到函数地址的。
*** 维护数据库的完整性、一致性、你喜欢用触发器还是自写业务逻辑？为什么?
- 尽可能用约束（包括CHECK、主键、唯一键、外键、非空字段）实现，这种方式的效率最好；其次用触发器，这种方式可以保证无论何种业务系统访问数据库都能维持数据库的完整性、一致性；最后再考虑用自写业务逻辑实现，但这种方式效率最低、编程最复杂，当为下下之策。
*** 什么是事务？什么是锁？
- 事务是指一个工作单元，它包含了一组数据操作命令，并且所有的命令作为一个整体一起向系统提交或撤消请求操作，即这组命令要么都执行，要么都不执行。
- 锁是在多用户环境中对数据的访问的限制。SqlServer自动锁定特定记录、字段或文件，防止用户访问，以维护数据安全或防止并发数据操作问题，锁可以保证事务的完整性和并发性。
*** 什么是索引，有什么优点？
- 索引象书的目录类似，索引使数据库程序无需扫描整个表，就可以在其中找到所需要的数据，索引包含了一个表中包含值的列表，其中包含了各个值的行所存储的位置，索引可以是单个或一组列，索引提供的表中数据的逻辑位置，合理划分索引能够大大提高数据库性能。
*** 视图是什么？游标是什么？
- 视图是一种虚拟表，虚拟表具有和物理表相同的功能，可以对虚拟表进行增该查操作;
- 视图通常是一个或多个表的行或列的子集;
- 视图的结果更容易理解（修改视图对基表不影响），获取数据更容易（相比多表查询更方便），限制数据检索（比如需要隐藏某些行或列），维护更方便。
- 游标对查询出来的结果集作为一个单元来有效的处理，游标可以定位在结果集的特定行、从结果集的当前位置检索一行或多行、可以对结果集中当前位置进行修改、
*** 什么是存储过程？有什么优点？
- 存储过程是一组予编译的SQL语句
- 它的优点：
  - 1.允许模块化程序设计，就是说只需要创建一次过程，以后在程序中就可以调用该过程任意次。
  - 2.允许更快执行，如果某操作需要执行大量SQL语句或重复执行，存储过程比SQL语句执行的要快。
  - 3.减少网络流量，例如一个需要数百行的SQL代码的操作有一条执行语句完成，不需要在网络中发送数百行代码。
  - 4.更好的安全机制，对于没有权限执行存储过程的用户，也可授权他们执行存储过程。
*** 什么是触发器？
- 触发器是一种特殊类型的存储过程，出发器主要通过事件触发而被执行的，
- 触发器的优点：
  - 1.强化约束，触发器能够提供比CHECK约束;
  - 2.跟踪变化，触发器可以跟踪数据库内的操作，从而不允许未经允许许可的更新和变化;
  - 3.联级运算，比如某个表上的触发器中包含对另一个表的数据操作，而该操作又导致该表上的触发器被触发
*** 简单介绍下http://ADO.NET和ADO主要有什么改进？ 
- ADO以Recordset存储,而http://ADO.NET则以DataSet表示，http://ADO.NET提供了数据集和数据适配器，有利于实现分布式处理，降低了对数据库服务器资源的消耗。
*** http://ASP.NET与ASP相比，主要有哪些进步？ 
- http://ASP.NET实现了面向对象编程，预编译的服务器端代码而不像ASP那样解释执行提高了性能，代码分离易于管理，可订制和扩展性，功能强大的开发工作，更好的安全机制。 
*** C#中的委托是什么？事件是不是一种委托？
- 委托本质上是一种“方法接口”，它相当于C/C++中的函数指针，当然它比函数指针安全，在C#中通常用于事件处理。事件不是委托，不过由于事件的性质决定了处理它的程序逻辑能访问的参数，因此，在C#中处理事件的逻辑都包装为委托。
*** 列举http://ADO.NET中的五个主要对象，并简单描述 
- Connection连接对象，Command执行命令和存储过程，DataReader向前只读的数据流，DataAdapter适配器，支持增删查询，DataSet数据级对象，相当与内存里的一张或多张表。 
*** 概述三层结构体系 
- 表示层(UI),业务逻辑层(BLL),数据访问层(DAL) 
*** 什么是装箱和拆箱？什么是重载？ 
- 装箱就是把值类型转成引用类型，拆箱相反把引用转换成值类型。
- 重载就是指一个方法名相同,参数个数不相同,返回值可以相同的方法。 
*** 简述WebService 
- WebService服务可以描述为可以在web上部署并可以被任何应用程序或其他服务调用的功能。所谓服务就是系统提供一组接口，并通过接口使用系统提供的功能，WebService服务可以提供任何企业到客户，企业到企业，点对点或部门对部门通讯所需的服务，比如一个公司可以通过网络连接到另一个公司的服务，从而直接传递订购单。
*** DataGrid的Datasouse可以连接什么数据源
- DataTabe，DataView，DataSet，DataViewManager，任何实现IListSource接口的组件，任何实现IList接口的组件
*** 概述反射和序列化
- 反射：公共语言运行库加载器管理应用程序域。这种管理包括将每个程序集加载到相应的应用程序域以及控制每个程序集中类型层次结构的内存布局。程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。
- 序列化：序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。
*** 概述O/R Mapping 的原理
- 利用反射，配置将对象和数据库表映射。
*** 列举http://ADO.NET中的共享类和数据库特定类
- 共享类：DataSet，DataTable，DataRow，DataColumn，DataRealtion，Constraint，DataColumnMapping，DataTableMapping
- 特定类：(x)Connection，(x)Command，(x)CommandBuilder，(x)DataAdapter，(x)DataReader，(x)Parameter，(x)Transaction
*** 详述.NET里class和struct的异同
- 结构与类共享几乎所有相同的语法，但结构比类受到的限制更多：尽管结构的静态字段可以初始化，结构实例字段声明还是不能使用初始值设定项。
- 结构不能声明默认构造函数（没有参数的构造函数）或析构函数。
- 结构的副本由编译器自动创建和销毁，因此不需要使用默认构造函数和析构函数。实际上，编译器通过为所有字段赋予默认值（参见默认值表）来实现默认构造函数。
- 结构不能从类或其他结构继承。
- 结构是值类型 -- 如果从结构创建一个对象并将该对象赋给某个变量，变量则包含结构的全部值。复制包含结构的变量时，将复制所有数据，对新副本所做的任何修改都不会改变旧副本的数据。
- 由于结构不使用引用，因此结构没有标识 -- 具有相同数据的两个值类型实例是无法区分的。C# 中的所有值类型本质上都继承自ValueType，后者继承自 Object。编译器可以在一个称为装箱的过程中将值类型转换为引用类型。
- 结构具有以下特点：
  - 结构是值类型，而类是引用类型。
  - 向方法传递结构时，结构是通过传值方式传递的，而不是作为引用传递的。
  - 与类不同，结构的实例化可以不使用 new 运算符。
  - 结构可以声明构造函数，但它们必须带参数。
  - 一个结构不能从另一个结构或类继承，而且不能作为一个类的基。所有结构都直接继承自 System.ValueType，后者继承自 System.Object。
  - 结构可以实现接口。
  - 在结构中初始化实例字段是错误的。
*** 什么叫应用程序域？什么是托管代码？什么是强类型系统？什么是装箱和拆箱？什么是重载？ CTS、CLS和CLR分别作何解释？
- 应用程序域：应用程序域为安全性、可靠性、版本控制以及卸载程序集提供了隔离边界。应用程序域通常由运行库宿主创建，运行库宿主负责在运行应用程序之前引导公共语言运行库。应用程序域提供了一个更安全、用途更广的处理单元，公共语言运行库可使用该单元提供应用程序之间的隔离。
- 托管代码：使用基于公共语言运行库的语言编译器开发的代码称为托管代码；托管代码具有许多优点，例如：跨语言集成、跨语言异常处理、增强的安全性、版本控制和部署支持、简化的组件交互模型、调试和分析服务等。
- 强类型：C# 是强类型语言；因此每个变量和对象都必须具有声明类型。
- 装箱和拆箱：装箱和拆箱使值类型能够被视为对象。对值类型装箱将把该值类型打包到 Object 引用类型的一个实例中。这使得值类型可以存储于垃圾回收堆中。拆箱将从对象中提取值类型。
- 重载：每个类型成员都有一个唯一的签名。方法签名由方法名称和一个参数列表（方法的参数的顺序和类型）组成。只要签名不同，就可以在一种类型内定义具有相同名称的多种方法。当定义两种或多种具有相同名称的方法时，就称作重载。
- CTS通用类型系统 (common type system) ：一种确定公共语言运行库如何定义、使用和管理类型的规范。
- CLR公共语言运行库：.NET Framework 提供了一个称为公共语言运行库的运行时环境，它运行代码并提供使开发过程更轻松的服务。
- CLS公共语言规范：要和其他对象完全交互，而不管这些对象是以何种语言实现的，对象必须只向调用方公开那些它们必须与之互用的所有语言的通用功能。为此定义了公共语言规范 (CLS)，它是许多应用程序所需的一套基本语言功能。
*** 如何理解委托
- 委托类似于 C++ 函数指针，但它是类型安全的。委托允许将方法作为参数进行传递。委托可用于定义回调方法。委托可以链接在一起；例如，可以对一个事件调用多个方法。方法不需要与委托签名精确匹配。有关更多信息，请参见协变和逆变。C# 2.0 版引入了匿名方法的概念，此类方法允许将代码块作为参数传递，以代替单独定义的方法。
*** http://26.ASP.net的身份验证方式有哪些？
- Windows 身份验证提供程序：提供有关如何将Windows 身份验证与Microsoft Internet 信息服务 (IIS) 身份验证结合使用来确保 The Official Microsoft ASP.NET Site 应用程序安全的信息。
- Forms 身份验证提供程序：提供有关如何使用您自己的代码创建应用程序特定的登录窗体并执行身份验证的信息。使用 Forms 身份验证的一种简便方法是使用 The Official Microsoft ASP.NET Site 成员资格和 The Official Microsoft ASP.NET Site 登录控件，它们一起提供了一种只需少量或无需代码就可以收集、验证和管理用户凭据的方法。
- Passport 身份验证提供程序：提供有关由Microsoft 提供的集中身份验证服务的信息，该服务为成员站点提供单一登录和核心配置
*** 活动目录的作用
- Active Directory存储了有关网络对象的信息，并且让管理员和用户能够轻松地查找和使用这些信息。
- Active Directory使用了一种结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻辑的分层组织。
*** 解释一下UDDI、WSDL的意义及其作用
- UDDI：统一描述、发现和集成协议(UDDI, Universa Description, Discovery and Integration)是一套基于Web的、分布式的、为Web服务提供的信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web服务注册以使得别的企业能够发现的访问协议的实现标准。UDDI 提供了一组基于标准的规范用于描述和发现服务，还提供了一组基于因特网的实现。
- WSDL：WSDL描述Web服务的公共接口。这是一个基于XML的关于如何与Web服务通讯和使用的服务描述；
- 作用： 服务 URL 和命名空间 ：网络服务的类型（可能还包括SOAP 的函数调用，正像我所说过的，WSDL足够自如地去描述网络服务的广泛内容）。有效函数列表，每个函数的参数，每个参数的类型 ，每个函数的返回值及其数据类型。
*** 什么是SOAP？
- SOAP（Simpe Object Access Protoco ）简单对象访问协议是在分散或分布式的环境中交换信息并执行远程过程调用的协议，是一个基于XML的协议。使用SOAP，不用考虑任何特定的传输协议（最常用的还是HTTP协议），可以允许任何类型的对象或代码，在任何平台上，以任何一直语言相互通信。
- SOAP 是一种轻量级协议，用于在分散型、分布式环境中交换结构化信息。 SOAP 利用 XML 技术定义一种可扩展的消息处理框架，它提供了一种可通过多种底层协议进行交换的消息结构。这种框架的设计思想是要独立于任何一种特定的编程模型和其他特定实现的语义。
- SOAP 定义了一种方法以便将 XML 消息从 A 点传送到 B 点。为此，它提供了一种基于 XML且具有以下特性的消息处理框架：1) 可扩展，2) 可通过多种底层网络协议使用，3) 独立于编程模型。 
*** 如何部署一个http://ASP.net页面？
- VS 2005和VS 2003都有发布机制。2003可以发布然后再复制部署。VS2005基本上可以直接部署到对应位置。
*** 如何理解.net中的垃圾回收机制？
- .NETFramework 的垃圾回收器管理应用程序的内存分配和释放。每次您使用 new 运算符创建对象时，运行库都从托管堆为该对象分配内存。只要托管堆中有地址空间可用，运行库就会继续为新对象分配空间。但是，内存不是无限大的。最终，垃圾回收器必须执行回收以释放一些内存。垃圾回收器优化引擎根据正在进行的分配情况确定执行回收的最佳时间。当垃圾回收器执行回收时，它检查托管堆中不再被应用程序使用的对象并执行必要的操作来回收它们占用的内存。 
*** 概述.NET中的GC机制。
- GC的全称是garbage collection，中文名称垃圾回收，是.NET中对内存管理的一种功能。垃圾回收器跟踪并回收托管内存中分配的对象，定期执行垃圾回收以回收分配给没有有效引用的对象的内存。当使用可用内存不能满足内存请求时，GC会自动进行。 
- 在进行垃圾回收时，垃圾回收器会首先搜索内存中的托管对象，然后从托管代码中搜索被引用的对象并标记为有效，接着释放没有被标记为有效的对象并收回内存，最后整理内存将有效对象挪动到一起
- http://33.ASP.NET中常见内置对象？
- Response、Request、Server、Session、Application、Cookie
*** 死锁的必要条件？怎么克服？
- 系统的资源不足，进程的推进的顺序不合适，资源分配不当，一个资源每次只能被一个进程使用，一个资源请求资源时，而此时这个资源已阻塞，对已获得资源不放，进程获得资源时，未使用完前，不能强行剥夺。
*** 简要谈您对微软.NET 构架下remoting和webservice两项技术的理解以及实际中的应用。
- WS主要是可利用HTTP，穿透防火墙。而Remoting可以利用TCP/IP，二进制传送提高效率。
- remoting是.net中用来跨越machine,process, appdomain进行方法调用的技术,对于三成结构的程序，就可以使用remoting技术来构建．它是分布应用的基础技术.相当于以前的DCOM。
- Web Service是一种构建应用程序的普通模型，并能在所有支持internet网通讯的操作系统上实施。Web Service令基于组件的开发和web的结合达到最佳，基于组件的对象模型。
*** 公司要求开发一个继承System.Windows.Forms.ListView类的组件，要求达到以下的特殊功能：点击ListView各列列头时，能按照点击列的每行值进行重排视图中的所有行 (排序的方式如DataGrid相似)。根据您的知识，请简要谈一下您的思路
- 根据点击的列头,包该列的ID取出,按照该ID排序后,在给绑定到ListView中。
*** 给定以下XML文件，完成算法流程图。
  #+BEGIN_SRC xml
<FileSystem> 
　　< DriverC > 
　　　　<Dir DirName=”MSDOS622”> 
    　　　　　　<File FileName =” Redirecting to Command Brand”></File>
    　　　　</Dir> 
    　　　　<File FileName =”MSDOS.SYS” ></File>
    　　　　<File FileName =” IO.SYS”></File> 
    　　</DriverC> 
    </FileSystem> 
  #+END_SRC
- 请画出遍历所有文件名（FileName）的流程图(请使用递归算法)。
  #+BEGIN_SRC csharp
void FindFile(Directory d) { 
    FileOrFolders = d.GetFileOrFolders(); 
    foreach ( FileOrFolder fof in FileOrFolders) {
        if (fof  is  File) {
            // You Found a file; 
        } else if (fof is Directory) 
            FindFile(fof);                       　　
        }
    }
}
  #+END_SRC
*** http://109.ADO.NET相对于ADO等主要有什么改进？
- 1:http://ado.net不依赖于ole db提供程序,而是使用.net托管提供的程序,
- 2:不使用com
- 3:不在支持动态游标和服务器端游 
- 4:,可以断开connection而保留当前数据集可用
- 5:强类型转换
- 6:xml支持
*** 你觉得ASP.NET 2.0（VS2005）和你以前使用的开发工具（.Net 1.0或其他）有什么最大的区别？你在以前的平台上使用的哪些开发思想（pattern/ architecture）可以移植到ASP.NET2.0上 (或者已经内嵌在ASP.NET 2.0中)
- 1、ASP.NET2.0把一些代码进行了封装打包,所以相比1.0相同功能减少了很多代码。
- 2、同时支持代码分离和页面嵌入服务器端代码两种模式,以前1.0版本,.NET提示帮助只有在分离的代码文件,无 法 在页面嵌入服务器端代码获得帮助提示。
- 3、代码和设计界面切换的时候,2.0支持光标定位.这个我比较喜欢。
- 4、在绑定数据,做表的分页.UPDATE,DELETE,等操作都可以可视化操作,方便了初学者。
- 5、在http://ASP.NET中增加了40多个新的控件,减少了工作量。
*** 重载与覆盖的区别？
- 1、方法的覆盖是子类和父类之间的关系，是垂直关系；方法的重载是同一个类中方法之间的关系，是水平关系。
- 2、覆盖只能由一个方法，或只能由一对方法产生关系；方法的重载是多个方法之间的关系。
- 3、覆盖要求参数列表相同；重载要求参数列表不同。
- 4、覆盖关系中，调用那个方法体，是根据对象的类型（对像对应存储空间类型）来决定；重载关系，是根据调用时的实参表与形参表来选择方法体的。
*** 什么是WSE？目前最新的版本是多少？
- WSE (WebService Extension)包来提供最新的WEB服务安全保证，最新版本2.0。
*** a=10,b=15，在不用第三方变量的前提下，把a,b的值互换
- a=a+b;b=a-b;a=a-b;
*** 还有变态要求，需要代码最短呢。有两个结果：
- 1) a^=b^(b^=a^b); // 13个字节
- 2) a=b+(b=a)*0; // 11个字节
*** 请简述面向对象的多态的特性及意义！
- 面向对象的编程使用了派生继承以及虚函数机制.一个本来指向基类的对象指针可以指向其派生类的.并访问从基类继承而来的成员变量和函数.而虚函数是专门为这个特性设计的,这个函数在每个基类的派生类中都是同一个名字,但函数体却并不一定相同,派生类往往为实现自己的功能而修改这个虚函数.这样用一个指针就能够实现对多种不同的派生类的访问, 并实现其派生类的特定功能(代码 )
*** session喜欢丢值且占内存，Cookis不安全，请问用什么办法代替这两种原始的方法
- 用ViewState，stateserver
*** 对数据的并发采用什么办法进行处理较好。
- 可以控制连接池的连接数量,条件好的话可以用负载平衡
- http://123.ADO.NET处理数据并发的方法和步骤?
- 开放式并发，没有用到数据库的锁，而依靠SQL语句判断数据是否已经变化了。
-  步骤：通常使用VS提供的工具生成SQL语句，工具生成的结果实在不符合要求，才手工写SQL语句。
*** 动态创建的控件PostBack后是否可以保存下来,为什么? 
- http://ASP.NET框架不会为你保存，但可以手工保存到ViewState
*** 要点：1. 联动效果，运行代码只要执行Cat.Cryed()方法。2. 对老鼠和主人进行抽象
- 评分标准: 
  - <1>.构造出Cat、Mouse、Master三个类，并能使程序运行(2分)
  - <2>从Mouse和Master中提取抽象（5分）
  - <3>联动效应，只要执行Cat.Cryed()就可以使老鼠逃跑，主人惊醒。(3分)
  #+BEGIN_SRC csharp
public interface Observer {
    void Response();           // 观察者的响应，如是老鼠见到猫的反映
}
public interface Subject {
    void AimAt(Observer obs);  // 针对哪些观察者，这里指猫的要扑捉的对象---老鼠
}
public class Mouse : Observer {
    private string name;
    public Mouse(string name, Subject subj) {           
        this.name = name;
        subj.AimAt(this);
    }
    public void Response() {
        Console.WriteLine(name + " attempt to escape!");
    }
}
public class Master : Observer {   
    public Master(Subject subj) {           
        subj.AimAt(this);
    }
    public void Response() {
        Console.WriteLine("Host waken!");
    }  
}
public class Cat : Subject {
    private ArrayList observers;
    public Cat() {   
        this.observers = new ArrayList();
    }
    public void AimAt(Observer obs) {
        this.observers.Add(obs);
    }
    public void Cry() {
        Console.WriteLine("Cat cryed!");
        foreach (Observer obs in this.observers) {
            obs.Response();
        }
    }
}
class MainClass {       
    static void Main(string[] args) {
        Cat cat = new Cat();
        Mouse mouse1 = new Mouse("mouse1", cat);
        Mouse mouse2 = new Mouse("mouse2", cat);
        Master master = new Master(cat);
        cat.Cry();
    }
}

//---------------------------------------------------------------------------------------------
// 设计方法二: 使用event -- delegate设计..
//---------------------------------------------------------------------------------------------
public delegate void SubEventHandler();
public abstract class Subject {
    public event SubEventHandler SubEvent;
    protected void FireAway() {
        if (this.SubEvent != null)
            this.SubEvent();
    }   
}
public class Cat : Subject {  
    public void Cry() {
        Console.WriteLine("cat cryed.");
        this.FireAway();
    }
}
public abstract class Observer {
    public Observer(Subject sub) {
        sub.SubEvent += new SubEventHandler(Response);
    }
    public abstract void Response();    
}
public class Mouse : Observer {
    private string name;
    public Mouse(string name, Subject sub) : base(sub) {   
        this.name = name;
    }
    public override void Response() {
        Console.WriteLine(name + " attempt to escape!");
    }
}
public class Master : Observer {
    public Master(Subject sub) : base(sub){}
    public override void Response() {
        Console.WriteLine("host waken");
    }
}
class Class1 {
    static void Main(string[] args) {
        Cat cat = new Cat();
        Mouse mouse1 = new Mouse("mouse1", cat);
        Mouse mouse2 = new Mouse("mouse2", cat);
        Master master = new Master(cat);
        cat.Cry();
    }
}
  #+END_SRC