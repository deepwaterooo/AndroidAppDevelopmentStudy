#+latex_class: cn-article
#+title: 安卓中的线程、异步任务、Service与IntentService
#+author: deepwaterooo

* Java 创建线程的三种方式总结
- https://blog.csdn.net/u011578734/article/details/110523825
** 继承 Thread 类
   #+BEGIN_SRC java
class MyThread extends Thread {
    @Override
        public void run() {
        super.run();
    }
}
private void testThread(){
    Thread thread = new MyThread();
    thread.start();
}
   #+END_SRC
- 缺点: Java 的单继承限制，想通过 Thread 实现多线程，就只能继承 Thread 类，不可继承其他类。
** 实现 Runnable 接口
- 如果自己的类已经继承了其他类，这时就只能通过实现 Runnable 接口来实现多线程了。
- 不过，继承 Runnable 接口后，想要启动线程，需要把该类的对象作为参数，传递给 Thread 的构造函数，并使用 Thread 类的实例方法 start 来启动。
#+BEGIN_SRC java
public class TestThread extends A implements Runnable {
    public void run() {
        // todo
    }
}
// 启动线程
TestThread testThread = new TestThread();
Thread thread = new Thread(testThread);
thread.start();
#+END_SRC
- Thread 内部的 run 方法我们可以看到它的实现原理：
#+BEGIN_SRC java
private Runnable target;
public void run() {
    if (target != null) {
        target.run();
    }
}
#+END_SRC
- target 是我们传递进来的 Runnable 对象，当线程执行时，线程的 run 方法会直接调用 Runnable 对象的 run 方法。
** 实现 Callable 接口
- 如果想要执行的线程有返回，怎么处理呢？这时应该使用 Callable 接口了，与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。
#+BEGIN_SRC java
public class MyCallable implements Callable<Integer> {
    public Integer call() {
        return 111;
    }
}
public static void main(String[] args) throws ExecutionException, InterruptedException {
    MyCallable mc = new MyCallable();
    FutureTask<Integer> ft = new FutureTask<>(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
#+END_SRC
** 比较
- 这几种线程创建方式中，实现接口会更好一些，因为：
  - Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口。
  - 类可能只要求可执行就行，继承整个 Thread 类开销过大。
  - 另外，如果需要有返回值时，使用 Callable 接口是适合的。


* Handler的使用
- Android中，不允许应用程序在子线程中更新UI，UI的处理必须在UI线程中进行，这样Android定制了一套完善的线程间通信机制——Handler通信机制。Handler作为Android线程通信方式，高频率的出现在我们的日常开发工作中，我们常用的场景包括：使用异步线程进行网络通信、后台任务处理等，Handler则负责异步线程与UI线程（主线程）之间的交互。
- Android为了确保UI操作的线程安全，规定所有的UI操作都必须在主线程（UI线程）中执行，决定了UI线程中不能进行耗时任务，在开发过程中，需要将网络，IO等耗时任务放在工作线程中执行，工作线程中执行完成后需要在UI线程中进行刷新，因此就有了Handler进程内线程通信机制，当然Handler并不是只能用在UI线程与工作线程间的切换，Android中任何线程间通信都可以使用Handler机制。
** UI线程中使用Handler
- UI线程中使用Handler非常简单，因为框架已经帮我们初始化好了Looper,只需要创建一个Handler对象即可，之后便可以直接使用这个Handler实例向UI线程发消息（子线程--->UI线程）
#+BEGIN_SRC java
    private Handler handler = new Handler(){
        @Override
        public void handleMessage(@NonNull Message msg) {
            super.handleMessage(msg);
            //处理消息
        }
    };
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_six);
    }
#+END_SRC
- 这种方式会导致 _内存泄露_ 。
- Handler 内存泄漏的两个原因: 
  - Java 中非静态内部类和匿名内部类会持有外部类的引用
#+BEGIN_SRC java
// 这是一个外部类 Handler 不会持有外部类引用
// 显然 handleMessage 没地方写了
Handler handler = new Handler();

// 重写 handleMessage 后将得到一个内部类 Handler，以内 handleMessage 是在外部类中实现的
// 它持有外部类引用，可能会引起内存泄漏
Handler handler = new Handler() { // 这是重写了handleMessage后的内部类Handler
  @Override public void handleMessage(Message msg) {
        super.handleMessage(msg);
        switch (msg.what) {
            case 0:
              MLog.i(msg.obj);
              break;
            case 1:
              break;
            default:

        }
    }
};

// 这里 Handler 是一个匿名类，但不是内部类
// Runnable 是一个匿名内部类，持有外部类引用，可能会引起内存泄漏
new Handler().post(new Runnable() {
    @Override public void run() {
      // ...
    }
});
#+END_SRC 
  - Handler 的生命周期比外部类长
  - 我们通过Handler发送消息，在Message对象中会持有当前Handler对象的引用，在Java中非静态成员类、内部类、匿名类会持有外部对象的引用（这里在源码中有提到），而Looper是线程局部变量，其生命周期与UI线程相同，Looper持有MessageQueue的引用，MessageQueue持有Message的引用，当通过Handler发送一个延时消息未处理之前用户已经离开当前Activity，会导致Activity不能及时释放而内存泄漏。
- 分析
  - 非静态的内部 Handler 子类、匿名 Handler 子类会持有外部类的引用(Activity)，而 Handler 可能会因为要等待处理耗时操作导致存活时间超过 Activity，或者消息队列中存在未被 Looper 处理的 Message ，而 Message 会持有 Handler 的引用。于是，在 Activity 退出时，其引用还是被 Handler 持有，导致 Activity 无法被及时回收，造成内存泄露。
  - 非静态的内部 Runnable 子类、匿名 Runnable 子类 post 到任意 Handler 上时，Runnable 其实是 Massage中的 Callback，持有 Message 引用，如果这个 Massage 在消息队列还没有被处理，那么就会造成 Runnable 一直持有外部类的引用而造成内存泄露。
*** 解决思路
- 通过静态内部类或者外部类来声明 Handler 和 Runnable，然后使用弱引用来拿到外部类的变量。
- 在 Activity/Fragment 销毁的时候请空 MessageQueue 中的消息。
**** 官方推荐的一种
    #+BEGIN_SRC java
private Handler handler = new Handler(new Handler.Callback() {
        @Override
        public boolean handleMessage(@NonNull Message msg) {
            switch (msg.what){
            case 1:
            //处理子线程发过来的消息
            Toast.makeText(SixActivity.this,(String)msg.obj,Toast.LENGTH_LONG).show();
            Log.d("aa",(String) msg.obj);
            break;

            }
            return false;
        }
    });
    #+END_SRC
**** 静态内部类
- 下面的例子实现了子线程（执行run()耗时函数的线程）向主线程发送消息
  #+BEGIN_SRC java
public static final int LOAD_COM = 1; // 加载任务的id标志

private Handler mHandler = new MyHandler(MainActivity.this); // 在MainActivity中，创建了一个Handler对象。

private static class MyHandler extends Handler { // MainActivity中的静态static内部类
    private final WeakReference<MainActivity> mActivity; // 持有当前MainActivity的WeakReference
    private MyHandler(MainActivity activity) {
        this.mActivity = new WeakReference(activity);
    }
    @Override public void handleMessage(@NonNull Message msg) { // ui线程中，负责消息返回的处理逻辑
        super.handleMessage(msg);      // UI线程中，Handler对象的handleMessage方法负责处理消息的返回
        switch (msg.what){
        case LOAD_COM:
            Log.d("TestHandler", msg.obj.toString());
            MainActivity mainActivity = mActivity.get();
            if (mainActivity != null){
                mainActivity.mTextView.setText(msg.obj.toString());
            }
            break;
        }
    }
};
@Override public void onClick(View v) {
    switch (v.getId()) {
    case R.id.start_load: // 当按钮start_load点击时，启动一个后台线程，模拟一个后台加载过程（线程休眠1秒）
        new Thread() {
            @Override
            public void run() { // 后台线程中执行的逻辑：这里代码写定义在主线程MainActivity中，但实际run()函数的真正执行是执行在子线程中
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
// 子线程发送消息
                // Message message = new Message();//可以使用new Message来创建消息，但是一般不这样使用？
                Message message = Message.obtain(); // 后台任务完成后，使用Handler对象的sendMessage方法发送消息（一个Messaage对象）给UI线程
                message.what = LOAD_COM;
                message.obj = "我是子线程消息";
                mHandler.sendMessage(message); // 从后台线程中，发送消息给UI线程
            }
        }.start();
        break;
    }
}
  #+END_SRC
- 主线程给子线程发送消息（UI线程--->子线程）
  #+BEGIN_SRC java
public class SixActivity extends AppCompatActivity {
    private Handler handler;
    private Button btn;
    @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_six);
        new MyOneThread().start();     // 子线程创建方式
        btn= findViewById(R.id.dian);
        btn.setOnClickListener(new View.OnClickListener() {
                @Override
                    public void onClick(View v) {
                    Message message=Message.obtain();
                    message.what=1;
                    message.obj="我是主线程的消息发送给子线程";
                    handler.sendMessage(message); // 封装完数据发送给子线程
                }
            });
    }
    class MyOneThread extends Thread{
        @Override public void run() {
            // 在子线程中处理消息,子线程中处理消息，没有默认的Loop
            // 由于只有主线程成才默认的Looper.prepare(), Looper.loop();
            Looper.prepare(); // 创建Looper: 如果不添加会报错
            handler = new Handler() { // 在子线程中创建消息Handler
                @Override
                public void handleMessage(@NonNull Message msg) {
                    switch (msg.what){
                    case 1:
                    Log.d("aa",(String) msg.obj);
                    break;
                    }
                }
            };
            // 循环读取messageQueue
            Looper.loop(); // 如果不添加读取不到消息
        }
    }
}
  #+END_SRC
- 子线程中，也可以使用这个方式来获取Looper
#+BEGIN_SRC java
handler = new Handler(Looper.getMainLooper()) {
    @Override
    public void handleMessage(@NonNull Message msg) {
        switch (msg.what) {
        case 1:
        Log.d("aa",(String) msg.obj);
        break;
        }
    }
};
#+END_SRC
- 子线程发送消息到子线程（子线程----->子线程）
#+BEGIN_SRC java
btn.setOnClickListener(new View.OnClickListener() {
        @Override public void onClick(View v) {
            new Thread(new Runnable() {
                    @Override
                    public void run() {
                        Message message = Message.obtain();
                        message.obj = "我是子线程发送到子线消息";
                        message.what = 1;
                        handler.sendMessage(message); // 发送消息的子线程也是有handler的
                    }
                }).start();
        }
    });
class MyOneThread extends Thread {
    @Override public void run() {
        //在子线程中处理消息,子线程中处理消息，没有默认的Loop
        //由于只有主线程成才默认的Looper.prepare(), Looper.loop();
        // Looper.prepare(); // 创建Looper： 效果一样，换下面的方式
        handler = new Handler(Looper.getMainLooper()){
            @Override
            public void handleMessage(@NonNull Message msg) {
                switch (msg.what){
                case 1:
                Log.d("aa",(String) msg.obj);
                break;
                }
            }
        };
        // Looper.loop(); // 循环读取messageQueue
    }
}
#+END_SRC
- 使用Handler.post()直接更新ui
#+BEGIN_SRC java
private Handler handler=new Handler();
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_six);
    btn = findViewById(R.id.dian);
    new Thread(new Runnable() {
            @Override
            public void run() {
                // Message message=Message.obtain();
                // message.obj="我是子线程静态消息";
                // message.what=1;
                // handler.sendMessage(message);
                handler.post(new Runnable() {
                        @Override
                        public void run() {
                            Log.d("aa","直接更新Ui");
                            btn.setText("我是更新的消息");
                        }
                    });
            }
        }).start();
}
#+END_SRC
- post和sendMessage本质上是没有区别的，只是实际用法中有一点差别
- post也没有独特的作用，post本质上还是用sendMessage实现的，post只是一中更方便的用法而已
  
[[./pic/handler.png]]

** 关于安卓handler的面试小问题
*** Looper和Handler一定要处于一个线程吗？子线程中可以用MainLooper去创建Handler吗？
- （1）子线程中
#+BEGIN_SRC java
Handler handler = new Handler(Looper.getMainLooper()); // 此时,子线程的handler与Looper.getMainLooper()主线程Looper, 两者就不在一个线程中
#+END_SRC
  - 此时两者就不在一个线程中
- （2）子线程中可以用MainLooper去创建Handler.
*** Handler的post方法发送的是同步消息吗？可以发送异步消息吗？
- 用户层面发送的都是同步消息
- 不能发送异步消息
- 异步消息只能由系统发送。
*** Handler.post的逻辑在哪个线程执行的，是由Looper所在线程还是Handler所在线程决定的？
- 由Looper所在线程决定的
- 最终逻辑是在Looper.loop()方法中，从MsgQueue中拿出msg，并且执行其逻辑，这是在Looper中执行的，因此是由Looper所在的线程决定的。
*** Handler构造方法中通过Looper.myLooper();是如何获取到当前线程的Looper的？
- myLooper()内部使用ThreadLocal实现，因此能够获取各个线程自己的Looper
*** MessageQueue(消息队列)
- 消息队列被封装到Looper里面了，我们一般不会直接与MessageQueue打交道。我们只需要记住它是用来存放消息的单链表结构。队列的顺序由Message的next属性来维护。MessageQueue是整个Handler机制的核心，里面涉及很多特性我们这里都不展开讲述(比如消息屏障机制)。
** handler工作原理总结： Handler的工作原理
- Handler的消息传递机制涉及到四个部分：
  - 1. Message：线程间传递的对象。
  - 2. MessageQueue： 消息队列，用来存放Handler发布的Message.
  - 3. Handler：负责将Message插入到MessageQueue中以及对MessageQueue中的Message进行处理。
  - 4. Looper：负责从MessageQueue中取出Message，并交给Handler.
- 其中：
  -  Looper存储在ThreadLocal中，Looper在创建时会同时创建MessageQueue，作为其成员对象.因此Looper和MessageQueue是属于创建者线程的，各线程之间的Looper和MessageQueue相互独立。
  - Handler在创建时会从当前线程的ThreadLocal中取得Looper.
  - 发送消息时，在发送线程中调用接收线程中的Handler的sendMessage方法，过程中，Handler会将自身赋予到Message的target中，并将Message插入到Handler对应的MessageQueue中。
  - 而接收线程中的Looper在循环过程中会取出这个Message，通过Message.target取出接收线程中的Handler，并将消息交Handler对象处理。由此实现了跨线程通信。
  - 要注意的是：线程与Looper和MessageQueue是一对一的关系，即一个线程只维护一个Looper和一个MessageQueue;而线程与Handler的关系是一对多，即一个线程可以有很多Handler，一个Handler只对应一个线程，这也是为什么Handler在发送消息时，为什么要将自身赋给Message.target的原因。
- Handler内存泄露的解决方法
  - 方法1：通过程序逻辑进行保护。
    - 关闭Activity的时候停掉后台线程，这样就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。
    - 如果你的Handler是被delay的Message持有了引用，那么在Activity销毁前使用相应的Handler的removeCallbacksAndMessages()方法，把消息对象从消息队列移除就行了。
  - 方法2：将Handler声明为静态类
    - 静态类不持有外部类的对象，这样即使Handler在运行，Activity也可以被回收。
    - 由于静态类的Handler不再持有外部类对象，如果要操作Activity需要增加一个Activity的弱引用。
- 优点：
  - 操作简单，无学习成本。
- 缺点：
  - 代码规范性较差，不易维护。
  - 每次操作都会开启一个匿名线程，系统开销较大。

* AsyncTask
- 较为轻量级的异步类，封装了 FutureTask 的线程池、ArrayDeque 和 Handler 进行调度。AsyncTask 主要用于 _后台与界面持续交互_
- 我们来看看 AsyncTask 这个抽象类的定义，当我们定义一个类来继承 AsyncTask 这个类的时候，我们需要为其指定3个泛型参数：
#+BEGIN_SRC java
AsyncTask　<Params, Progress, Result>
#+END_SRC
  - Params: 这个泛型指定的是我们传递给异步任务执行时的参数的类型。
  - Progress: 这个泛型指定的是我们的异步任务在执行的时候将执行的进度返回给UI线程的参数的类型。
  - Result: 这个泛型指定的异步任务执行完后返回给UI线程的结果的类型。
- 我们在定义一个类继承 AsyncTask 类的时候，必须要指定好这三个泛型的类型，如果都不指定的话，则都将其写成 void。
- 我们来看一个官方给的例子：
#+BEGIN_SRC java
private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {
     protected Long doInBackground(URL... urls) {
         int count = urls.length;
         long totalSize = 0;
         for (int i = 0; i < count; i++) {
             totalSize += Downloader.downloadFile(urls[i]);
             publishProgress((int) ((i / (float) count) * 100));
             // Escape early if cancel() is called
             if (isCancelled()) break;
         }
         return totalSize;
     }
     protected void onProgressUpdate(Integer... progress) {
         setProgressPercent(progress[0]);
     }
     protected void onPostExecute(Long result) {
         showDialog("Downloaded " + result + " bytes");
     }
}
#+END_SRC
- 使用时只需要集成 AsyncTask，创建对象并调用 execute 执行即可：
#+BEGIN_SRC java
new DownloadFilesTask().execute(url1, url2, url3);
#+END_SRC
- doInBackground(Params…) 方法里执行耗时逻辑，然后在 onPostExecute(Result) 中将结果更新回UI组件
- AsyncTask 的几个主要方法中，doInBackground 方法运行在子线程，execute、onPreExecute、onProgressUpdate、onPostExecute 这几个方法都是在 UI 线程运行的。
** 使用 AsyncTask 的注意事项
- AsyncTask 的实例必须在 UI Thread 中创建。
- 只能在 UI 线程中调用 AsyncTask 的 execute 方法。
- AsyncTask 被重写的四个方法是系统自动调用的,不应手动调用。
- 每个AsyncTask 只能被执行一次，多次执行会引发异常。
- AsyncTask 的四个方法，只有 doInBackground 方法是运行在其他线程中,其他三个方法都运行在 UI 线程中，也就说其他三个方法都可以进行 UI 的更新操作。
- AsyncTask 默认是串行执行，如果需要并行执行，使用接口 executeOnExecutor 方法。
** 优点：
- 结构清晰，使用简单，适合后台任务的交互。
- 异步线程的优先级已经被默认设置成了：THREAD_PRIORITY_BACKGROUND，不会与 UI 线程抢占资源。
** 缺点：
- 结构略复杂，代码较多。
- 每个 AsyncTask 只能被执行一次，多次调用会发生异常。
- AsyncTask 在整个 Android 系统中维护一个线程池，有可能被其他进程的任务抢占而降低效率。

* HandlerThread
- HandlerThread 是一个自带 Looper 消息循环的线程类。处理异步任务的方式和 Thread + Looper + Handler 方式相同。
** 优点：
- 简单，内部实现了普通线程的 Looper 消息循环。
- 可以串行执行多个任务。
- 内部拥有自己的消息队列，不会阻塞 UI 线程。
** 缺点：
- 没有结果返回接口，需要自行处理。
- 消息过多时，容易造成阻塞。
- 只有一个线程处理，效率较低。
- 线程优先级默认优先级为 THREAD_PRIORITY_DEFAULT，容易和 UI 线程抢占资源。

*  IntentService
- IntentService 继承自 Service 类，用于启动一个异步服务任务，它的内部是通过 HandlerThread 来实现异步处理任务的。
- 我们来看下 IntentService 的主要方法：
#+BEGIN_SRC java
// mServiceLooper;
// mServiceHandler;
@Override
public void onCreate() {
    // TODO: It would be nice to have an option to hold a partial wakelock during processing,
    // and to have a static startService(Context, Intent) method that would launch the service & hand off a wakelock.
    super.onCreate();
    HandlerThread thread = new HandlerThread("IntentService [" + mName + "]");
    thread.start();
    mServiceLooper = thread.getLooper();
    mServiceHandler = new ServiceHandler(mServiceLooper);
}
@Override
public void onStart(@Nullable Intent intent, int startId) {
    Message msg = mServiceHandler.obtainMessage();
    msg.arg1 = startId;
    msg.obj = intent;
    mServiceHandler.sendMessage(msg);
}
private final class ServiceHandler extends Handler {
    public ServiceHandler(Looper looper) {
        super(looper);
    }
    @Override
        public void handleMessage(Message msg) {
        onHandleIntent((Intent)msg.obj);
        stopSelf(msg.arg1);
    }
}
#+END_SRC
** 优点：
- 只需要继承 IntentService，就可以在 onHandlerIntent 方法中异步处理 Intent 类型任务了。
- 任务结束后 IntentService 会自行停止，无需手动调用 stopService。
- 可以执行处理多个 Intent 请求，顺序执行多任务。
- IntentService 是继承自 Service，具有后台 Service 的优先级。
** 缺点：
- 需要启动服务来执行异步任务，不适合简单任务处理。
- 异步任务是由 HandlerThread 实现的，只能单线程、顺序处理任务。
- 没有返回 UI 线程的接口。

* 使用线程池来处理异步任务
- 利用 Executors 的静态方法 newCachedThreadPool()、newFixedThreadPool()、newSingleThreadExecutor() 及重载形式实例化 ExecutorService 接口即得到线程池对象。
- 动态线程池 newCachedThreadPool()：根据需求创建新线程的，需求多时，创建的就多，需求少时，JVM 自己会慢慢的释放掉多余的线程。
- 固定数量的线程池 newFixedThreadPool()：内部有个任务阻塞队列，假设线程池里有2个线程，提交了4个任务，那么后两个任务就放在任务阻塞队列了，即使前2个任务 sleep 或者堵塞了，也不会执行后两个任务，除非前2个任务有执行完的。
- 单线程 newSingleThreadExecutor()：单线程的线程池，这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去。
** 优点：
- 线程的创建和销毁由线程池来维护，实现了线程的复用，从而减少了线程创建和销毁的开销。
- 适合执行大量异步任务，提高性能。
- 灵活性高，可以自由控制线程数量。
- 扩展性好，可以根据实际需要进行扩展。
** 缺点：
- 代码略显复杂。
- 线程池本身对系统资源有一定消耗。
- 当线程数过多时，线程之间的切换成本会有很大开销，从而使性能严重下降。
- 每个线程都会耗费至少 1040KB 内存，线程池的线程数量需要控制在一定范围内。
- 线程的优先级具有继承性，如果在 UI 线程中创建线程池，线程的默认优先级会和 UI 线程相同，从而对 UI 线程使用资源进行抢占。

