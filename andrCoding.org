#+latex_class: book
#+title: Android Coding Assessment Test Prepare
#+author: deepwaterooo

* Activity生命周期探讨
- https://www.jianshu.com/p/1b3f829810a1

  [[./pic/activityLifeCycle.png]]
** Activity生命周期相关函数说明
- (1) onCreate()是activity正在被创建，也就是说此时的UI操作不会更新UI，比如setText()操作，所以此时在子线程调用setText()不会报线程错误。详解可见Android子线程更新View的探索,在这个方法内我们可以做一些初始化工作。
- (2) onRestart()需要注意的是：activity正在重新启动，一般情况下，activity从不可见状态到可见状态，onRestart()才会被调用，但是一定要注意的是一般来说这是用户行为导致activity不可见的时候，此时变为可见的时候才会调用onRestart(),这里所说的用户行为就是用户按home键，或者进入“新”的activity。这样的操作会使activity先执行onPause(),后执行onStop()，这样回到这个activity会调用onRestart()。为什么我这里强调说用户行为导致的不可见状态，等下我会说。。。。
- (3) onStart()的时候，activity才可见，但是没有出现在前台，无法与用户交互
- (4) onResume()的时候，activity已经可见，并且出现在前台开始活动，与onStart()相比，activity都已经可见，但是onStart()的时候activity还在后台，onResume()才显示在前台
- (5) onPause()主要注意的是：此时的activity正在被停止，接下来马上调用onStop()。特殊情况下快速回到该activity，onStop()不会执行，会去执行onResume()。
  - _一般在这个生命周期内做存储数据、停止动画工作，但不能太耗时。_
  - 为什么特殊强调呢，因为该activity的onPause()执行完了，才回去执行新的activity的onResume()，一旦耗时，必然会拖慢新的activity的显示。
- (6) onStop()：此时的activity即将停止。在这里可以做稍微重量级的操作，同样也不能耗时。
- (7) onDestroy()：此时的activity即将被回收，在这里会做一些回收工作和最终资源释放。
*** 在这里着重讲解一下onStart与onResume，onPause与onStop区别
onStart与onResume两种状态虽都可见，但onStart时还无法与用户交互，并未获得焦点。onResume时页面已获得焦点，可与用户交互；onPause时页面还在前台，只不过页面已失去焦点，无法与用户交互了，onStop时已不可见了。
    
    [[./pic/states.png]]

activity四个状态所在的生命周期：

- Running状态：一个新的Activity启动入栈后，它在屏幕最前端，处于栈的最顶端，此时它处于可见并可和用户交互的激活状态。
- Paused状态：依旧在用户可见状态，但是界面焦点已经失去，此Activity无法与用户进行交互。当Activity被另一个透明或者Dialog样式的Activity覆盖时的状态。此时它依然与窗口管理器保持连接，系统继续维护其内部状态，它仍然可见，但它已经失去了焦点，故不可与用户交互。所以就解释为什么启动一个dialogActivity或者透明Activity时，原Activity只执行了onPause生命周期，并未执行onStop
- Stopped状态：用户看不到当前界面,也无法与用户进行交互 完全被覆盖。当Activity不可见时，Activity处于Stopped状态。当Activity处于此状态时，一定要保存当前数据和当前的UI状态，否则一旦Activity退出或关闭时，当前的数据和UI状态就丢失了。
- Killed状态：Activity被杀掉以后或者被启动以前，处于Killed状态。这是Activity已从Activity堆栈中移除，需要重新启动才可以显示和使用。
- 4种状态中，Running状态和Paused状态是可见的，Stopped状态和Killed状态时不可见的。
  
[[./pic/func.png]]

** Activity注意事项
- Activity中所有和状态相关的回调函数：

[[./pic/one.png]]

[[./pic/two.png]]

  [[./pic/activityLifecyleCallbacks.png]]

- 在这里我会特别提出一个point，就是异常情况下activity被杀死，而后被重新创建的情况。
  
  #+caption: 异常情况下activity的重建过程
  [[./pic/recreateActivity.png]]

- 这张图非常重要，可以帮我们解决异常情况下activity如何正常回复的问题
- 当系统停止activity时，它会调用onSaveInstanceState()(过程1)，如果activity被销毁了，但是需要创建同样的实例，系统会把过程1中的状态数据传给onCreate()和onRestoreInstanceState()，所以我们要在onSaveInstanceState()内做保存参数的动作，在onRestoreInstanceState()做获取参数的动作。
  #+BEGIN_SRC java
// Save Activity State
static final String STATE_SCORE = "playerScore";
static final String STATE_LEVEL = "playerLevel";
@Override
public void onSaveInstanceState(Bundle savedInstanceState) {
    savedInstanceState.putInt(STATE_SCORE, mCurrentScore); // Save the user's current game state
    savedInstanceState.putInt(STATE_LEVEL, mCurrentLevel);
    super.onSaveInstanceState(savedInstanceState); // Always call the superclass so it can save the view hierarchy state
}
  #+END_SRC
- 获取参数操作：
  #+BEGIN_SRC java
// onCreate() 方法
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState); // Always call the superclass first
    if (savedInstanceState != null) { // Check whether we're recreating a previously destroyed instance
        mCurrentScore = savedInstanceState.getInt(STATE_SCORE); // Restore value of members from saved state
        mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);
    } else  // Probably initialize members with default values for a new instance
}
  #+END_SRC
- 也可以
  #+BEGIN_SRC java
// onRestoreInstanceState()方法
public void onRestoreInstanceState(Bundle savedInstanceState) {
    super.onRestoreInstanceState(savedInstanceState); // Always call the superclass so it can restore the view hierarchy
    mCurrentScore = savedInstanceState.getInt(STATE_SCORE); // Restore state members from saved instance
    mCurrentLevel = savedInstanceState.getInt(STATE_LEVEL);
}
  #+END_SRC

** 一些特殊的方法
*** onWindowFocusChanged()
- 在Activity窗口获得或失去焦点时被调用并且当Activity被创建时是在onResume之后被调用，当Activity被覆盖或者退居后台或者当前Activity退出时，它是在onPause之后被调用（在这个方法中可以view已经绘制完成，可以获取view的宽高等属性）
*** onSaveInstanceState()
- (1)在Activity被覆盖或退居后台之后，系统资源不足将其杀死，此方法会被调用；
- (2)在用户改变屏幕方向时，此方法会被调用； 
- (3)在当前Activity跳转到其他Activity或者按Home键回到主屏，自身退居后台时，此方法会被调用。
- 第一种情况我们无法保证什么时候发生，系统根据资源紧张程度去调度；
- 第二种是屏幕翻转方向时，系统先销毁当前的Activity，然后再重建一个新的，调用此方法时，我们可以保存一些临时数据；
- 第三种情况系统调用此方法是为了保存当前窗口各个View组件的状态。
- onSaveInstanceState的调用顺序是在onstop之前。（android3.0之前：在onPause之前调用，在3.0之后，在onPause之后调用）
*** onRestoreInstanceState()
- 有的人说这个方法和onSaveInstanceState是一对，其实不然，
- (1)在Activity被覆盖或退居后台之后，系统资源不足将其杀死，然后用户又回到了此Activity，此方法会被调用；
- (2)在用户改变屏幕方向时，重建的过程中，此方法会被调用。
- 我们可以重写此方法，以便可以恢复一些临时数据。
- onRestoreInstanceState的调用顺序是在onStart之后。
- 在当前Activity跳转到其他Activity或者按Home键回到主屏，自身退居后台时：onRestoreInstanceState不会调用，但是onSaveInstanceState会调用，这点就是区别
*** 注意一下两个函数在生命周期中的调用顺序
#+BEGIN_SRC java
onCreate()
onStart()
onSaveInstanceState()
onResume()
onPause()
onRestoreInstanceState()
onStop()
onDestory()
#+END_SRC
** 最后的总结
- 当Activity被系统撤销后重新建立时，保存以及恢复数据的函数调用顺序是：
  - onSaveInstanceState(保存数据) ----> onCreate(恢复数据allstate) ----> onRestoryInstanceState(恢复数据HierarchyState)
- 如果要取消切换屏幕方法重建activity，可以配置configChanges属性：当支持的最小sdk版本大于android4.0需要设置这个属性）
  #+BEGIN_SRC java
android:configChanges="keyboardHidden|orientation|screenSize（当支持的最小sdk版本大于android4.0需要设置这个属性）"
  #+END_SRC

** 他人总结
- 横竖屏切换时 Activity 的生命周期
1、不设置 Activity 的 android:configChanges 时，切屏会重新调用各个生命周期 默认首先销毁当前 activity，然后重新加载。如下图，当横竖屏切换时先执行 onPause/onStop 方法
#+BEGIN_SRC java
onPause()
onStop()
onCreate()
onStart()
onResume()
#+END_SRC
2、设置 Activity 的 android:configChanges="orientation|keyboardHidden|screenSize"时，切屏不会重新调 用各个生命周期，只会执行 onConfigurationChanged 方法。

- https://juejin.im/post/5a18f58651882531bb6c82e2
- 1. 打开一个全新的activityA：
  - onCreate() ----> onStart() ----> onResume()
- 2. 从activity A ----> activity B（全屏）：
  - activity A 先执行: onPause()
  - 然后activity B执行: onCreate() ----> onStart() ----> onResume()
  - activity A 再执行: onStop()
- 3. 从activity A ----> activity B（非全屏）：
  - activity A先执行: onPause()
  - 然后activity B执行: onCreate() ----> onStart() ----> onResume()
  - *activity A不会执行onStop()*
- 4. activity B（全屏）返回到 activity A：
  - activity B 先执行: onPause()
  - activity A: onRestart ----> onStart() ----> onResume()
  - activity B再执行: onStop() ----> onDestory()
- 5. activity B（非全屏）返回到activity A 
  - activity B先执行: onPause()
  - activity A: onResume()
  - activity B再执行: onStop() ----> onDestory()
- 6. activity B返回到activity A：
  - 如果activityA已经被销毁，activityA会重新创建，执行: onCreate() ----> onStart() ----> onResume()
  - activityB的流程不变
- 7. activity A按home键退居后台：
  - 同2的流程: onPause()
- 8. 再从home返回到activity A
  - 同4的流程: onRestart ----> onStart() ----> onResume()
** activity之间的数据传递： 6种方式
*** 使用Inten的putExtra传递
- 第一个Activity中
    #+BEGIN_SRC java
    Intent intent = new Intent(this,TwoActivity.class);
    intent.putExtra("data",str);
    startActivity(intent);
    #+END_SRC
- 第二个Activity
    #+BEGIN_SRC java
    Intent intent = getIntent();
    String str = intent.getStringExtra("data");
    tv.setText(str);
    #+END_SRC
*** 使用Intention的Bundle传递
- 第一个Activity中
    #+BEGIN_SRC java
    Intent intent = new Intent(MainActivity.this,TwoActivity.class);
    Bundle bundle = new Bundle();
    bundle.putString("data", str);
    intent.putExtra("bun", bundle);
    startActivity(intent);
    #+END_SRC
- 第二个Activity
    #+BEGIN_SRC java
    Intent intent = getIntent();
    Bundle bundle = intent.getBundleExtra("bun");
    String str = bundle.getString("data");
    tv.setText(str);
    #+END_SRC
*** 使用Activity销毁时传递数据
- 第一个Activity中
    #+BEGIN_SRC java
    Intent intent = new Intent(MainActivity.this,TwoActivity.class);
    startActivityForResult(intent, 11);
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        String str = data.getStringExtra("data");
        tvOne.setText(str);
    }
    #+END_SRC
- 第二个Activity
    #+BEGIN_SRC java
    Intent intent = new Intent();
    intent.putExtra("data", edtOne.getText().toString().trim());
    setResult(3, intent);
    finish();
    #+END_SRC
*** SharedPreferences传递数据
- 第一个Activity中
    #+BEGIN_SRC java
SharedPreferences sp = this.getSharedPreferences("info", 1);
Editor edit = sp.edit();
edit.putString("data", str);
edit.commit();
Intent intent = new Intent(MainActivity.this,TwoActivity.class);
startActivity(intent);
    #+END_SRC
- 第二个Activity
    #+BEGIN_SRC java
SharedPreferences sp = this.getSharedPreferences("info", 1);
tv.setText(sp.getString("data", ""));
    #+END_SRC
*** 使用序列化对象Seriazable
- 这里需要建一个工具类
#+BEGIN_SRC java
import java.io.Serializable;
class DataBean implements Serializable {
    private String name;
    private String sex;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getSex() {
        return sex;
    }
    public void setSex(String sex) {
        this.sex = sex;
    }
}
#+END_SRC
- 第一个Activity中
    #+BEGIN_SRC java
Intent intent = new Intent(MainActivity.this,TwoActivity.class);
DataBean bean = new DataBean();
bean.setName("啦啦");
bean.setSex("男");
intent.putExtra("key", bean);
startActivity(intent);
    #+END_SRC
- 第二个Activity
    #+BEGIN_SRC java
Intent intent = getIntent();
//反序列化数据对象
Serializable se = intent.getSerializableExtra("key");
if(se instanceof DataBean){
    //获取到携带数据的DataBean对象db
    DataBean db = (DataBean) se;
    tv.setText(db.getName()+"==="+db.getSex());
}
    #+END_SRC
*** 使用静态变量传递数据
- 第一个Activity中
    #+BEGIN_SRC java
Intent intent = new Intent(MainActivity.this,TwoActivity.class);
TwoActivity.name="牛逼";
TwoActivity.str="你说";
startActivity(intent);
    #+END_SRC
- 第二个Activity
    #+BEGIN_SRC java
protected static String name;
protected static String str;
tv.setText(str+name);
    #+END_SRC
*** 剪切板，稍偏
- 第一个Activity中
    #+BEGIN_SRC java
ClipboardManager clipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
String name = "AHuier";
clipboardManager.setText(name);
Intent intent = new Intent(IntentDemo.this, Other.class);
startActivity(intent);
    #+END_SRC
- 第二个Activity
    #+BEGIN_SRC java
ClipboardManager clipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
String msgString = clipboardManager.getText().toString();
textView.setText(msgString);
    #+END_SRC
- 利用剪切板传递复杂的数据，如对象，略

* Fragment生命周期探讨
   #+caption: Fragment生命周期探讨

 [[./pic/fragmentlifecycle.png]]
   #+caption: Fragment与Activity生命周期对比图

 [[./pic/lifecyclecompare.png]]

- Fragment基本类，生命周期如下：
  #+BEGIN_SRC java
void onAttach(Context context)
void onCreate(Bundle savedInstanceState)
View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
void onActivityCreated(Bundle savedInstanceState)
void onStart()
void onResume()
void onPause()
void onStop()
void onDestroyView()
void onDestroy()
void onDetach()
  #+END_SRC

** 首先需要提出的一些points：
- Fragment是直接从Object继承的，而Activity是Context的子类。因此我们可以得出结论：Fragment不是Activity的扩展。但是与Activity一样，在我们使用Fragment的时候我们总会扩展Fragment(或者是她的子类)，并可以通过子类更改她的行为。
- 使用Fragment时，必要构建一个无参构造函数，系统会默认带。但一但写有参构造函数，就必要构建无参构造函数。一般来说我们传参数给Fragment，会通过bundle，而不会用构造方法传，代码如下：
  #+BEGIN_SRC java
public static MyFragment newInstance(int index){  
    MyFragment mf = new MyFragment();  
    Bundle args = new Bundle();  
    args.putInt("index",index);  
    mf.setArguments(args);  
    return mf;  
} 
  #+END_SRC
** 生命周期
- onAttach()：onAttach()回调将在Fragment与其Activity关联之后调用。需要使用Activity的引用或者使用Activity作为其他操作的上下文，将在此回调方法中实现。
  - 将Fragment附加到Activity以后，就无法再次调用setArguments()--除了在最开始，无法向初始化参数添加内容。
- onCreate(Bundle savedInstanceState)：此时的Fragment的onCreate()回调时，该fragmet还没有获得Activity的onCreate()已完成的通知，所以不能将依赖于Activity视图层次结构存在性的代码放入此回调方法中。在onCreate()回调方法中，我们应该尽量避免耗时操作。此时的bundle就可以获取到activity传来的参数
  #+BEGIN_SRC java
@Override
public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        Bundle args = getArguments();  
        if (args != null) {  
            mLabel = args.getCharSequence("label", mLabel);  
        }  
    }  
  #+END_SRC
- onCreateView()
  #+BEGIN_SRC java
onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
  #+END_SRC
  - 其中的Bundle为状态包与上面的bundle不一样。
  - 不要将视图层次结构附加到传入的ViewGroup父元素中，该关联会自动完成。如果在此回调中将碎片的视图层次结构附加到父元素，很可能会出现异常。
  - 这句话什么意思呢？就是不要把初始化的view视图主动添加到container里面，以为这会系统自带，所以inflate函数的第三个参数必须填false，而且不能出现container.addView(v)的操作。
  #+BEGIN_SRC java
View v = inflater.inflate(R.layout.hello_world, container, false);
  #+END_SRC
- onActivityCreated()
  - onActivityCreated()回调会在Activity完成其onCreate()回调之后调用。在调用onActivityCreated()之前，Activity的视图层次结构已经准备好了，这是在用户看到用户界面之前你可对用户界面执行的最后调整的地方。
  - 如果Activity和她的Fragment是从保存的状态重新创建的，此回调尤其重要，也可以在这里确保此Activity的其他所有Fragment已经附加到该Activity中了
- Fragment与Activity相同生命周期调用：接下来的onStart(), onResume(), onPause(), onStop()回调方法将和Activity的回调方法进行绑定，也就是说与Activity中对应的生命周期相同，因此不做过多介绍。
- onDestroyView():该回调方法在视图层次结构与Fragment分离之后调用。
- onDestroy()：不再使用Fragment时调用。(备注：Fragment仍然附加到Activity并任然可以找到，但是不能执行其他操作)
- onDetach()：Fragment生命周期最后回调函数，调用后，Fragment不再与Activity绑定，释放资源。

** Fragment每个生命周期方法的意义、作用
- onAttach()
  - 执行该方法时，Fragment与Activity已经完成绑定，该方法有一个Activity类型的参数，代表绑定的Activity，这时候你可以执行诸如mActivity = activity的操作。
- onCreate()
  - 初始化Fragment。可通过参数savedInstanceState获取之前保存的值。
- onCreateView()
  - 初始化Fragment的布局。加载布局和findViewById的操作通常在此函数内完成，但是不建议执行耗时的操作，比如读取数据库数据列表。
- onActivityCreated()
  - 执行该方法时，与Fragment绑定的Activity的onCreate方法已经执行完成并返回，在该方法内可以进行与Activity交互的UI操作，所以在该方法之前Activity的onCreate方法并未执行完成，如果提前进行交互操作，会引发空指针异常。
- onStart()
  - 执行该方法时，Fragment由不可见变为可见状态。
- onResume()
  - 执行该方法时，Fragment处于活动状态，用户可与之交互。
- onPause()
  - 执行该方法时，Fragment处于暂停状态，但依然可见，用户不能与之交互。
- onSaveInstanceState()
  - 保存当前Fragment的状态。该方法会自动保存Fragment的状态，比如EditText键入的文本，即使Fragment被回收又重新创建，一样能恢复EditText之前键入的文本。
- onStop()
  - 执行该方法时，Fragment完全不可见。
- onDestroyView()
  - 销毁与Fragment有关的视图，但未与Activity解除绑定，依然可以通过onCreateView方法重新创建视图。通常在ViewPager+Fragment的方式下会调用此方法。
- onDestroy()
  - 销毁Fragment。通常按Back键退出或者Fragment被回收时调用此方法。
- onDetach()
  - 解除与Activity的绑定。在onDestroy方法之后调用。
- setUserVisibleHint()
  - 设置Fragment可见或者不可见时会调用此方法。在该方法里面可以通过调用getUserVisibleHint()获得Fragment的状态是可见还是不可见的，如果可见则进行懒加载操作。
** Fragment生命周期执行流程
- 1、Fragment创建
  - setUserVisibleHint() ----> onAttach() ----> onCreate() ----> onCreateView() ----> onActivityCreated() ----> onStart() ----> onResume()
- 2、Fragment变为不可见状态（锁屏、回到桌面、被Activity完全覆盖）
  - onPause() ----> onSaveInstanceState() ----> onStop()
- 3、Fragment变为部分可见状态（打开Dialog样式的Activity）
  - onPause() ----> onSaveInstanceState()
- 4、Fragment由不可见变为活动状态
  - onStart() ----> OnResume()
- 5、Fragment由部分可见变为活动状态
  - onResume()
- 6、Fragment退出
  - onPause() ----> onStop() ----> onDestroyView() ----> onDestroy() ----> onDetach()
  - （注意退出不会调用onSaveInstanceState方法，因为是人为退出，没有必要再保存数据）
- 7、Fragment被回收又重新创建
  - 被回收执行: onPause() ----> onSaveInstanceState() ----> onStop() ----> onDestroyView() ----> onDestroy() ----> onDetach()
  - 重新创建执行: onAttach() ----> onCreate() ----> onCreateView() ----> onActivityCreated() ----> onStart() ----> onResume() ----> setUserVisibleHint()
- 横竖屏切换
  - 与Fragment被回收又重新创建一样。
** onHiddenChanged的回调时机
- 当使用add()+show()，hide()跳转新的Fragment时，旧的Fragment回调onHiddenChanged()，不会回调onStop()等生命周期方法，而新的Fragment在创建时是不会回调onHiddenChanged()，这点要切记。
** FragmentPagerAdapter+ViewPager的注意事项
- 1、 使用FragmentPagerAdapter+ViewPager时，切换回上一个Fragment页面时（已经初始化完毕），不会回调任何生命周期方法以及onHiddenChanged()，只有setUserVisibleHint(boolean isVisibleToUser)会被回调，所以如果你想进行一些懒加载，需要在这里处理。
- 2、 在给ViewPager绑定FragmentPagerAdapter时，new FragmentPagerAdapter(fragmentManager)的FragmentManager，一定要保证正确，如果ViewPager是Activity内的控件，则传递getSupportFragmentManager()，如果是Fragment的控件中，则应该传递getChildFragmentManager()。只要记住ViewPager内的Fragments是当前组件的子Fragment这个原则即可。
- 3、 你不需要考虑在“内存重启”的情况下，去恢复的Fragments的问题，因为FragmentPagerAdapter已经帮我们处理啦。
** setUserVisibleHint()不调用的问题
- 通常情况下都是因为PagerAdapter不是FragmentPagerAdapter造成的，FragmentPagerAdapter内部实现了对setUserVisibleHint()方法的调用，所以需要懒加载的结构最好使用FragmentPagerAdapter +Fragment的结构，少用PagerAdapter。

** Fragment注意事项
- 在使用Fragment时，我发现了一个金矿，那就是setRetainInstance()方法,此方法可以有效地提高系统的运行效率，对流畅性要求较高的应用可以适当采用此方法进行设置。
- Fragment有一个非常强大的功能--就是可以在Activity重新创建时可以不完全销毁Fragment，以便Fragment可以恢复。在onCreate()方法中调用setRetainInstance(true/false)方法是最佳位置。当Fragment恢复时的生命周期如上图所示，注意图中的红色箭头。当在onCreate()方法中调用了setRetainInstance(true)后，Fragment恢复时会跳过onCreate()和onDestroy()方法，因此不能在onCreate()中放置一些初始化逻辑.

* Android Fragment 生命周期图
- http://www.cnblogs.com/purediy/p/3276545.html
- Fragment与Activity生命周期对比图：

** 生命周期分析
*** 当一个fragment被创建的时候(它会经历以下状态)
- onAttach()
- onCreate()
- onCreateView()
- onActivityCreated()
*** 当这个fragment对用户可见的时候
- onStart()
- onResume()
*** 当这个fragment进入“后台模式”的时候
- onPause()
- onStop()
*** 当这个fragment被销毁了（或者持有它的activity被销毁了）
- onPause()
- onStop()
- onDestroyView()
- onDestroy() // 本来漏掉类这个回调，感谢xiangxue336提出。
- onDetach()
*** 就像activity一样，在以下的状态中，可以使用Bundle对象保存一个fragment的对象。
- onCreate()
- onCreateView()
- onActivityCreated()
*** fragments的大部分状态都和activity很相似，但fragment有一些新的状态。
- onAttached() -- 当fragment被加入到activity时调用（在这个方法中可以获得所在的activity）。
- onCreateView() -- 当activity要得到fragment的layout时，调用此方法，fragment在其中创建自己的layout(界面)。
- onActivityCreated() -- 当activity的onCreated()方法返回后调用此方法
- onDestroyView() -- 当fragment中的视图被移除的时候，调用这个方法。
- onDetach() -- 当fragment和activity分离的时候，调用这个方法。
- Notes:
  - 一旦activity进入resumed状态（也就是running状态），你就可以自由地添加和删除fragment了。
  - 因此，只有当activity在resumed状态时，fragment的生命周期才能独立的运转，其它时候是依赖于activity的生命周期变化的。


* activity lifecycle
*** Activity横竖屏切换生命周期变化
**** 新建一个Activity，并把各个生命周期打印出来
onCreate,
创建activity时调用。设置在该方法中，还以Bundle中可以提出用于创建该 Activity 所需的信息。
onStart,
activity变为在屏幕上对用户可见时，即获得焦点时，会调用。
onResume,
activity开始与用户交互时调用（无论是启动还是重新启动一个活动，该方法总是被调用的）
onSaveInstanceState
onPause,
activity被暂停或收回cpu和其他资源时调用，该方法用于保存活动状态的
onStop,
activity被停止并转为不可见阶段及后续的生命周期事件时，即失去焦点时调用
onDestroy,
activity被完全从系统内存中移除时调用，该方法被调用可能是因为有人直接调用 finish()方法 或者系统决定停止该活动以释放资源。
onRestoreInstanceState,
Android在横竖排切换时候，将主动销毁activity和重新创建一个新的activity出来，在此过程中，onRestoreInstanceState就要被回调
onConfigurationChanged,
配置指定属性后,屏幕方向发生变化后回调此函数.
**** 运行Activity，得到如下信息
#+BEGIN_SRC java
onCreate  -->
onStart  -->
onResume  -->
#+END_SRC
**** 按crtl+f12切换成横屏时
#+BEGIN_SRC java
onPause  -->
onStop  -->
onDestroy  -->
onCreate  -->
onStart  -->
onRestoreInstanceState  -->
onResume  -->
#+END_SRC
**** 再按crtl+f12切换成竖屏时，发现又打印了相同的log
#+BEGIN_SRC java
onPause  -->
onStop  -->
onDestroy  -->
onCreate  -->
onStart  -->
onRestoreInstanceState  -->
onResume  -->
#+END_SRC
**** 修改AndroidManifest.xml
把该Activity添加
#+BEGIN_SRC java
android:configChanges="orientation"，
#+END_SRC
执行步骤3(切换成横屏时)
#+BEGIN_SRC java
onPause  -->
onStop  -->
onDestroy  -->
onCreate  -->
onStart  -->
onRestoreInstanceState  -->
onResume  -->
#+END_SRC
**** 再执行步骤4(切换竖屏)，发现再打印相同信息
#+BEGIN_SRC java
onPause  -->
onStop  -->
onDestroy  -->
onCreate  -->
onStart  -->
onRestoreInstanceState  -->
onResume  -->
#+END_SRC

*** Why do developers often put app initialization code in the Application class?
- The Application class is instantiated before any other class when the process for the application is created.

* fragmnet
*** What are Retained Fragments?
- By default, Fragments are destroyed and recreated along with their parent Activity’s when a configuration change occurs.
- Calling setRetainInstance(true) allows us to bypass this destroy-and-recreate cycle, signaling the system to retain the current instance of the fragment when the activity is recreated.

*** How would you communicate between two Fragments?

All Fragment-to-Fragment communication is done either through a shared ViewModel or through the associated Activity. Two Fragments should never communicate directly.

- The recommended way to communicate between fragments is to create a shared ViewModel object. Both fragments can access the ViewModel through their containing Activity. The Fragments can update data within the ViewModel and if the data is exposed using LiveData the new state will be pushed to the other fragment as long as it is observing the LiveData from the ViewModel.
#+BEGIN_SRC java
public class SharedViewModel extends ViewModel {
    private final MutableLiveData <Item> selected = new MutableLiveData < Item > ();
    public void select(Item item) {
        selected.setValue(item);
    }
    public LiveData <Item> getSelected() {
        return selected;
    }
}
public class MasterFragment extends Fragment {
    private SharedViewModel model;
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);
        itemSelector.setOnClickListener(item -> {
                model.select(item);
            });
    }
}
public class DetailFragment extends Fragment {
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);
        model.getSelected().observe(this, {
                item ->
                    // Update the UI.
                    // model.select(item); // 这行充当占位符，复制的上面的
                    });
    }
}
#+END_SRC
- Another way is to define an interface in your Fragment A, and let your Activity implement that Interface. Now you can call the interface method in your Fragment, and your Activity will receive the event. Now in your activity, you can call your second Fragment to update the textview with the received value.

** transaction stack backstack
*** What is the chief purpose of line five in this code snippet?
#+BEGIN_SRC java
override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_post_create)
	if (savedInstanceState != null) return
	val fragment = CreatePostFragment()
		supportFragmentManager
		.beginTransaction()
		.add(R.id. fragment_container, fragment)
		.commit()
}
#+END_SRC
- to make sure that the activity creates a new fragment each time it is restored from a previous state

* View
** What should you use to display a large, scrolling list of elements?
- Recycler View

** Given the fragment below, how would you get access to a TextView with an ID of text_home contained in the layout file of a Fragment class?
   #+BEGIN_SRC java
    private lateinit var textView: TextView
    override fun onCreateView(...): View? {
        val root = inflator.inflator(R>layout.fragment_home, container, false)
        textView = ??
        return root
    }
// root.findViewById(R.id.text_home)
   #+END_SRC  
   

* Intent
** You have created a NextActivity class that relies on a string containing some data that pass inside the intent Which code snippet allows you to launch your activity?
#+BEGIN_SRC java
Intent(this, NextActivity::class.java).apply {
    putExtra(EXTRA_NEXT, "some data")
}.also { intent ->
    startActivity(intent)
}
#+END_SRC
** You have created an AboutActivity class that displays details about your app. Which code snippet allows you to launch your activity?
#+BEGIN_SRC java
Intent(this, AboutActivity::class.java).also { 
    intent -> startActivity(intent) 
}
#+END_SRC
** Which definition will prevent other apps from accessing your Activity class via an intent?
#+BEGIN_SRC java
<activity android:name=".ExampleActivity" />
#+END_SRC
- Intent filters are used to make activities accessible to other apps using intents. So we have to choose option which have no intent filter to make sure it is not accessible by intent
** You want to allow users to take pictures in your app. Which is not an advantage of creating an appropriate intent, instead of requesting the camera permission directly?
- Users can select their favorite photo apps to take pictures.
- You do not have to make a permission request in your app to take a picture.
- You do not have to design the UI. The app that handles the camera intent will provide the UI.
- You have full control over the user experience. The app that handles the camera intent will respect your design choices. (ANSWER)

** onActivityResult()
- When will an activity's onActivityResult()be called?
  -  when calling finish() in the target activity
** startActivityWithResult(): You want to open the default Dialer app on a device. What is wrong with this code?
#+BEGIN_SRC java
val dialerIntent = Intent()
val et = findViewById(R.id.some_edit_text)
dialerIntent.action = Intent.ACTION_DIAL
dialerIntent.data = Uri.parse("tel:" + et.getText()?.toString())
startActivity(dialerIntent) // <--
#+END_SRC
- startActivityWithResult() should be used instead of startActivity() when using Intent.ACTION_DIAL.
     

* Data
** storage
*** To persist a small collection of key-value data, what should you use?
- SharedPereferences

*** What allows you to properly restore a user's state when an activity is restarted?
- the onSaveInstance()method
- persistent storage
- ViewModel objects
- all of these answers (Refrence) (ANSWER)
***  To preserve on-device memory, how might you determine that the user's device has limited storage capabilities?
#+BEGIN_SRC java
ActivityManager.isLowRamDevice() ;
#+END_SRC
- Use the ActivityManager.isLowRamDevice() method to find out whether a device defines itself as "low RAM."

** How would you retrieve the value of a user's email from SharedPreferences while ensuring that the returned value is not null?
   #+BEGIN_SRC java
  getDefaultSharedPreferances(this).getString(EMAIL,"")
   #+END_SRC
-  In Method "getDefaultSharedPrefarances(this).getString()" Second parameter is passed so that it can be returned, in case key doesn't exist. So we need to pass an empty string to be returned in case key doesn't exist.
   

* xml resource files
** layout
*** Which layout is best for large, complex hierarchies?
- ConstraintLayout

***  Which drawable definition allows you to achieve the shape below?
    
   [[./pic/circle.png]]

    #+BEGIN_SRC xml
<shape xmlns:android="http://schemas.android.com/apk/res/android"
android:shape="oval">
<stroke
    android:width="4dp"
    android:color="@android:color/black" />
<solid android:color="@android:color/white" />
</shape>
    #+END_SRC   
*** Which image best corresponds to the following LinearLayout?
#+BEGIN_SRC xml
  <LinearLayout
      android:layout_width="match_parent"
	  android:layout_height="match_parent"
	  android:orientation="horizontal"
	  android:gravity="center">
	<Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Button" />
	<Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Button" />
  </LinearLayout>
#+END_SRC
- gravity="center"是描述的竖直方向上位于中间，而水平方向上同样也是位于中间，每个键的宽度由自身内容的宽度决定
- gravity: todo
*** Which code snippet would achieve the layout displayed below?
   #+BEGIN_SRC java
<androidx.constraintlayout.widget.ConstraintLayout
	...>

	<TextView
		android:id="@+id/text_dashboard"
		android:layout_width="match_parent"
		android:layout_height="wrap_content"
		android:layout_marginStart="8dp"
		android:layout_marginEnd="8dp"
		android:textAlignment="center"
		android:text="Dashboard"
		app:layout_constraintEnd_toEndOf="parent"
		app:layout_constraintStart_toStartOf="parent"
		app:layout_constraintTop_toTopOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>
   #+END_SRC
- 左右各留8dp,文字中间对齐；文本框高度由自身高度决定；文本框宽度拉伸match_parent; 

*** 实现矩形，右下角白色，左上角黑色的渐变效果
#+BEGIN_SRC xml
  <shape xmlns:android-"http://schemas.android.com/apk/res/android"
  android:shape-"rectangle">
  <gradient
	  android:startColor-"@android:color/white"
	  android:endColor-"@android:color/black"
	  android:angle-"135"/>
	</shape>
#+END_SRC
*** Given the following dimens.xml file, how would you define an ImageView with medium spacing at the bottom?
#+BEGIN_SRC xml
<?xml version=1.0 encoding="utf-8"?>
<resources>
    <dimen name="spacing_medium">8dp</dimen>
    <dimen name="spacing_large">12dp</dimen>
</resources>
#+END_SRC
#+BEGIN_SRC xml
<ImageView
   android:id=@+id/image_map_pin"
   android:layout_width="wrap_content"
   android:layout_heignt="wrap_content"
   android:layout_marginBottom="@dimen/spacing_medium"
   android:src=@drawable/map_pin />
#+END_SRC
*** You want to provide a different drawable for devices that are in landscape mode and whose language is set to French. which directory is named correctly?
- drawable-fr-land
    
*** What folder should you use for your app's launcher icons?
- /mipmap
** permissions
*** 写外部存储权限
#+BEGIN_SRC java
<uses-permission
     android:name="android.permission.WRITE_EXTERNAL_STORAGE"
     android:maxSdkVersion="18" />
#+END_SRC
*** When would you use the ActivityCompat.shouldShowRequestPermissionRationale() function?
    #+BEGIN_SRC java
ActivityCompat.shouldShowRequestPermissionRationale();
    #+END_SRC
-  when a user has previously denied the request for a given permission and selected "Don't ask again," but you need the permission for your app to function

*** Why might you need to include the following permission to your app?
#+BEGIN_SRC java
android.permission.ACCESS_NETWORK_STATE
#+END_SRC
- to monitor the network state of the devices so that you don't attempt to make network calls when the network is unavailable


* annotation
** @VisibleForTesting: 
-  to denote that a class, methos, or field has its visibility relaxed to make code testable
   

* apk
** basic
*** When would you use a product flavour in your build setup?
   when you want to provide different version of your app with custom configuration and resources
*** To shrink your code in release builds, what tool does Android Studio use?
- R8
** build configuration
*** Which statement, in build.gradle file, correctly denotes that the corresponding module is an Android library module?
#+BEGIN_SRC java
 apply plugin: 'com.android.library'
#+END_SRC
*** You would like to enable analytics tracking only in release builds. How can you create a new field in the generated BuildConfig class to store that value?
#+BEGIN_SRC java
buildTypes {
	debug {
		buildConfigField 'boolean', 'ENABLE_ANALYTICS', 'false'
	}
	release {
		buildConfigField 'boolean', 'ENABLE_ANALYTICS', 'true'
	}
}
#+END_SRC   
***  To optimize your APK size, what image codec should you use?
- WebP (Reference)

*** Given an APK named app-internal-debug.apk produced from the build process, which statement is likely to be true?
-  This APK is created from the debug build type and internal product flavor.
** build errors
*** When attempting to build your project, what might the following error indicate?
#+BEGIN_SRC java
Conversion to Dalvik format filed: Unable to execute dex: method ID not in [0, 0xffff]: 65536
#+END_SRC
- You have exceeded the total number of methods that can be referenced within a single DEX file.

* testing
** Why do you use the AndroidJUnitRunner when running UI tests?
- Notice: AndroidJUnitRunner lets us run JUnit3/4-style tests on Android Devices
  - The test runner facilitates loading your test package and the app under test onto a device or emulator, runs the test, and reports the results.
** Given the test class below, which code snippet would be a correct assertion?
#+BEGIN_SRC java
 assertNotNull(resultAdd)    
#+END_SRC


* debugging
** network
*** You have built code to make a network call and tested that it works in your development environment. However, when you publish it to the Play console, the networking call fails to work. What will NOT help you troubleshoot this issue?
- checking whether ProGuard -keepclassmembers have been added to the network data transfer objects (DTOs) in question
- checking for exceptions in the server logs or server console
- checking that the network data transfer object has @SerizlizedName applied to its member properties
- using the profiler tools in Android Studio to detect anomalies in CPU, memory, and network usage (ANSWER: this does not help) 


* Frameworks
** Retrofit
*** You need to remove an Event based on it;s id from your API, Which code snippet defines that request in Retrofit?
  -  @DELETE("events/{id}") fun deleteEvent(@Path("id") id: Long): Call
*** You need to retrieve a list of photos from an API. Which code snippet defines an HTML GET request in Retrofit?
    #+BEGIN_SRC java
 @GET("photo") fun listPhotos() : Call<List>
    #+END_SRC


* 需要分类出去的
*** What are the permission protection levels in Android?
- Normal — A lower-risk permission that gives requesting applications access to isolated application-level features, with minimal risk to other applications, the system, or the user. The system automatically grants this type of permission to a requesting application at installation, without asking for the user’s explicit approval.
- Dangerous — A higher-risk permission. Any dangerous permissions requested by an application may be displayed to the user and require confirmation before proceeding, or some other approach may be taken to avoid the user automatically allowing the use of such facilities.
- Signature — A permission that the system grants only if the requesting application is signed with the same certificate as the application that declared the permission. If the certificates match, the system automatically grants the permission without notifying the user or asking for the user’s explicit approval.
- SignatureOrSystem — A permission that the system grants only to applications that are in the Android system image or that are signed with the same certificate as the application that declared the permission.

*** What is Android Data Binding?

The Data Binding Library is a support library that allows you to bind UI components in your layouts to data sources in your app using a declarative format rather than programmatically.

Layouts are often defined in activities with code that calls UI framework methods. For example, the code below calls findViewById() to find a TextView widget and bind it to the userName property of the viewModel variable:

#+BEGIN_SRC java
TextView textView = findViewById(R.id.sample_text);
textView.setText(viewModel.getUserName());
#+END_SRC

The following example shows how to use the Data Binding Library to assign text to the widget directly in the layout file. This removes the need to call any of the Java code shown above.

#+BEGIN_SRC java
<TextView
    android:text="@{viewmodel.userName}" />
#+END_SRC

- The pros of using Android Data Binding:
  - Reduces boilerplate code which in turns brings
  - Less coupling
  - Stronger readability
  - Powerful, easy to implement custom attribute and custom view
  - Even faster than findViewById - The binding does a single pass on the View hierarchy, extracting the Views with IDs. This mechanism can be faster than calling findViewById for several Views.

*** What is the ViewHolder pattern? Why should we use it?

Every time when the adapter calls getView() method, the findViewById() method is also called. This is a very intensive work for the mobile CPU and so affects the performance of the application and the battery consumption increases. ViewHolder is a design pattern which can be applied as a way around repeated use of findViewById().

A ViewHolder holds the reference to the id of the view resource and calls to the resource will not be required after you "find" them: Thus performance of the application increases.
#+BEGIN_SRC java
private static class ViewHolder {
    final TextView text;
    final TextView timestamp;
    final ImageView icon;
    final ProgressBar progress;

    ViewHolder(TextView text, TextView timestamp, ImageView icon, ProgressBar progress) {
        this.text = text;
        this.timestamp = timestamp;
        this.icon = icon;
        this.progress = progress;
    }
}
public View getView(int position, View convertView, ViewGroup parent) {
    View view = convertView;
    if (view == null) {
        view = // inflate new view
        ViewHolder holder = createViewHolderFrom(view);
        view.setTag(holder);  
    }
    ViewHolder holder = view.getTag();
    // TODO: set correct data for this list item
    // holder.icon.setImageDrawable(...)
    // holder.text.setText(...)
    // holder.timestamp.setText(...)
    // holder.progress.setProgress(...)
    return view;
}
private ViewHolder createViewHolderFrom(View view) {
    ImageView icon = (ImageView) view.findViewById(R.id.listitem_image);
    TextView text = (TextView) view.findViewById(R.id.listitem_text);
    TextView timestamp = (TextView) view.findViewById(R.id.listitem_timestamp);
    ProgressBar progress = (ProgressBar) view.findViewById(R.id.progress_spinner);
    return new ViewHolder(text, timestamp, icon, progress);
}
#+END_SRC
- View.setTag(Object) allows you to tell the View to hold an arbitrary object. If we use it to hold an instance of our ViewHolder after we do our findViewById(int) calls, then we can use View.getTag() on recycled views to avoid having to make the calls again and again.

*** What is the difference between Handler vs AsyncTask vs Thread?
Mid 
Top 113 Android Interview Questions  Android  113  
Answer
The Handler class can be used to register to a thread and provides a simple channel to send data to this thread. A Handler allows you communicate back with the UI thread from other background thread.
The AsyncTask class encapsulates the creation of a background process and the synchronization with the main thread. It also supports reporting progress of the running tasks.
And a Thread is basically the core element of multithreading which a developer can use with the following disadvantage:
Handle synchronization with the main thread if you post back results to the user interface
No default for canceling the thread
No default thread pooling
No default for handling configuration changes in Android
Having Tech or Coding Interview? Check 👉 113 Android Interview Questions
Source: stackoverflow.com
*** What is the difference between compileSdkVersion and targetSdkVersion?
Mid 
Top 113 Android Interview Questions  Android  113  
Answer
The compileSdkVersion is the version of the API the app is compiled against. This means you can use Android API features included in that version of the API (as well as all previous versions, obviously). If you try and use API 16 features but set compileSdkVersion to 15, you will get a compilation error. If you set compileSdkVersion to 16 you can still run the app on a API 15 device as long as your app's execution paths do not attempt to invoke any APIs specific to API 16.

The targetSdkVersion has nothing to do with how your app is compiled or what APIs you can utilize. The targetSdkVersion is supposed to indicate that you have tested your app on (presumably up to and including) the version you specify. This is more like a certification or sign off you are giving the Android OS as a hint to how it should handle your app in terms of OS features.
*** What is the difference between a Bundle and an Intent?
Mid 
Top 113 Android Interview Questions  Android  113  
Answer
A Bundle is a collection of key-value pairs.
However, an Intent is much more. It contains information about an operation that should be performed. This new operation is defined by the action it can be used for, and the data it should show/edit/add. The system uses this information for finding a suitable app component (activity/broadcast/service) for the requested action.
Think of the Intent as a Bundle that also contains information on who should receive the contained data, and how it should be presented.

*** What are the wake locks available in android?
A - PARTIAL_WAKE_LOCK
B - SCREEN_DIM_WAKE_LOCK
C - SCREEN_BRIGHT_WAKE_LOCK
D - FULL_WAKE_LOCK
E - FULL_WAKE_LOCK
Answer : E
Explanation
When CPU is on mode, PARTIAL_WAKE_LOCK will be active.

When CPU + bright Screen low is on mode, SCREEN_DIM_WAKE_LOCK will be active.

When CPU + bright Screen High is on mode,SCREEN_BRIGHT_WAKE_LOCK will be active.

When CPU, Screen, bright Screen High is on mode, FULL_WAKE_LOCK will be active.


* 项目中用到的小点
** api level 28, androidx之前的最后一个版本

** android api level 30 androidx 中项目一定需要修改的条款: androidx.fragment还没有弄通
*** gradles.propertiess
#+BEGIN_SRC xm
android.useAndroidX=true
landroid.enableJetifier=true 
#+END_SRC
*** project build.gragle: gragle versions
*** app module build.gradle
#+BEGIN_SRC .gradle
   implementation 'androidx.appcompat:appcompat:1.1.0'
    //implementation 'com.android.support:appcompat-v7:30.0.0'
    implementation 'com.android.support.constraint:constraint-layout:2.0.4'
    implementation 'com.android.support:design:30.0.0'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
#+END_SRC
-  什么是Jetifier？ 例如，要使用androidx打包的依赖项创建新项目，此新项目需要在gradle.properties文件中添加以下行：
*** JavaVersion.VERSION_1_8
#+BEGIN_SRC java
java version 8
 compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
#+END_SRC
*** references
#+BEGIN_SRC java
import android.content.Context;
import android.os.Bundle;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.Menu;
import android.view.MenuItem;
import androidx.fragment.app.Fragment;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.Toolbar;
import android.support.design.widget.FloatingActionButton;
import android.support.design.widget.Snackbar;
import com.google.android.material.floatingactionbutton.FloatingActionButton;
import com.google.android.material.snackbar.Snackbar;
#+END_SRC
*** xml中也还有一些注意事项
    #+BEGIN_SRC xml
    <com.me.generalprac.CustomTitleView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>
    <include layout="@layout/custom_title"/>
    #+END_SRC
    

