#+latex_class: cn-article
#+title: Android Study Plan
#+author: deepwaterooo

* View相关
  
  [[./pic/viewas.png]]

** 自定义View
*** 一、View中关于四个构造函数参数
- 自定义View中View的构造函数有四个
#+BEGIN_SRC java
// 主要是在java代码中生命一个View时所调用，没有任何参数，一个空的View对象
public ChildrenView(Context context) {
    super(context);
}
// 在布局文件中使用该自定义view的时候会调用到，一般会调用到该方法
public ChildrenView(Context context, AttributeSet attrs) { // AttributeSet from .xml设置
    this(context, attrs，0);
}

// 如果你不需要View随着主题变化而变化，则上面两个构造函数就可以了
// 下面两个是与主题相关的构造函数
public ChildrenView(Context context, AttributeSet attrs, int defStyleAttr) {
    this(context, attrs, defStyleAttr, 0);
}
public ChildrenView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
    super(context, attrs, defStyleAttr, defStyleRes);
}
#+END_SRC
- 构造函数的传入参数说明
  - context:上下文
  - AttributeSet attrs：从xml中定义的参数
  - intdefStyleAttr：主题中优先级最高的属性
  - intdefStyleRes： 优先级次之的内置于View的style(这里就是自定义View设置样式的地方)
- 多个地方定义属性，优先级排序 Xml直接定义 > xml中style引用 > defStyleAttr>defStyleRes > theme直接定义
** 二、.xml中的自定义属性
- 基本类型包括： integer, boolean, color, string, float, dimension, enum, flags, fraction, reference
- 基本类型略过，其它相对重要一点儿的
*** color ：引用颜色
*** dimension: 引用字体大小
- 定义
    #+BEGIN_SRC xml
<attr name = "text_size" format = "dimension" />
    #+END_SRC
- 使用：
#+BEGIN_SRC xml
<app:text_size = "28sp"  />
<app:text_size = "@android:dimen/app_icon_size" />
#+END_SRC
*** enum：枚举值
- 定义
    #+BEGIN_SRC xml
<attr name="orientation">
  <enum name="horizontal" value="0" />
  <enum name="vertical" value="1" />
</attr>
    #+END_SRC
- 使用：
    #+BEGIN_SRC xml
<app:orientation = "vertical" />
    #+END_SRC
*** flags:标志 （位或运行） 主要作用=可以多个值
- 定义
    #+BEGIN_SRC xml
<attr name="gravity">
  <flag name="top" value="0x01" />
  <flag name="bottom" value="0x02" />
  <flag name="left" value="0x04" />
  <flag name="right" value="0x08" />
  <flag name="center_vertical" value="0x16" />
</attr>
    #+END_SRC
-  使用
    #+BEGIN_SRC xml
<app:gravity = Top|left />
    #+END_SRC
*** fraction:百分数：
- 定义：
    #+BEGIN_SRC xml
<attr name = "transparency" format = "fraction" />
    #+END_SRC
- 使用：
    #+BEGIN_SRC xml
<app:transparency = "80%"  />
    #+END_SRC
*** reference:参考/引用某一资源ID
- 定义：
    #+BEGIN_SRC xml
<attr name="leftIcon" format="reference" />
    #+END_SRC
- 使用：
    #+BEGIN_SRC xml
<app:leftIcon = "@drawable/图片ID" />
    #+END_SRC
*** 混合类型：属性定义时指定多种类型值
- 属性定义
    #+BEGIN_SRC xml
<attr name = "background" format = "reference|color" />
    #+END_SRC
- 使用
    #+BEGIN_SRC xml
<android:background = "@drawable/图片ID"  />
<android:background = "#FFFFFF"  />
    #+END_SRC
** 三、自定义控件类型
   
   [[./pic/selfviews.png]]
   
*** 自定义组合控件步骤
**** 1. 自定义属性
- 在res/values目录下的attrs.xml文件中
#+BEGIN_SRC xml
<resources>
  <declare-styleable name="CustomView">
    <attr name="leftIcon" format="reference" />
    <attr name="state" format="boolean"/>
    <attr name="name" format="string"/>
  </declare-styleable>
</resources>
#+END_SRC
**** 2. 布局中使用自定义属性
- 在布局中使用
#+BEGIN_SRC xml
<com.myapplication.view.CustomView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:leftIcon="@mipmap/ic_temp"
    app:name="温度"
    app:state="false" />
#+END_SRC
**** 3. view的构造函数获取自定义属性
     #+BEGIN_SRC kotlin
class DigitalCustomView : LinearLayout {
    constructor(context: Context) : super(context)
    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) {
    LayoutInflater.from(context).inflate(R.layout.view_custom, this)
        var ta = context.obtainStyledAttributes(attrs, R.styleable.CustomView)
        mIcon = ta.getResourceId(R.styleable.CustomView_leftIcon, -1) //左图像
        mState = ta.getBoolean(R.styleable.DigitalCustomView_state, false)
        mName = ta.getString(R.styleable.CustomView_name)
        ta.recycle()
        initView()
    }
}
     #+END_SRC
- 上面给出大致的代码 记得获取context.obtainStyledAttributes(attrs, R.styleable.CustomView)最后要调用ta.recycle()利用对象池回收ta加以复用
*** 继承系统控件
- 就是继承系统已经提供好给我们的控件例如TextView、LinearLayout等,分为View类型或者ViewGroup类型的两种。主要根据业务需求进行实现，实现重写的空间也很大 主要看需求。
- 比如需求 ：在文字后面加个颜色背景
- 根据需要一般这种情况下我们是希望可以复用系统的onMeaseur和onLayout流程.直接复写onDraw方法
#+BEGIN_SRC kotlin
class Practice02BeforeOnDrawView : AppCompatTextView {
    internal var paint = Paint(Paint.ANTI_ALIAS_FLAG)
    internal var bounds = RectF()
    constructor(context: Context) : super(context) {}
    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) {}
    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) {}
    init {
        paint.color = Color.parseColor("#FFC107")
    }
    override fun onDraw(canvas: Canvas) {
        // 把下面的绘制代码移到 super.onDraw() 的上面，就可以让原主体内容盖住你的绘制代码了
        // （或者你也可以把 super.onDraw() 移到这段代码的下面）
        val layout = layout
        bounds.left = layout.getLineLeft(1)
        bounds.right = layout.getLineRight(1)
        bounds.top = layout.getLineTop(1).toFloat()
        bounds.bottom = layout.getLineBottom(1).toFloat()
        //绘制方形背景
        canvas.drawRect(bounds, paint)
        super.onDraw(canvas)
    }
}
#+END_SRC
- 这里会涉及到画笔Paint()、画布canvas、路径Path、绘画顺序等的一些知识点，后面再详细说明
*** 直接继承View
- 这种就是类似TextView等，不需要去轮询子View，只需要根据自己的需求重写onMeasure()、onLayout()、onDraw()等方法便可以，要注意点就是记得Padding等值要记得加入运算
#+BEGIN_SRC kotlin
private int getCalculateSize(int defaultSize, int measureSpec) {
    int finallSize = defaultSize;
    int mode = MeasureSpec.getMode(measureSpec);
    int size = MeasureSpec.getSize(measureSpec);
    //  根据模式对
    switch (mode) {
        case MeasureSpec.EXACTLY: 
            break;
        case MeasureSpec.AT_MOST: 
            break;
        case MeasureSpec.UNSPECIFIED: 
            break;
    }
    return finallSize;
}
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int width = getCalculateSize(120, widthMeasureSpec);
    int height = getCalculateSize(120, heightMeasureSpec);
    setMeasuredDimension(width, height);
}
@Override
protected void onDraw(Canvas canvas) { // 画一个圆
    // 调用父View的onDraw函数，因为View这个类帮我们实现了一些基本的而绘制功能，比如绘制背景颜色、背景图片等
    super.onDraw(canvas);
    int r = getMeasuredWidth() / 2;
    // 圆心的横坐标为当前的View的左边起始位置+半径
    int centerX = getLeft() + r;
    // 圆心的纵坐标为当前的View的顶部起始位置+半径
    int centerY = getTop() + r;
    Paint paint = new Paint();
    paint.setColor(Color.RED);
    canvas.drawCircle(centerX, centerY, r, paint);
}
#+END_SRC
*** 直接继承ViewGroup
- 类似实现LinearLayout等，可以去看那一下LinearLayout的实现 基本的你可能要重写onMeasure()、onLayout()、onDraw()方法,这块很多问题要处理包括轮训childView的测量值以及模式进行大小逻辑计算等，这个篇幅过大后期加多个文章写详细的
- 这里写个简单的需求，模仿LinearLayout的垂直布局
#+BEGIN_SRC kotlin
class CustomViewGroup :ViewGroup{
    constructor(context:Context):super(context)
    constructor(context: Context,attrs:AttributeSet):super(context,attrs){
        // 可获取自定义的属性等
    }
    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
        // 将所有的子View进行测量，这会触发每个子View的onMeasure函数
        measureChildren(widthMeasureSpec, heightMeasureSpec)
        val widthMode = MeasureSpec.getMode(widthMeasureSpec)
        val widthSize = MeasureSpec.getSize(widthMeasureSpec)
        val heightMode = MeasureSpec.getMode(heightMeasureSpec)
        val heightSize = MeasureSpec.getSize(heightMeasureSpec)
        val childCount = childCount
        if (childCount == 0) {
            // 没有子View的情况
            setMeasuredDimension(0, 0)
        } else {
            // 如果宽高都是包裹内容
            if (widthMode == MeasureSpec.AT_MOST && heightMode == MeasureSpec.AT_MOST) {
                // 我们将高度设置为所有子View的高度相加，宽度设为子View中最大的宽度
                val height = getTotalHeight()
                val width = getMaxChildWidth()
                setMeasuredDimension(width, height)
            } else if (heightMode == MeasureSpec.AT_MOST) {
                // 如果只有高度是包裹内容
                // 宽度设置为ViewGroup自己的测量宽度，高度设置为所有子View的高度总和
                setMeasuredDimension(widthSize, getTotalHeight())
            } else if (widthMode == MeasureSpec.AT_MOST) {// 如果只有宽度是包裹内容
            // 宽度设置为子View中宽度最大的值，高度设置为ViewGroup自己的测量值
            setMeasuredDimension(getMaxChildWidth(), heightSize)
        }
    }
    // 获取子View中宽度最大的值
    private fun getMaxChildWidth(): Int {
        val childCount = childCount
        var maxWidth = 0
        for (i in 0 until childCount) {
            val childView = getChildAt(i)
            if (childView.measuredWidth > maxWidth)
            maxWidth = childView.measuredWidth
        }
        return maxWidth
    }
    // 将所有子View的高度相加
    private fun getTotalHeight(): Int {
        val childCount = childCount
        var height = 0
        for (i in 0 until childCount) {
            val childView = getChildAt(i)
            height += childView.measuredHeight
        }
        return height
    }
}
override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {
    val count = childCount
    var currentHeight = t
    for (i in 0 until count) {
        val child = getChildAt(i)
        val h = child.measuredHeight
        val w = child.measuredWidth
        child.layout(l, currentHeight, l + w, currentHeight + h) // 摆放子view
        currentHeight += h
    }
}
#+END_SRC
- 主要两点 先 measureChildren()轮训遍历子View获取宽高,并根据测量模式逻辑计算最后所有的控件的所需宽高，最后setMeasuredDimension()保存一下 ###四、 View的绘制流程相关 最基本的三个相关函数 measure() ->layout()->draw()

** 四、onMeasure()相关的知识点
   
   [[./pic/onmeasure.png]]

*** 1. MeasureSpec
- MeasureSpec是View的内部类，它封装了一个View的尺寸，在onMeasure()当中会根据这个MeasureSpec的值来确定View的宽高。 
- MeasureSpec 的数据是int类型，有32位。 高两位表示模式，后面30位表示大小size。
- 则MeasureSpec = mode+size 三种模式分别为：EXACTLY, AT_MOST, UNSPECIFIED
  - EXACTLY: （match_parent或者 精确数据值）精确模式，对应的数值就是MeasureSpec当中的size
  - AT_MOST:(wrap_content)最大值模式，View的尺寸有一个最大值，View不超过MeasureSpec当中的Size值
  - UNSPECIFIED：（一般系统使用）无限制模式，View设置多大就给他多大
#+BEGIN_SRC kotlin
// 获取测量模式
val widthMode = MeasureSpec.getMode(widthMeasureSpec)
// 获取测量大小 
val widthSize = MeasureSpec.getSize(widthMeasureSpec)
// 通过Mode和Size构造MeasureSpec
val measureSpec = MeasureSpec.makeMeasureSpec(size, mode);
#+END_SRC
*** 2. View #onMeasure()源码
    #+BEGIN_SRC java
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
                         getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}
protected int getSuggestedMinimumWidth() {
    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
}
protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {
    boolean optical = isLayoutModeOptical(this);
    if (optical != isLayoutModeOptical(mParent)) {
        Insets insets = getOpticalInsets();
        int opticalWidth  = insets.left + insets.right;
        int opticalHeight = insets.top  + insets.bottom;
        measuredWidth  += optical ? opticalWidth  : -opticalWidth;
        measuredHeight += optical ? opticalHeight : -opticalHeight;
    }
    setMeasuredDimensionRaw(measuredWidth, measuredHeight);
}
public static int getDefaultSize(int size, int measureSpec) {
    int result = size;
    int specMode = MeasureSpec.getMode(measureSpec);
    int specSize = MeasureSpec.getSize(measureSpec);
    switch (specMode) {
    case MeasureSpec.UNSPECIFIED:
        result = size;
        break;
    case MeasureSpec.AT_MOST:
    case MeasureSpec.EXACTLY:
        result = specSize;
        break;
    }
    return result;
}
private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) {
    mMeasuredWidth = measuredWidth;
    mMeasuredHeight = measuredHeight;
    mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;
}
    #+END_SRC
- setMeasuredDimension(int measuredWidth, int measuredHeight) ：用来设置View的宽高，在我们自定义View保存宽高也会要用到。
- getSuggestedMinimumWidth()：当View没有设置背景时，默认大小就是mMinWidth，这个值对应Android:minWidth属性，如果没有设置时默认为0. 如果有设置背景，则默认大小为mMinWidth和mBackground.getMinimumWidth()当中的较大值。
- getDefaultSize(int size, int measureSpec)：用来获取View默认的宽高，在getDefaultSize()中对MeasureSpec.AT_MOST,MeasureSpec.EXACTLY两个的处理是一样的，我们自定义View的时候 要对两种模式进行处理。
*** 3. ViewGroup中并没有measure()也没有onMeasure()
- 因为ViewGroup除了测量自身的宽高，还需要测量各个子View的宽高，不同的布局测量方式不同 (例如 LinearLayout跟RelativeLayout等布局）,所以直接交由继承者根据自己的需要去复写。但是里面因为子View的测量是相对固定的，所以里面已经提供了基本的measureChildren()以及measureChild()来帮助我们对子View进行测量 这个可以看一下我另一篇文章：LinearLayout # onMeasure()LinearLayout onMeasure源码阅读

** 五、onLayout()相关
View.java的onLayout方法是空实现:因为子View的位置，是由其父控件的onLayout方法来确定的。
onLayout(int l, int t, int r, int b)中的参数l、t、r、b都是相对于其父 控件的位置。
自身的mLeft, mTop, mRight, mBottom都是相对于父控件的位置。
*** 1. Android坐标系
- 安卓屏幕的左上角为坐标原点，向右为X轴正向，向下为Y轴正向
*** 2. 内部View坐标系跟点击坐标
    
    [[./pic/view.png]]
    
*** 3. 看一下View#layout(int l, int t, int r, int b)源码
    #+BEGIN_SRC java
public void layout(int l, int t, int r, int b) {
    if ((mPrivateFlags3 & PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
        mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
    }
    int oldL = mLeft;
    int oldT = mTop;
    int oldB = mBottom;
    int oldR = mRight;
    boolean changed = isLayoutModeOptical(mParent) ?
        setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);
    if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
        onLayout(changed, l, t, r, b);
        //   ....省略其它部分
    }
}
private boolean setOpticalFrame(int left, int top, int right, int bottom) {
    Insets parentInsets = mParent instanceof View ?
        ((View) mParent).getOpticalInsets() : Insets.NONE;
    Insets childInsets = getOpticalInsets();
    return setFrame(
        left   + parentInsets.left - childInsets.left,
        top    + parentInsets.top  - childInsets.top,
        right  + parentInsets.left + childInsets.right,
        bottom + parentInsets.top  + childInsets.bottom);
}
protected boolean setFrame(int left, int top, int right, int bottom) {
    boolean changed = false;
    // ....省略其它部分
    if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {
        changed = true;
        int drawn = mPrivateFlags & PFLAG_DRAWN;
        int oldWidth = mRight - mLeft;
        int oldHeight = mBottom - mTop;
        int newWidth = right - left;
        int newHeight = bottom - top;
        boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);
        invalidate(sizeChanged);
        mLeft = left;
        mTop = top;
        mRight = right;
        mBottom = bottom;
        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);
        mPrivateFlags |= PFLAG_HAS_BOUNDS;
        if (sizeChanged) 
            sizeChange(newWidth, newHeight, oldWidth, oldHeight);
        if ((mViewFlags & VISIBILITY_MASK) == VISIBLE || mGhostView != null) {
            mPrivateFlags |= PFLAG_DRAWN;
            invalidate(sizeChanged);
            invalidateParentCaches();
        }
        mPrivateFlags |= drawn;
        mBackgroundSizeChanged = true;
        mDefaultFocusHighlightSizeChanged = true;
        if (mForegroundInfo != null) 
            mForegroundInfo.mBoundsChanged = true;
        notifySubtreeAccessibilityStateChangedIfNeeded();
    }
    return changed;
}
    #+END_SRC
- 四个参数l、t、r、b分别代表View的左、上、右、下四个边界相对于其父View的距离。 在调用onLayout(changed, l, t, r, b);之前都会调用到setFrame()确定View在父容器当中的位置，赋值给mLeft,mTop,mRight,mBottom。 在ViewGroup#onLayout()跟View#onLayout()都是空实现，交给继承者根据自身需求去定位
- 部分零散知识点：
  - getMeasureWidth()与getWidth() getMeasureWidth()返回的是mMeasuredWidth，而该值是在setMeasureDimension()中的setMeasureDimensionRaw()中设置的。因此onMeasure()后的所有方法都能获取到这个值。 getWidth返回的是mRight-mLeft，这两个值，是在layout()中的setFrame()中设置的. getMeasureWidthAndState中有一句： This should be used during measurement and layout calculations only. Use {@link #getWidth()} to see how wide a view is after layout.
  - 总结：只有在测量过程中和布局计算时，才用getMeasuredWidth()。在layout之后，用getWidth()来获取宽度

** 六、draw()绘画过程
   #+BEGIN_SRC java
 /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1\. Draw the background
         *      2\. If necessary, save the canvas' layers to prepare for fading
         *      3\. Draw view's content
         *      4\. Draw children
         *      5\. If necessary, draw the fading edges and restore layers
         *      6\. Draw decorations (scrollbars for instance)
         */
   #+END_SRC
- 上面是draw()里面写的绘画顺序。
  - 绘制背景。
  - 如果必要的话,保存当前canvas
  - 绘制View的内容
  - 绘制子View
  - 如果必要的话,绘画边缘重新保存图层
  - 画装饰(例如滚动条)
*** 1. 看一下View#draw()源码的实现
    #+BEGIN_SRC java
public void draw(Canvas canvas) {
    // Step 1, draw the background, if needed
    int saveCount;
    if (!dirtyOpaque) 
        drawBackground(canvas);

    // skip step 2 & 5 if possible (common case)

    final int viewFlags = mViewFlags;
    boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0;
    boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0;
    if (!verticalEdges && !horizontalEdges) {
        // Step 3, draw the content
        if (!dirtyOpaque) onDraw(canvas);

        // Step 4, draw the children
        dispatchDraw(canvas);
        drawAutofilledHighlight(canvas);

        // Overlay is part of the content and draws beneath Foreground
        if (mOverlay != null && !mOverlay.isEmpty()) 
            mOverlay.getOverlayView().dispatchDraw(canvas);

        // Step 6, draw decorations (foreground, scrollbars)
        onDrawForeground(canvas);

        // Step 7, draw the default focus highlight
        drawDefaultFocusHighlight(canvas);

        if (debugDraw()) 
            debugDrawFocus(canvas);
        return;
    }
}
    #+END_SRC
- 由上面可以看到 先调用drawBackground(canvas) ->onDraw(canvas)->dispatchDraw(canvas)->onDrawForeground(canvas)越是后面绘画的越是覆盖在最上层。
- drawBackground(canvas):画背景，不可重写
- onDraw(canvas)：画主体
  - 代码写在super.onDraw()前：会被父类的onDraw覆盖
  - 代码写在super.onDraw()后：不会被父类的onDraw覆盖
- dispatchDraw() ：绘制子 View 的方法
  - 代码写在super.dispatchDraw(canvas)前：把绘制代码写在 super.dispatchDraw() 的上面，这段绘制就会在 onDraw() 之后、 super.dispatchDraw() 之前发生，也就是绘制内容会出现在主体内容和子 View 之间。而这个…… 其实和重写 onDraw() 并把绘制代码写在 super.onDraw() 之后的做法，效果是一样的。
  - 代码写在super.dispatchDraw(canvas)后：只要重写 dispatchDraw()，并在 super.dispatchDraw() 的下面写上你的绘制代码，这段绘制代码就会发生在子 View 的绘制之后，从而让绘制内容盖住子 View 了。
- onDrawForeground(canvas)：包含了滑动边缘渐变和滑动条跟前景
  - 一般来说，一个 View（或 ViewGroup）的绘制不会这几项全都包含，但必然逃不出这几项，并且一定会严格遵守这个顺序。例如通常一个 LinearLayout 只有背景和子 View，那么它会先绘制背景再绘制子 View；一个 ImageView 有主体，有可能会再加上一层半透明的前景作为遮罩，那么它的前景也会在主体之后进行绘制。需要注意，前景的支持是在 Android 6.0（也就是 API 23）才加入的；之前其实也有，不过只支持 FrameLayout，而直到 6.0 才把这个支持放进了 View 类里。
    
[[./pic/drawprocess.png]]

*** 2. 注意事项
**** 2.1 在 ViewGroup 的子类中重写除 dispatchDraw() 以外的绘制方法时，可能需要调用 setWillNotDraw(false)；
- 出于效率的考虑，ViewGroup 默认会绕过 draw() 方法，换而直接执行 dispatchDraw()，以此来简化绘制流程。所以如果你自定义了某个 ViewGroup 的子类（比如 LinearLayout）并且需要在它的除 dispatchDraw() 以外的任何一个绘制方法内绘制内容，你可能会需要调用 View.setWillNotDraw(false) 这行代码来切换到完整的绘制流程（是「可能」而不是「必须」的原因是，有些 ViewGroup 是已经调用过 setWillNotDraw(false) 了的，例如 ScrollView）。
**** 2.2 在重写的方法有多个选择时，优先选择 onDraw()
- 一段绘制代码写在不同的绘制方法中效果是一样的，这时你可以选一个自己喜欢或者习惯的绘制方法来重写。但有一个例外：如果绘制代码既可以写在 onDraw() 里，也可以写在其他绘制方法里，那么优先写在 onDraw() ，因为 Android 有相关的优化，可以在不需要重绘的时候自动跳过 onDraw() 的重复执行，以提升开发效率。享受这种优化的只有 onDraw() 一个方法。
** 七、在Activity中获取View的宽高的几种方式
- Activity 获取 view 的宽高， 在 onCreate , onResume 等方法中获取到的都是0， 因为 View 的测量过程并不是和 Activity 的声明周期同步执行的
*** 1. view.post 
- post 可以将一个 runnable 投递到消息队列的尾部，然后等待 Looper 调用此 runnable 的时候， View 也已经初始化好了
    #+BEGIN_SRC java
view.post(new Runnable() {
    @Override
    public void run() {
        int width = view.getMeasuredWidth();
        int height = view.getMeasuredHeight(); 
    }
});
    #+END_SRC
*** 2. ViewTreeObserver 
- 使用 addOnGlobalLayoutListener 接口， 当 view 树的状态发生改变或者 View 树内部的 view 的可见性发生改变时， onGlobalLayout() 都会被调用， 需要注意的是， onGlobalLayout 方法可能被调用多次， 代码如下：
    #+BEGIN_SRC java
 view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                view.getViewTreeObserver().removeOnGlobalLayoutListener(this);
                int width = view.getMeasuredWidth();
                int height = view.getMeasuredHeight();
            }
        });
    #+END_SRC
*** 3. onWindowFocusChanged 
- 这个方法的含义是 View 已经初始化完毕了， 宽高已经准备好了， 需要注意的就是这个方法可能会调用多次， 在 Activity onResume 和onPause的时候都会调用， 也会有多次调用的情况
    #+BEGIN_SRC java
     @Override
    public void onWindowFocusChanged(boolean hasWindowFocus) {
        super.onWindowFocusChanged(hasWindowFocus);
        if (hasWindowFocus){
            int width = view.getMeasuredWidth();
            int height = view.getMeasuredHeight();
        }
    }
    #+END_SRC


** View 工作流程
- 通过 SetContentView()，调用 到PhoneWindow ，后实例DecorView ，通过 LoadXmlResourceParser() 进行IO操作 解析xml文件 通过反射 创建出View，并将View绘制在 DecorView上，这里的绘制则交给了ViewRootImpl 来完成，通过performTraversals() 触发绘制流程，performMeasure 方法获取View的尺寸，performLayout 方法获取View的位置 ，然后通过 performDraw 方法遍历View 进行绘制。
** 事件分发
- 一个 MotionEvent 产生后，按 Activity -> Window -> DecorView（ViewGroup） -> View 顺序传递，View 传递过程就是事件分发，因为开发过程中存在事件冲突，所以需要熟悉流程：
  - dispatchTouchEvent：用于分发事件，只要接受到点击事件就会被调用，返回结果表示是否消耗了当前事件
  - onInterceptTouchEvent：用于判断是否拦截事件（只有ViewGroup中存在），当 ViewGroup 确定要拦截事件后，该事件序列都不会再触发调用此 ViewGroup 的 onIntercept
  - onTouchEvent：用于处理事件，返回结果表示是否处理了当前事件，未处理则传递给父容器处理。（事件顺序是：OnTouchListener -> OnTouchEvent -> OnClick）
** 自定义View!!
准备自定义View方面的面试最简单的方法：

就是自己动手实现几个View（由简单到复杂）；
分析一些热门App中的自定义View的效果是怎么实现的；
阿里面试官： 自定义View跟绘制流程相关知识点？（标准参考解答，值得收藏）
- https://www.cnblogs.com/Android-Alvin/p/12297933.html
- View组件的绘制会调用draw(Canvas canvas)方法，draw过程中主要是先画Drawable背景，对 drawable调用setBounds()然后是draw(Canvas c)方法。有点注意的是背景drawable的实际大小会影响view组件的大小，drawable的实际大小通过getIntrinsicWidth()和getIntrinsicHeight()获取，当背景比较大时view组件大小等于背景drawable的大小。
- 画完背景后，draw过程会调用onDraw(Canvas canvas)方法，然后就是dispatchDraw(Canvas canvas)方法, dispatchDraw()主要是分发给子组件进行绘制，我们通常定制组件的时候重写的是onDraw()方法。值得注意的是ViewGroup容器组件的绘制，当它没有背景时直接调用的是dispatchDraw()方法, 而绕过了draw()方法，当它有背景的时候就调用draw()方法，而draw()方法里包含了dispatchDraw()方法的调用。因此要在ViewGroup上绘制东西的时候往往重写的是dispatchDraw()方法而不是onDraw()方法，或者自定制一个Drawable，重写它的draw(Canvas c)和 getIntrinsicWidth()。
- 最后是onTouchEvent()和onInterceptTouchEvent()方法，这两个方法也是我们经常会用到的。
  - onInterceptTouchEvent()方法定义在于ViewGroup中，默认返回值为false，表示不拦截TouchEvent()。
  - onTouchEvent()方法定义在View中，
  - 当ViewGroup要调用onTouchEvent()时，调用super.onTouchEvent()方法。ViewGroup调用onTouchEvent()默认返回false，表示不消耗touch事件，
  - View调用onTouchEvent()默认返回true，表示消耗了touch事件。


* ViewPager
- 这些以前遗露过的地方，基本上网上搜一搜、看一遍，再下载一两个小顶目看一下别人的实现，基本上的原本就懂了。记下来，方便改天（进阶探深或是）复习的时候参考
- 有一个顶目很强大，把它的源码好好读一下： WowoViewPager
- 有一个小小圆点的 _轮播指示器_ 稍微实现了一下，自己第一次去体会
#+BEGIN_SRC xml
tools:viewBindingIgnore="true"
#+END_SRC
  - 视图绑定在某个特定视图中的用法，居然也自己悟出来了；自己最终找出来的bug androidx里
  #+BEGIN_SRC java
binding.viewpager.addOnPageChangeListener(new ViewPager.OnPageChangeListener(){});
  #+END_SRC 
  - 也真是印象深刻，磨了一天，终于解决了自己有点儿兴趣却被bug住的小点儿问题。。。。。。  
** ViewPager简介
- ViewPager是android扩展包v4包中的类，这个类可以让用户左右切换当前的view：
  - ViewPager类直接继承了ViewGroup类，所有它是一个容器类，可以在其中添加其他的view类。
  - ViewPager类需要一个PagerAdapter适配器类给它提供数据。
  - ViewPager经常和Fragment一起使用，并且提供了专门的FragmentPagerAdapter和FragmentStatePagerAdapter类供Fragment中的ViewPager使用。
** ViewPager适配器
*** PagerAdapter
- 和ListView等控件使用一样,需要ViewPager设置PagerAdapter来完成页面和数据的绑定，这个PagerAdapter是一个基类适配器，它的子类有FragmentPagerAdapter和FragmentStatePagerAdapter,这两个子类适配器用于和Fragment一起使用。
- 实现一个最基本的PagerAdapter，必须实现四个方法：
#+BEGIN_SRC java
public class MyAdapter extends PagerAdapter {
    private List<View> mViewList;
    public AdapterViewpager(List<View> mViewList) {
        this.mViewList = mViewList;
    }
    @Override
    public int getCount() {  // 返回要滑动的VIew的个数
        return mViewList.size();
    }
    @Override
    public boolean isViewFromObject(View view, Object object) {// 当前的页面是否与给定的键相关联
        return view == object;
    }
    @Override
    public Object instantiateItem(ViewGroup container, int position) {  // 做了两件事，第一：将当前视图添加到container中，第二：返回当前View
        container.addView(mViewList.get(position));
        return mViewList.get(position);
    }
    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {  // 从当前container中删除指定位置（position）的View
        container.removeView(mViewList.get(position));
    }
}
#+END_SRC 
- 原理解析：
  - viewpager不直接处理每一个视图而是将各个视图与一个键（Key）联系起来。这个键用来跟踪且唯一代表一个页面，不仅如此，该键还独立于这个页面所在adapter的位置。当pagerAdapter将要改变的时候他会调用startUpdate函数，接下来会调用一次或多次的instantiateItem或者destroyItem。最后在更新的后期会调用finishUpdate。当finishUpdate返回时 instantiateItem返回的对象应该添加到父ViewGroup destroyItem返回的对象应该被ViewGroup删除。isViewFromObject(View, Object)代表了当前的页面是否与给定的键相关联。
  - instantiateItem 返回一个代表新增视图页面的Object（Key），这里没必要非要返回视图本身，也可以这个页面的其它容器。其实我的理解是可以代表当前页面的任意值，只要你可以与你增加的View一一对应即可，比如position变量也可以做为Key。
  - isViewFromObject用来判断instantiateItem函数所返回来的Key的视图与一个页面视图是否代表的同一个视图（即它俩是否是对应的，对应的表示同一个View），如果对应的是同一个View，返回True，否则返回False。
  - 对于非常简单的pagerAdapter你可以选择用page本身作为键，在创建并且添加到viewgroup后instantiateItem方法里返回该page本身即可destroyItem将会将该page从viewgroup里面移除。isViewFromObject方法里面直接可以返回view == object。我们上面例子正是这么做的。
- 自定义Key实例：
#+BEGIN_SRC java
public class MyAdapter extends PagerAdapter {
    private List<View> mViewList;
    public AdapterViewpager(List<View> mViewList) {
        this.mViewList = mViewList;
    }
    @Override
    public int getCount() {
        return mViewList.size();
    }
    @Override
    public boolean isViewFromObject(View view, Object object) { // 根据传来的key，找到view,判断与传来的参数View view是不是同一个视图  
         return view == mViewList.get((int)Integer.parseInt(object.toString()));  
    }
    @Override
    public Object instantiateItem(ViewGroup container, int position) {
        container.addView(mViewList.get(position));
        // 把当前新增视图的位置（position）作为Key传过去  
        return position; 
    }
    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
        container.removeView(mViewList.get(position));
    }
}
#+END_SRC 
*** FragmentPagerAdapter/FragmentStatePagerAdapter
- 对于FragmentPagerAdapter/FragmentStatePagerAdapter的派生类，只需要重写getItem(int)和getCount()就可以了。
- 实现一个最基本的FragmentPagerAdapter：
#+BEGIN_SRC java
public class FragAdapter extends FragmentPagerAdapter {
    private List<Fragment> mFragments;
    public FragAdapter(FragmentManager fm, List<Fragment> mFragments) {
        super(fm);
        this.mFragments = mFragments;
    }
    @Override
    public Fragment getItem(int position) {// 必须实现
        return mFragments.get(position);
    }
    @Override
    public int getCount() {// 必须实现
        return mFragments.size();
    }
    @Override
    public CharSequence getPageTitle(int position) {// 选择性实现
        return mFragments.get(position).getClass().getSimpleName();
    }
}
#+END_SRC 
- FragmentStatePagerAdapter的实现和FragmentPagerAdapter的实现一样就不在写了。
#+BEGIN_SRC java
// 构造适配器  
List<Fragment> fragments=new ArrayList<Fragment>();  
fragments.add(new Fragment1());  
fragments.add(new Fragment2());  
fragments.add(new Fragment3());   
FragAdapter adapter = new FragAdapter(getSupportFragmentManager(), fragments);
#+END_SRC 
- 相比PagerAdapter，FragmentPagerAdapter和FragmentStatePagerAdapter更专注于每一页是Fragment的情况，而这两个子类适配器使用情况也是有区别的。
  - FragmentPagerAdapter适用于页面比较少的情况，
  - FragmentStatePagerAdapter适用于页面比较多的情况。为什么？简单分析下两个适配器的源码就可以知道了。
- FragmentStatePagerAdapter：
#+BEGIN_SRC java
@Override
  public Object instantiateItem(ViewGroup container, int position) {
      //  If we already have this item instantiated, there is nothing
      //  to do.  This can happen when we are restoring the entire pager
      //  from its saved state, where the fragment manager has already
      //  taken care of restoring the fragments we previously had instantiated.
      if (mFragments.size() > position) {
          Fragment f = mFragments.get(position);// fragment被释放后这里得到的null值
          if (f != null) 
              return f;
      }
      if (mCurTransaction == null) 
          mCurTransaction = mFragmentManager.beginTransaction();
      Fragment fragment = getItem(position);// fragment被释放后或者是初次进入页面拿到新的Fragment实例
      if (DEBUG) Log.v(TAG, "Adding item #" + position + ": f=" + fragment);
      if (mSavedState.size() > position) {
          Fragment.SavedState fss = mSavedState.get(position);
          if (fss != null) {
              fragment.setInitialSavedState(fss);
          }
      }
      while (mFragments.size() <= position) 
          mFragments.add(null);
      fragment.setMenuVisibility(false);
      fragment.setUserVisibleHint(false);
      mFragments.set(position, fragment);
      mCurTransaction.add(container.getId(), fragment);// 新的Fragment实例是add上去的
      return fragment;
  }
 @Override
  public void destroyItem(ViewGroup container, int position, Object object) {
      Fragment fragment = (Fragment) object;
      if (mCurTransaction == null) {
          mCurTransaction = mFragmentManager.beginTransaction();
      }
      if (DEBUG) Log.v(TAG, "Removing item #" + position + ": f=" + object  + " v=" + ((Fragment)object).getView());
      while (mSavedState.size() <= position) {
          mSavedState.add(null);
      }
      mSavedState.set(position, fragment.isAdded()? mFragmentManager.saveFragmentInstanceState(fragment) : null);
      mFragments.set(position, null); // 真正释放了fragment实例
      mCurTransaction.remove(fragment);
}
#+END_SRC 
- FragmentPagerAdapter：
#+BEGIN_SRC java
@Override
  public Object instantiateItem(ViewGroup container, int position) {
      if (mCurTransaction == null) {
          mCurTransaction = mFragmentManager.beginTransaction();
      }
      final long itemId = getItemId(position);
      //  Do we already have this fragment?
      String name = makeFragmentName(container.getId(), itemId);
      Fragment fragment = mFragmentManager.findFragmentByTag(name);
      if (fragment != null) {
          if (DEBUG) Log.v(TAG, "Attaching item #" + itemId + ": f=" + fragment);
          mCurTransaction.attach(fragment);// 因为fragment实例没有被真正释放，所以可以直接attach效率高
      } else {
          fragment = getItem(position);// 初始化页面的时候拿到fragment的实例
          if (DEBUG) Log.v(TAG, "Adding item #" + itemId + ": f=" + fragment);
          mCurTransaction.add(container.getId(), fragment,makeFragmentName(container.getId(), itemId));// add上去
      }
      if (fragment != mCurrentPrimaryItem) {
          fragment.setMenuVisibility(false);
          fragment.setUserVisibleHint(false);
      }
      return fragment;
  }
  @Override
  public void destroyItem(ViewGroup container, int position, Object object) {
      if (mCurTransaction == null) {
          mCurTransaction = mFragmentManager.beginTransaction();
      }
      if (DEBUG) Log.v(TAG, "Detaching item #" + getItemId(position) + ": f=" + object  + " v=" + ((Fragment)object).getView());
      mCurTransaction.detach((Fragment)object); // 并没有真正释放fragment对象只是detach
  }
#+END_SRC 
- 从源码中我们可以看出FragmentStatePagerAdapter中fragment实例在destroyItem的时候被真正释放，所以FragmentStatePagerAdapter省内存。FragmentPagerAdapter中的fragment实例在destroyItem的时候并没有真正释放fragment对象只是detach，所以FragmentPagerAdapter消耗更多的内存，带来的好处就是效率更高一些。所以得出这样的结论：FragmentPagerAdapter适用于页面比较少的情况，FragmentStatePagerAdapter适用于页面比较多的情况，因此不同的场合选择合适的适配器才是正确的做法。
- FragmentPagerAdapter适合在较少Fragment滑动切换的界面使用的，划过的fragment会保存在内存中，尽管已经划过。而FragmentStatePagerAdapter和ListView有点类似，只会保存当前界面，以及下一个界面和上一个界面（如果有），最多保存3个，其他会被销毁掉。
  - 最后要注意的是FragmentStatePagerAdapter可能不经意间会造成内存未正常回收，严重导致内存溢出，比如图片资源没有释放，资源引用问题。（之前在网上看到过EditText由于保存焦点导致Fragment未被释放而导致OOM，设置edtText.saveEanble(false)就可以解决此问题)。最后PagerAdapter都只是数据集，数据集的改变只能发生在主线程里并且以必须调用notifyDataSetChanged() 来通知完成更新。
*** 关于使用中发现，在删除或者修改数据的时候，PagerAdapter无法像BaseAdapter那样仅通过notifyDataSetChanged方法通知刷新View。
- 通常情况下调用notifyDataSetChanged方法会让ViewPager通过Adapter的getItemPosition方法查询一遍所有child view，如果所有child view位置均为POSITION_NONE，表示所有的child view都不存在，ViewPager会调用destroyItem方法销毁，并且重新生成，从而加大系统开销，并在一些复杂情况下导致逻辑问题。特别是对于只是希望更新child view内容的时候，但造成了完全不必要的开销，
- 列表内容如果是针对于child view比较简单的情况（例如仅有TextView、ImageView等，没有ListView等展示数据的情况），可以重写PagerAdapter的方法getItemPosition
#+BEGIN_SRC java
@Override    
public int getItemPosition(Object object) {    
    return POSITION_NONE;    
}
#+END_SRC 
- 但复杂的情况则需要根据自己的需求来实现notifyDataSetChanged的功能，比如，在仅需要对某个View内容进行更新时，在instantiateItem()时，用View.setTag方法加入标志，在需要更新信息时，通过findViewWithTag的方法找到对应的View进行局部更新。
** ViewPager 动画
-    本节介绍ViewPager动画，可以分为两类，第一类是针对于ViewPager的界面滑动动画(这个是PageTransformer的真正用途)，分析并比较了AndroidImageSlider和JazzyViewPager两种实现，第二类是对ViewPager中的内容进行动画处理，这个是这个是PageTransformer的巧妙应用，处理好了可以达到很棒的交互效果，示例是Yahoo天气的视差效果。
*** AndroidImageSlider
- 从3.0开始，ViewPager支持自定义切换动画，暴露的接口为PageTransformer，因此只要实现PageTransformer接口和其唯一的方法transformPage(View view, float position)即可。
#+BEGIN_SRC java
public interface PageTransformer {
     public void transformPage(View page, float position);
}
setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer);
#+END_SRC 
- 参数position—–给定界面的位置相对于屏幕中心的偏移量。在用户滑动界面的时候，是动态变化的。那么我们可以将position的值应用于setAlpha(), setTranslationX(), or setScaleY()方法，从而实现自定义的动画效果。
- 另外在ViewPager滑动时，内存中存活的Page都会执行transformPage方法，在滑动过程中涉及到两个Page，当前页和下一页，而它们 的position值是相反的（因为是相对运动,一个滑入一个滑出），比如，页面A向右滑动到屏幕一半，页面B也正好处于一半的位置，那么A和B的 position为：0.5 和 -0.5
  - position == 0 ：当前界面位于屏幕中心的时候
  - position == 1 ：当前Page刚好滑出屏幕右侧
  - position == -1 ：当前Page刚好滑出屏幕左侧
- 官方提供了PageTransformer的实现例子：
#+BEGIN_SRC java
public class DepthPageTransformer implements ViewPager.PageTransformer {
    private static final float MIN_SCALE = 0.75f;
    public void transformPage(View view, float position) {
        Log.d("DepthPageTransformer", view.getTag() + " , " + position + "");
        int pageWidth = view.getWidth();
        if (position < -1) { //  [-Infinity,-1)
            //  This page is way off-screen to the left.
            view.setAlpha(0);
        } else if (position <= 0) { //  [-1,0]
            //  Use the default slide transition when moving to the left page
            view.setAlpha(1);
            view.setTranslationX(0);
            view.setScaleX(1);
            view.setScaleY(1);
        } else if (position <= 1) { //  (0,1]
            //  Fade the page out.
            view.setAlpha(1 - position);
            //  Counteract the default slide transition
            view.setTranslationX(pageWidth * -position);
            //  Scale the page down (between MIN_SCALE and 1)
            float scaleFactor = MIN_SCALE
                    + (1 - MIN_SCALE) * (1 - Math.abs(position));
            view.setScaleX(scaleFactor);
            view.setScaleY(scaleFactor);
        } else { //  (1,+Infinity]
            //  This page is way off-screen to the right.
            view.setAlpha(0);
        }
    }
}
public class ZoomOutPageTransformer implements ViewPager.PageTransformer {
    private static final float MIN_SCALE = 0.85f;
    private static final float MIN_ALPHA = 0.5f;
    @SuppressLint("NewApi")
    public void transformPage(View view, float position) {
        int pageWidth = view.getWidth();
        int pageHeight = view.getHeight();
        Log.e("TAG", view + " , " + position + "");
        if (position < -1) { //  [-Infinity,-1)
            //  This page is way off-screen to the left.
            view.setAlpha(0);
        } else if (position <= 1) 
        { //  [-1,1]
            //  Modify the default slide transition to shrink the page as well
            float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position));
            float vertMargin = pageHeight * (1 - scaleFactor) / 2;
            float horzMargin = pageWidth * (1 - scaleFactor) / 2;
            if (position < 0) {
                view.setTranslationX(horzMargin - vertMargin / 2);
            } else {
                view.setTranslationX(-horzMargin + vertMargin / 2);
            }
            //  Scale the page down (between MIN_SCALE and 1)
            view.setScaleX(scaleFactor);
            view.setScaleY(scaleFactor);
            //  Fade the page relative to its size.
            view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE)
                    / (1 - MIN_SCALE) * (1 - MIN_ALPHA));
        } else { //  (1,+Infinity]
            //  This page is way off-screen to the right.
            view.setAlpha(0);
        }
    }
}
#+END_SRC 
- 使用：
#+BEGIN_SRC java
mViewPager.setPageTransformer(true, new DepthPageTransformer());
mViewPager.setPageTransformer(true, new ZoomOutPageTransformer());
#+END_SRC 
- AndroidImageSlider就是基于这种实现的。
  
[[./pic/sliderlayout.png]]

- 上图是AndroidImageSlider的架构，最核心的类是SliderLayout，他继承自相对布局，包含了可以左右滑动切换的SliderView，以及页面指示器PagerIndicator。这两个都可以自定义，常规的用法是：使用TextSliderView+自定义PagerIndicator，下面对常规用法就行介绍。
- （1）添加依赖
#+BEGIN_SRC groovy
    compile 'com.squareup.picasso:picasso:2.5.2'
    compile 'com.nineoldandroids:library:2.4.0'
    compile 'com.daimajia.slider:library:1.1.5@aar'
#+END_SRC
  - 建议全部的依赖项目统一使用最新的版本，因为依赖的项目之间可能也会存在依赖，避免冲突。
- （2）在布局文件中放置SliderLayout以及PagerIndicator（如果不添加则用默认的Indicator）。注意布局中我是通过相对布局把PagerIndicator压在SliderLayout之上的。
  #+BEGIN_SRC xml
<RelativeLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <com.daimajia.slider.library.SliderLayout
        android:id="@+id/slider"
        android:layout_width="match_parent"
        android:layout_height="200dp">
        <com.daimajia.slider.library.Indicators.PagerIndicator
            android:id="@+id/custom_indicator"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentBottom="true"
            android:layout_centerHorizontal="true"
            android:layout_marginBottom="10dp"
            custom:selected_color="@color/colorPrimary"
            custom:selected_height="3dp"
            custom:selected_padding_left="2dp"
            custom:selected_padding_right="2dp"
            custom:selected_width="16dp"
            custom:shape="rect"
            custom:unselected_color="#55333333"
            custom:unselected_height="3dp"
            custom:unselected_padding_left="2dp"
            custom:unselected_padding_right="2dp"
            custom:unselected_width="16dp"/>
    </com.daimajia.slider.library.SliderLayout>
</RelativeLayout>
  #+END_SRC
- （3）代码实现，主要步骤是：
  - 准备好要显示的数据，包括图片（本地或网络地址都可以）和图片描述等。
  - 新建若干个TextSliderView并且设置好数据以及相应的监听，最后添加到SliderLayout里面。
  - 对SliderLayout进行一些个性化的设置，比如动画，自定义PagerIndicator，每一个广告的延时时间等。
  - 最后别忘了在布局摧毁的时候，调用sliderLayout.stopAutoCycle();方法停止广告的轮播，以释放资源。
#+BEGIN_SRC java
public class SecondActivity extends ActionBarActivity implements BaseSliderView.OnSliderClickListener, ViewPagerEx.OnPageChangeListener{
    private SliderLayout mDemoSlider;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
        mDemoSlider = (SliderLayout)findViewById(R.id.slider);
        HashMap<String,String> url_maps = new HashMap<String, String>();
        url_maps.put("Hannibal", "http:// static2.hypable.com/wp-content/uploads/2013/12/hannibal-season-2-release-date.jpg");
        url_maps.put("Big Bang Theory", "http:// tvfiles.alphacoders.com/100/hdclearart-10.png");
        url_maps.put("House of Cards", "http:// cdn3.nflximg.net/images/3093/2043093.jpg");
        url_maps.put("Game of Thrones", "http:// images.boomsbeat.com/data/images/full/19640/game-of-thrones-season-4-jpg.jpg");
        HashMap<String,Integer> file_maps = new HashMap<String, Integer>();
        file_maps.put("nemo",R.mipmap.nemo);
        file_maps.put("toystory",R.mipmap.toystory);
        file_maps.put("up",R.mipmap.up);
        file_maps.put("wall", R.mipmap.wall);
        for(String name : url_maps.keySet()){
            TextSliderView textSliderView = new TextSliderView(this);
            //  initialize a SliderLayout
            textSliderView
                    .description(name)
                    .image(url_maps.get(name))
                    .setScaleType(BaseSliderView.ScaleType.Fit)
                    .setOnSliderClickListener(this);
            // add your extra information
            textSliderView.bundle(new Bundle());
            textSliderView.getBundle().putString("extra",name);
            mDemoSlider.addSlider(textSliderView);
        }
        mDemoSlider.setPresetTransformer(SliderLayout.Transformer.Accordion);// 设置过渡动画
        mDemoSlider.setPresetIndicator(SliderLayout.PresetIndicators.Center_Bottom); // Indicator位置
        mDemoSlider.setCustomAnimation(new DescriptionAnimation()); // 底部文字展现的动画
        mDemoSlider.setDuration(5000);
        mDemoSlider.addOnPageChangeListener(this);
        ListView l = (ListView)findViewById(R.id.transformers);
        l.setAdapter(new TransformerAdapter(this));
        l.setOnItemClickListener(new AdapterView.OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                mDemoSlider.setPresetTransformer(((TextView) view).getText().toString());
                Toast.makeText(SecondActivity.this, ((TextView) view).getText().toString(), Toast.LENGTH_SHORT).show();
            }
        });
    }
    @Override
    protected void onStop() {
        //  To prevent a memory leak on rotation, make sure to call stopAutoCycle() on the slider before activity or fragment is destroyed
        mDemoSlider.stopAutoCycle();
        super.onStop();
    }
    @Override
    public void onSliderClick(BaseSliderView slider) {
        Toast.makeText(this,slider.getBundle().get("extra") + "",Toast.LENGTH_SHORT).show();
    }
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater menuInflater = getMenuInflater();
        menuInflater.inflate(R.menu.main,menu);
        return super.onCreateOptionsMenu(menu);
    }
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()){
            case R.id.action_custom_indicator:
             /**设置自定义的indicator，否则是默认的*/
              mDemoSlider.setCustomIndicator((PagerIndicator) findViewById(R.id.custom_indicator));
                break;
            case R.id.action_custom_child_animation:
            /**设置自定义底部文字展现的动画，否则是默认的*/ 
                mDemoSlider.setCustomAnimation(new ChildAnimationExample());
                break;
            case R.id.action_restore_default:
                mDemoSlider.setPresetIndicator(SliderLayout.PresetIndicators.Center_Bottom);
                mDemoSlider.setCustomAnimation(new DescriptionAnimation());
                break;
            case R.id.action_github:
                Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse("https:// github.com/daimajia/AndroidImageSlider"));
                startActivity(browserIntent);
                break;
        }
        return super.onOptionsItemSelected(item);
    }
    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {}
    @Override
    public void onPageSelected(int position) {
        Log.d("Slider Demo", "Page Changed: " + position);
    }
    @Override
    public void onPageScrollStateChanged(int state) {}
}
#+END_SRC 
- AndroidImageSlider提供的动画有很多：
#+BEGIN_SRC java
SliderLayout.Transformer.Default
SliderLayout.Transformer.Accordion
SliderLayout.Transformer.Background2Foreground
SliderLayout.Transformer.CubeIn
SliderLayout.Transformer.DepthPage
SliderLayout.Transformer.Fade
SliderLayout.Transformer.FlipHorizontal
SliderLayout.Transformer.FlipPage
SliderLayout.Transformer.Foreground2Background
SliderLayout.Transformer.RotateDown
SliderLayout.Transformer.RotateUp
SliderLayout.Transformer.Stack
SliderLayout.Transformer.Tablet
SliderLayout.Transformer.ZoomIn
SliderLayout.Transformer.ZoomOutSlide
SliderLayout.Transformer.ZoomOut
#+END_SRC 
- 注：如果你还是想用以前的ViewPager，只是单纯想应用这些动画怎么办呢？
- 我已经将library中的所有动画分离出来，可以下载我后面的demo，在文件夹Transformers下可以找到所有的动画，使用上面说的setPageTransformer即可。
- 因为library中动画使用的是ViewHelper，需要添加依赖：
#+BEGIN_SRC groovy
compile 'com.nineoldandroids:library:2.4.0'
#+END_SRC
*** JazzyViewPager
- JazzyViewPager的实现方式略显复杂，没有使用PageTransformer接口的transformPage方法，而是使用了OnPageChangeListener接口的onPageScrolled方法。
#+BEGIN_SRC java
public interface OnPageChangeListener {
     onPageScrolled(int position, float positionOffset, int positionOffsetPixels);
}
#+END_SRC 
- 下面简单的看下JazzyViewPager库的动画实现，它将positionOffset作为参数控制。由于positionOffset的值为[0,1),所以就需要分别处理正负的情况。另外JazzyViewPager是通过维护一个LinkedHashMap来持有Page的引用。在Adapter添加界面的时候，会调用JazzyViewPager的 setObjectForPosition(Object obj, int position) 方法存入到集合中去。然后在onPageScrolled方法中再根据position获取当前Page的前一个mLeft和后一个mRight界面，分别对前后两个界面添加动画。
- （1）添加依赖
#+BEGIN_SRC groovy
 compile 'com.nineoldandroids:library:2.4.0'
#+END_SRC
- （2）添加属性文件attrs.xml，ID文件ids.xml以及字符串列表文件String.xml。
- （3）引入文件: JazzyViewPager, OutlineContainer, Util
- （5）代码实现
#+BEGIN_SRC xml
<RelativeLayout xmlns:android="http:// schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >
    <com.hx.viewpager.JazzyViewPager.JazzyViewPager
        android:id="@+id/jazzy_pager"
        android:layout_width="fill_parent"
        android:layout_height="200dp" />
</RelativeLayout>
#+END_SRC
#+BEGIN_SRC java
public class ThirdActivity extends AppCompatActivity {
    private JazzyViewPager mJazzy;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_third);
        setupJazziness(JazzyViewPager.TransitionEffect.Tablet);
    }
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        menu.add("Toggle Fade");
        String[] effects = this.getResources().getStringArray(R.array.jazzy_effects);
        for (String effect : effects)
            menu.add(effect);
        return true;
    }
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getTitle().toString().equals("Toggle Fade")) {
            mJazzy.setFadeEnabled(!mJazzy.getFadeEnabled());
        } else {
            JazzyViewPager.TransitionEffect effect = JazzyViewPager.TransitionEffect.valueOf(item.getTitle().toString());
            setupJazziness(effect);
        }
        return true;
    }
    private void setupJazziness(JazzyViewPager.TransitionEffect effect) {
        mJazzy = (JazzyViewPager) findViewById(R.id.jazzy_pager);
        mJazzy.setTransitionEffect(effect); // 设置动画
        mJazzy.setAdapter(new MainAdapter());
        mJazzy.setPageMargin(30); // 每页Pager的距离
    }
    private class MainAdapter extends PagerAdapter {
        @Override
        public Object instantiateItem(ViewGroup container, final int position) {
            TextView text = new TextView(ThirdActivity.this);
            text.setGravity(Gravity.CENTER);
            text.setTextSize(30);
            text.setTextColor(Color.WHITE);
            text.setText("Page " + position);
            text.setPadding(30, 30, 30, 30);
            int bg = Color.rgb((int) Math.floor(Math.random()*128)+64,
                    (int) Math.floor(Math.random()*128)+64,
                    (int) Math.floor(Math.random()*128)+64);
            text.setBackgroundColor(bg);
            container.addView(text, ViewPager.LayoutParams.MATCH_PARENT, ViewPager.LayoutParams.MATCH_PARENT);
            // 当viewpager超过三个view时，需要保存
            mJazzy.setObjectForPosition(text, position);
            return text;
        }
        @Override
        public void destroyItem(ViewGroup container, int position, Object obj) {
            container.removeView(mJazzy.findViewFromObject(position));
        }
        @Override
        public int getCount() {
            return 10;
        }
        @Override
        public boolean isViewFromObject(View view, Object obj) {
            if (view instanceof OutlineContainer) {
                return ((OutlineContainer) view).getChildAt(0) == obj;
            } else {
                return view == obj;
            }
        }
    }
}
#+END_SRC 
- 小结：
  - 上面主要介绍了ViewPager的Page的滑动动画，两种实现方式：
  - PageTransformer.transformPage 方式：在执行onPageScrolled方法的时候，会遍历ViewPager的所有View，并执行其transformPage方法。position是已经处理好的（方向和值）。
  onPageScrolled 方式：略显复杂，因为没法拿到View，还要自己去维护一个View集合，并且positionOffset的限制，需要自己去处理不同View的position : PageA：position , PageB：-(1-position)。
** 视差动画
- 实现原理：为ViewPage内部的View处理不同的平移速度，达到视差的效果，一般我们可以通过ViewPager.PageTransformer来实现这样的效果。github上有现成的例子我们可以拿来用ParallaxPagerTransformer。
#+BEGIN_SRC java
public class ParallaxPagerTransformer implements ViewPager.PageTransformer {
    private int id;
    private int border = 0;
    private float speed = 0.2f;
    public ParallaxPagerTransformer(int id) {
        this.id = id;
    }
    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
    @Override
    public void transformPage(View view, float position) {
        View parallaxView = view.findViewById(id);
        if (view == null ) {
            Log.w("ParallaxPager", "There is no view");
        }
        if (parallaxView != null && Build.VERSION.SDK_INT > Build.VERSION_CODES.HONEYCOMB ) {
            if (position > -1 && position < 1) {
                float width = parallaxView.getWidth();
                parallaxView.setTranslationX(-(position * width * speed)); // 乘以speed系数，减缓移动速度
                float sc = ((float)view.getWidth() - border)/ view.getWidth();
                if (position == 0) {
                    view.setScaleX(1);
                    view.setScaleY(1);
                } else {
                    view.setScaleX(sc);
                    view.setScaleY(sc);
                }
            }
        }
    }
    public void setBorder(int px) {
        border = px;
    }
    public void setSpeed(float speed) {
        this.speed = speed;
    }
}
mPager = (ViewPager) findViewById(R.id.id_viewpager);
        mPager.setBackgroundColor(0xFF000000);
        mAdapter = new DemoParallaxAdapter(getSupportFragmentManager(), fragmentList);
        mPager.setAdapter(mAdapter);
        /**image这个ID需要是pager的子view，这里写在fragment中*/
        ParallaxPagerTransformer pt = new ParallaxPagerTransformer((R.id.image));
        pt.setBorder(20);
        pt.setSpeed(0.2f);
        mPager.setPageTransformer(false, pt);
#+END_SRC 
- R.id.image写在Fragment中，见布局文件：
#+BEGIN_SRC xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http:// schemas.android.com/apk/res/android"
    android:id="@+id/root"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ImageView
        android:id="@+id/image"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerHorizontal="true"
        android:layout_centerVertical="true"
        android:scaleType="fitXY"
        android:src="@mipmap/nemo" />
    <TextView
        android:id="@+id/name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:textAppearance="?android:attr/textAppearanceLarge"
        android:textColor="#FFFFFFFF"
        android:text="nemo"
        android:textSize="72sp"
        android:textStyle="bold" />
</RelativeLayout>
#+END_SRC

** 指示器 ViewPager Indicator
- 上面讲AndroidImageSlider的时候其实我们已经使用过Indicator，这里我要介绍的是大神JakeWharton早在五年前就开源的ViewPagerIndicator库。下载链接。
- 查看Viewpager Indicator的Library代码，可以看到此项目的设计思想：首先一个pageIndicator接口类，具体样式的导航类实现该接口，然后根据具体样式去实现相应的逻辑。
- IcsLinearLayout：LinearLayout 的扩展，支持了 4.0 以上的 divider 特性。
- CirclePageIndicator、LinePageIndicator、UnderlinePageIndicator、TitlePagerIndicator 继承自View。
- TabPageIndicator、IconPageIndicator 继承自 HorizontalScrollView。
  - 首先一个indicator必须要与一个ViewPager关联在一起，所以它提供了一个setViewPager方法。
  - 它扩展了ViewPager.OnPageChangeListener接口，表示接管了ViewPager的Pager改变时的监听处理，这也是为什么为ViewPager设置OnPageChangeListener监听器时不能设置在ViewPager上而必须设置在indicator上的原因。
  - 还有一个notifyDataSetChanged通知方法，表示为这个ViewPager提供View(一般是Fragment)的Adapter 里面的数据集发生变化时，执行的动作，这里可增加相关的逻辑。
- （1）添加依赖
  - 在项目的build.gradle中添加：
#+BEGIN_SRC groovy
allprojects {
        repositories {
                        maven { url "https:// jitpack.io" }
        }
    }
#+END_SRC
- 在模块（app）的build.gradle中添加：
#+BEGIN_SRC groovy
dependencies {
            compile 'com.github.JakeWharton:ViewPagerIndicator:2.4.1'
    }
#+END_SRC
- （2）代码实现
#+BEGIN_SRC xml
<RelativeLayout xmlns:android="http:// schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <android.support.v4.view.ViewPager
        android:id="@+id/id_viewpager"
        android:layout_width="fill_parent"
        android:layout_height="200dp"/>
    <com.viewpagerindicator.CirclePageIndicator
        android:id="@+id/indicator"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignBottom="@+id/id_viewpager"
        android:layout_marginBottom="10dp"
        app:radius="5dp"
        app:fillColor="#ff0000"
        app:pageColor="#ffffff"
        app:strokeColor="#0000ff"
        app:strokeWidth="1dp"/>
</RelativeLayout>
#+END_SRC
#+BEGIN_SRC java
mViewPager = (ViewPager) findViewById(R.id.id_viewpager);
indicator = (CirclePageIndicator) findViewById(R.id.indicator);
mViewPager.setAdapter(new MyAdapter());
indicator.setViewPager(mViewPager);
// OnPageChangeListener要设置在Indicator上，不能像之前那样设置在ViewPager上了
indicator.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {
       @Override
       public void onPageSelected(int arg0) {
           Toast.makeText(getApplicationContext(), mTitle[arg0], Toast.LENGTH_SHORT).show();
       }
       @Override
       public void onPageScrolled(int arg0, float arg1, int arg2) {}
       @Override
       public void onPageScrollStateChanged(int arg0) {}
});
#+END_SRC 
- 注：用以修改指示的颜色和大小等属性，CirclePageIndicator提供以下属性：
#+BEGIN_SRC xml
<declare-styleable name="CirclePageIndicator">
        <!-- 指示标识是否居中 -->
        <attr name="centered" />
        <!-- 当前选择指示的颜色 -->
        <attr name="fillColor" format="color" />
        <!-- 当前未被选择指示的颜色 -->
        <attr name="pageColor" format="color" />
        <!-- 指示的布局方式，水平还是垂直 -->
        <attr name="android:orientation" />
        <!-- 指示的大小 -->
        <attr name="radius" format="dimension" />
        <!-- 指示是否快速滑动 -->
        <attr name="snap" format="boolean" />
        <!-- 描边的颜色 -->
        <attr name="strokeColor" format="color" />
        <!-- 描边的宽度 -->
        <attr name="strokeWidth" />
        <!-- 指示整体的背景色 -->
        <attr name="android:background" />
    </declare-styleable>
#+END_SRC
- 其他更多Indicator的用法请自行摸索。
** 其他知识点
*** 循环滑动
- 官方提供的ViewPager不能循环滑动，当从左向右滑动到最后一页后，如果想再滑到第一页，则必须再从右向左滑动到第一页。
- 无限循环的viewpager有两种实现方式：
  - （1）对ViewPager初始化的时候，给它填充固定数目的足够多的虚拟的页面空间，在视图渲染的时候利用虚拟位置对实际页面总数的求余实现虚拟位置与实际位置的转换。
  - （2）通过监听viewpager的滑动来设置页面。如当前有数据123，则设置页面为31231，当页面滑动到第一个3时，设置当前页面为第二个3，那么左右都可以滑动，当其滑动到第二个1时同理。
- 这里我来实现第一种：
#+BEGIN_SRC java
// 设置缓存的页面数量,超出则释放
mViewPager.setOffscreenPageLimit(4);
// 初始ViewPager设置到中间位置
mViewPager.setCurrentItem(Integer.MAX_VALUE/2);
public class MyAdapter extends PagerAdapter {
        @Override
        public Object instantiateItem(ViewGroup container, int position) {
            ImageView imageView = new ImageView(getApplicationContext());
            imageView.setScaleType(ImageView.ScaleType.FIT_XY);
            imageView.setImageResource(mImgIds[position % mImgIds.length]);
            container.addView(imageView);
            return imageView;
        }
        @Override
        public void destroyItem(ViewGroup container, int position, Object object) {
            // 之前设置过了最多缓存4页，所以会自动释放，不要担心OOM
            //  container.removeView(mImageViews.get(position));
        }
        @Override
        public boolean isViewFromObject(View view, Object object) {
            return view == object;
        }
        @Override
        public int getCount() {
            if (mImgIds.length <= 1) {
                return 1;
            } else {
                return Integer.MAX_VALUE;
            }
        }
    }
#+END_SRC 
*** 一屏显示多个页面
- 原理就一个属性Android:clipChildren=”false”,该属性的意思就是在子View进行绘制时不要去裁切它们的显示范围。
#+BEGIN_SRC xml
<FrameLayout
    android:layout_width="match_parent"
    android:layout_height="160dp"
    android:clipChildren="false"
    android:layout_centerInParent="true"
    android:background="#aadc71ff">
    <android.support.v4.view.ViewPager
        android:id="@+id/id_viewpager"
        android:layout_width="match_parent"
        android:layout_marginLeft="60dp"
        android:layout_marginRight="60dp"
        android:clipChildren="false"
        android:layout_height="120dp"
        android:layout_gravity="center">
    </android.support.v4.view.ViewPager>
</FrameLayout>
#+END_SRC
- 我们设置了ViewPager外层控件以及ViewPager都设置了android:clipChildren=”false”。
- 这个属性默认是true，作用就是限制子view在父View范围内显示。 加了这个属性意思是ViewPager中间图片的两边可以显示部分左右两边的图片。同时要在逻辑代码中加viewPager.setPageMargin()设置间距
- 注意LinearLayout和ViewPager都要设置，否则没有效果。
- ViewPager的宽度是match_parent，左后个设置了60dp的边距，就是为了显示出左右部分的Page。
#+BEGIN_SRC java
 // 设置Page间间距
mViewPager.setPageMargin(20);
#+END_SRC 
*** 预加载
    #+BEGIN_SRC java
// 设置缓存的页面数量
mViewPager.setOffscreenPageLimit(4);
    #+END_SRC 
*** PagerTabStrip与PagerTitleStrip添加标题栏
- 在Android.support.v4包中的两个控件PagerTabStrip与PagerTitleStrip，他们都是用来实现标题栏的，但各自有些不同，在这篇文章中，我们就讲讲它们各自都能实现怎样的功能，又有哪些异同点
- PagerTitleStrip的官方解释
  - PagerTitleStrip是ViewPager的一个关于当前页面、上一个页面和下一个页面的一个非交互的指示器。它经常作为ViewPager控件的一个子控件被被添加在XML布局文件中。在你的布局文件中，将它作为子控件添加在ViewPager中。而且要将它的
  #+BEGIN_SRC xml
  android:layout_gravity
  #+END_SRC
  - 属性设置为TOP或BOTTOM来将它显示在ViewPager的顶部或底部。每个页面的标题是通过适配器的getPageTitle(int)函数提供给ViewPager的
- PagerTabStrip
  - PagerTabStrip的官方解释
    - PagerTabStrip是ViewPager的一个关于当前页面、上一个页面和下一个页面的一个可交互的指示器。它经常作为ViewPager控件的一个子控件被被添加在XML布局文件中。在你的布局文件中，将它作为子控件添加在ViewPager中。而且要将它的
    - android:layout_gravity
    - 属性设置为TOP或BOTTOM来将它显示在ViewPager的顶部或底部。每个页面的标题是通过适配器的getPageTitle(int)函数提供给ViewPager的
    - PagerTabStrip与PagerTitleStrip的不同
- 除了第一句以外的其它句与PagerTitleStrip的解释完全相同。只是PagerTabStrip是可交互的，而PagerTitleStrip是不可交互的区别。
  - 1、PagerTabStrip在当前页面下，会有一个下划线条来提示当前页面的Tab是哪个。
  - 2、PagerTabStrip的Tab是可以点击的，当用户点击某一个Tab时，当前页面就会跳转到这个页面，而PagerTitleStrip则没这个功能。
