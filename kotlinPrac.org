#+latex_class: cn-article
#+title: Kotlin Grammer
#+author: deepwaterooo

* 空安全

** 可空类型与非空类型
- Kotlin 的类型系统旨在消除来自代码空引用的危险，也称为《十亿美元的错误》。
- 许多编程语言（包括 Java）中最常见的陷阱之一，就是访问空引用的成员会导致空引用异常。在 Java 中，这等同于 NullPointerException 或简称 NPE。
- Kotlin 的类型系统旨在从我们的代码中消除 NullPointerException。NPE 的唯一可能的原因可能是：
  - 显式调用 throw NullPointerException()；
  - 使用了下文描述的 !! 操作符；
  - 有些数据在初始化时不一致，例如当：
    - 传递一个在构造函数中出现的未初始化的 this 并用于其他地方（“泄漏 this”）；
    - 超类的构造函数调用一个开放成员，该成员在派生中类的实现使用了未初始化的状态；
  - Java 互操作：
    - 企图访问平台类型的 null 引用的成员；
    - 用于具有错误可空性的 Java 互操作的泛型类型，例如一段 Java 代码可能会向 Kotlin 的 MutableList<String> 中加入 null，这意味着应该使用 MutableList<String?> 来处理它；
    - 由外部 Java 代码引发的其他问题。
- 在 Kotlin 中，类型系统区分一个引用可以容纳 null （可空引用）还是不能容纳（非空引用）。 例如，String 类型的常规变量不能容纳 null：
#+BEGIN_SRC kotlin
var a: String = "ab"
var a: String = "abc" // 默认情况下，常规初始化意味着非空
a = null // 编译错误
#+END_SRC
- 如果要允许为空，我们可以声明一个变量为可空字符串，写作 String?：
#+BEGIN_SRC kotlin
var b: String? = "abc" // 可以设置为空
b = null // ok
print(b)
#+END_SRC
- 现在，如果你调用 a 的方法或者访问它的属性，它保证不会导致 NPE，这样你就可以放心地使用：
#+BEGIN_SRC kotlin
val l = a.length
#+END_SRC
- 但是如果你想访问 b 的同一个属性，那么这是不安全的，并且编译器会报告一个错误：
#+BEGIN_SRC kotlin
val l = b.length // 错误：变量“b”可能为空
#+END_SRC
- 但是我们还是需要访问该属性，对吧？有几种方式可以做到。

** 在条件中检测 null
- 首先，你可以显式检测 b 是否为 null，并分别处理两种可能：
#+BEGIN_SRC kotlin
val l = if (b != null) b.length else -1
#+END_SRC
- 编译器会跟踪所执行检测的信息，并允许你在 if 内部调用 length。 同时，也支持更复杂（更智能）的条件：
#+BEGIN_SRC kotlin
val b: String? = "Kotlin"
if (b != null && b.length > 0) {
    print("String of length ${b.length}")
} else {
    print("Empty string")
}
// String of length 6
#+END_SRC
- 请注意，这只适用于 b 是不可变的情况（即在检测和使用之间没有修改过的局部变量 ，或者不可覆盖并且有幕后字段的 val 成员），因为否则可能会发生在检测之后 b 又变为 null 的情。况

** 安全的调用
- 你的第二个选择是安全调用操作符，写作 ?.：
#+BEGIN_SRC kotlin
val a = "Kotlin"
val b: String? = null
println(b?.length)
println(a?.length) // 无需安全调用
#+END_SRC
- 如果 b 非空，就返回 b.length，否则返回 null，这个表达式的类型是 Int?。
- 安全调用在链式调用中很有用。例如，如果一个员工 Bob 可能会（或者不会）分配给一个部门， 并且可能有另外一个员工是该部门的负责人，那么获取 Bob 所在部门负责人（如果有的话）的名字，我们写作：
#+BEGIN_SRC kotlin
bob?.department?.head?.name
#+END_SRC
- 如果任意一个属性（环节）为空，这个链式调用就会返回 null。
- 如果要只对非空值执行某个操作，安全调用操作符可以与 let 一起使用：
#+BEGIN_SRC kotlin
val listWithNulls: List<String?> = listOf("Kotlin", null)
for (item in listWithNulls) {
    item?.let { println(it) } // 输出 Kotlin 并忽略 null
}
#+END_SRC
- 安全调用也可以出现在赋值的左侧。这样，如果调用链中的任何一个接收者为空都会跳过赋值，而右侧的表达式根本不会求值：
#+BEGIN_SRC kotlin
// 如果 `person` 或者 `person.department` 其中之一为空，都不会调用该函数：
person?.department?.head = managersPool.getManager()
#+END_SRC

** Elvis 操作符
- 当我们有一个可空的引用 b 时，我们可以说“如果 b 非空，我使用它；否则使用某个非空的值”：
#+BEGIN_SRC kotlin
val l: Int = if (b != null) b.length else -1
val l: Int = if (b != null) b.length else -1
#+END_SRC
- 除了完整的 if-表达式，这还可以通过 Elvis 操作符表达，写作 ?:：
#+BEGIN_SRC kotlin
val l = b?.length ?: -1
val l = b?.length ?: -1
#+END_SRC
- 如果 ?: 左侧表达式非空，elvis 操作符就返回其左侧表达式，否则返回右侧表达式。 请注意， _当且仅当左侧为空时，才会对右侧表达式求值。_
- 请注意， _因为 throw 和 return 在 Kotlin 中都是表达式，所以它们也可以用在 elvis 操作符右侧。这可能会非常方便，例如，检测函数参数：_
#+BEGIN_SRC kotlin
fun foo(node: Node): String? { // <<<==== 返回值可为空
    val parent = node.getParent() ?: return null
    val name = node.getName() ?: throw IllegalArgumentException("name expected")
    // ……
}
#+END_SRC

** !! 操作符： 非空断言运算符（!!）
- 第三种选择是为 NPE 爱好者准备的：非空断言运算符（!!）将任何值转换为非空类型，若该值为空则抛出异常。我们可以写 b!! ，这会返回一个非空的 b 值 （例如：在我们例子中的 String）或者如果 b 为空，就会抛出一个 NPE 异常：
#+BEGIN_SRC kotlin
val l = b!!.length
#+END_SRC
- 因此，如果你想要一个 NPE，你可以得到它，但是你必须显式要求它，否则它不会不期而至。

** 安全的类型转换
如果对象不是目标类型，那么常规类型转换可能会导致 ClassCastException。 另一个选择是使用安全的类型转换，如果尝试转换不成功则返回 null：
#+BEGIN_SRC kotlin
val aInt: Int? = a as? Int
#+END_SRC

** 可空类型的集合
- 如果你有一个可空类型元素的集合，并且想要过滤非空元素，你可以使用 filterNotNull 来实现：
#+BEGIN_SRC kotlin
val nullableList: List<Int?> = listOf(1, 2, null, 4)
val intList: List<Int> = nullableList.filterNotNull()
#+END_SRC
* Kotlin中常量和静态方法
** 常量
*** Java中：
    #+BEGIN_SRC java
    class StaticDemoActivity {
         public static final String LOAN_TYPE = "loanType";
         public static final String LOAN_TITLE = "loanTitle";
    }
    #+END_SRC
*** Kotlin中：
    #+BEGIN_SRC java
class StaticDemoActivity {
    companion object {
        val LOAN_TYPE = "loanType"
        val  LOAN_TITLE = "loanTitle"
    }
}
class StaticDemoActivity {
    companion object StaticParams{
        val  LOAN_TYPE = "loanType"
        val  LOAN_TITLE = "loanTitle"
    }
}
class StaticDemoActivity {
    companion object {
        const val LOAN_TYPE = "loanType"
        const val LOAN_TITLE = "loanTitle"
    }
}
    #+END_SRC
- 注：const 关键字用来修饰常量，且只能修饰 val，不能修饰var, companion object 的名字可以省略，可以使用 Companion来指代
*** 引用常量（这里的引用只针对于java引用kotlin代码）
-     TestEntity类引用StaticDemoActivity中的常量
#+BEGIN_SRC java
class TestEntity {
    public TestEntity () {
        String title = StaticDemoActivity.Companion.getLOAN_TITLE();
    }
}
class TestEntity {
    public TestEntity () {
        String title = StaticDemoActivity.StaticParams.getLOAN_TITLE();
    }
}
class TestEntity {
    public TestEntity () {
        String title = StaticDemoActivity.LOAN_TITLE;
        String type= StaticDemoActivity.LOAN_TYPE;
    }
}
#+END_SRC
** 静态方法
    - Java代码：
    #+BEGIN_SRC java
    class StaticDemoActivity {
        public static void test(){
        } 
    }
    #+END_SRC
- Kotlin中：
#+BEGIN_SRC java
    class StaticDemoActivity {
        companion object {
            fun test(){
            }
        }
    }
    class StaticDemoActivity {
        companion object StaticParams{
            fun test() {
            }    
        }
    }
#+END_SRC
*** 引用静态方法（这里的引用只针对于java引用kotlin代码）
- TestEntity类引用StaticDemoActivity中的静态方法
#+BEGIN_SRC java
class TestEntity {
    public TestEntity () {
        StaticDemoActivity.Companion.test();
    }
}
class TestEntity {
    public TestEntity () {
        StaticDemoActivity.StaticParams.test();
    }
}
#+END_SRC
- companion object {}中用来修饰 静态常量，或者静态方法，单例等等

* Kotlin中的object 与companion object的区别
- 区别：
  - companion object 类中只能一个 声明周期跟类同步，Only one companion object is allowed per class
  - objcet 没有限制声明  更多用在对象声明，对象表达式使用。
    - 可以声明在类里  也可以声明在顶级包下 top-level declaration
- 使用原则：       
  - 如果想写工具类的功能，直接创建文件，写 top-level「顶层」函数。（声明在包下）
  - 如果需要继承别的类或者实现接口，就用 object 或 companion object。

** 一、 object关键字
- object 关键字可以表达两种含义：一种是对象表达式,另一种是 对象声明。
*** 1、对象表达式
- 继承一个匿名对象
#+BEGIN_SRC java
val textView = findViewById<TextView>(R.id.tv)
textView.setOnClickListener(object : OnClickListener {
        override fun onClick(p0: View?) {
            Toast.makeText(this@TestActivity, "点击事件生效", Toast.LENGTH_LONG)
        }
 
})
#+END_SRC
- 上面代码其实就是我们经常要给 view 设置的点击事件，OnClickListener 事件是一个匿名类的对象，用object来修饰。
*** 2、对象声明
- 用object 修饰的类为静态类，里面的方法和变量都为静态的。
**** 2.1 直接声明类
     #+BEGIN_SRC java
object DemoManager {
    private val TAG = "DemoManager"
    fun a() {
        Log.e(TAG,"此时 object 表示 声明静态内部类")
    }
}
     #+END_SRC
**** 2.2 声明静态内部类
- 类内部的对象声明，没有被inner 修饰的内部类都是静态的
#+BEGIN_SRC java
class DemoManager{
    object MyObject {
        fun a() {
            Log.e(TAG,"此时 object 表示 直接声明类")
        }
    }
}
#+END_SRC
- 如果需要调用 a()方法
- kotlin中调用
#+BEGIN_SRC java
fun init() {
    MyObject.a()
}
#+END_SRC
- java中调用
#+BEGIN_SRC java
 MyObject.INSTANCE.a();
#+END_SRC
 
** 二、companion object
- companion object 修饰为伴生对象,伴生对象在类中只能存在一个，类似于java中的静态方法 Java 中使用类访问静态成员，静态方法。
#+BEGIN_SRC java
companion object {
    private val TAG = "DemoManager"
    fun b() {
        Log.e(TAG,"此时 companion objec t表示 伴生对象")
    }
}
#+END_SRC
- kotlin 中调用
#+BEGIN_SRC java
fun init(){
   b()
}
#+END_SRC
- java 中调用
#+BEGIN_SRC java
DemoManager.Companion.b();
#+END_SRC
- companion object 相关的内容可以查阅 Kotlin中常量和静态方法 这篇文章，在这里不多在具体描述。
** 三、在companion object中如何调用外部的成员变量
*** 3.1 为什么companion object 中调用不到外部成员变量
    #+BEGIN_SRC java
class DemoManager {
    private val MY_TAG = "DemoManager"
    fun init(){
       b()
    }
    companion object {
        fun b() {
            Log.e(MY_TAG,"此时 companion objec t表示 伴生对象")
        }
    }
}
    #+END_SRC
- 在上面代码中MY_TAG 是不会被调用到的。
- 原理很简单：
- 在java中我们写一个静态方法，如果需要调用成员变量，是无法调用到的
#+BEGIN_SRC java
private String TAG = "MainActivity";
public static void init(){
    Log.e(TAG,"init() ");
}
#+END_SRC
- 只有将 TAG 修改为静态成员变量才能调用到
#+BEGIN_SRC java
private static String TAG = "MainActivity";
public static void init(){
    Log.e(TAG,"init() ");
}
#+END_SRC
- 由此可以看出来，java中静态方法调用成员变量，要求成员变量必须是静态的， 在kotlin 中也是一样，所以当companion object 中调用非静态的成员变量也是调用不到的。
*** 3.2 怎样解决才能调用到呢？
    #+BEGIN_SRC java
companion object {
    private val MY_TAG = "DemoManager"
    fun b() {
        Log.e(MY_TAG,"此时 companion objec t表示 伴生对象")
    }
}
    #+END_SRC
- 将所引用的成员变量也修饰静态的，这样就可以引用到了。
- 再透彻一点，偏源码与反编译一点儿的： https://www.cnblogs.com/webor2006/p/11210181.html
- https://juejin.cn/post/6844903816446345224

* 伴生对象：  A few facts about Companion objects（写得比较深和透彻一点儿）
- Kotlin给Java开发者带来最大改变之一就是废弃了static修饰符。与Java不同的是在Kotlin的类中不允许你声明静态成员或方法。相反，你必须向类中添加Companion对象来包装这些静态引用: 差异看起来似乎很小，但是它有一些明显的不同。
- 首先，companion伴生对象是个实际对象的单例实例。你实际上可以在你的类中声明一个单例，并且可以像companion伴生对象那样去使用它。这就意味着在实际开发中，你不仅仅只能使用一个静态对象来管理你所有的静态属性! companion这个关键字实际上只是一个快捷方式，允许你通过类名访问该对象的内容(如果伴生对象存在一个特定的类中，并且只是用到其中的方法或属性名称，那么伴生对象的类名可以省略不写)。就编译而言，下面的testCompanion（）方法中的三行都是有效的语句。
#+BEGIN_SRC kotlin
class TopLevelClass {
    companion object {
        fun doSomeStuff() {
        }
    }
    object FakeCompanion {
        fun doOtherStuff() {
        }
    }
}
fun testCompanion() {
    TopLevelClass.doSomeStuff()
    TopLevelClass.Companion.doSomeStuff()
    TopLevelClass.FakeCompanion.doOtherStuff()
}
#+END_SRC
- 为了兼容的公平性，companion关键字还提供了更多选项，尤其是与Java互操作性相关选项。果您尝试在Java类中编写相同的测试代码，调用方式可能会略有不同：
#+BEGIN_SRC java
public void testCompanion() {
    TopLevelClass.Companion.doSomeStuff();
    TopLevelClass.FakeCompanion.INSTANCE.doOtherStuff();
}
#+END_SRC
- 区别在于: Companion作为Java代码中静态成员开放(实际上它是一个对象实例，但是由于它的名称是以大写的C开头，所以有点存在误导性)，而FakeCompanion引用了我们的第二个单例对象的类名。在第二个方法调用中，我们需要使用它的INSTANCE属性来实际访问Java中的实例(你可以打开IntelliJ IDEA或AndroidStudio中的"Show Kotlin Bytecode"菜单栏，并点击里面"Decompile"按钮来查看反编译后对应的Java代码)
- 在这两种情况下(不管是Kotlin还是Java)，使用伴生对象Companion类比FakeCompanion类那种调用语法更加简短。此外，由于Kotlin提供一些注解，可以让编译器生成一些简短的调用方式，以便于在Java代码中依然可以像在Kotlin中那样简短形式调用。
- @JvmField注解，例如告诉编译器不要生成getter和setter,而是生成Java中成员。在伴生对象的作用域内使用该注解标记某个成员，它产生的副作用是标记这个成员不在伴生对象内部作用域，而是作为一个Java最外层类的静态成员存在。从Kotlin的角度来看，这没有什么太大区别，但是如果你看一下反编译的字节代码，你就会注意到伴生对象以及他的成员都声明和最外层类的静态成员处于同一级别。
- 另一个有用的注解 @JvmStatic.这个注解允许你调用伴生对象中声明的方法就像是调用外层的类的静态方法一样。但是需要注意的是：在这种情况下，方法不会和上面的成员一样移出伴生对象的内部作用域。因为编译器只是向外层类中添加一个额外的静态方法，然后在该方法内部又委托给伴生对象。
- 一起来看一下这个简单的Kotlin类例子:
#+BEGIN_SRC kotlin
class MyClass {
    companion object {
        @JvmStatic
        fun aStaticFunction() {}
    }
}
#+END_SRC
- 这是相应编译后的Java简化版代码:
#+BEGIN_SRC java
public class MyClass {
    public static final MyClass.Companion Companion = new MyClass.Companion();
    fun aStaticFunction() {//外层类中添加一个额外的静态方法
        Companion.aStaticFunction();//方法内部又委托给伴生对象的aStaticFunction方法
    }
    public static final class Companion {
         public final void aStaticFunction() {}
    }
}
#+END_SRC
- 这里存在一个非常细微的差别，但在某些特殊的情况下可能会出问题。例如，考虑一下Dagger中的module(模块)。当定义一个Dagger模块时，你可以使用静态方法去提升性能，但是如果你选择这样做，如果您的模块包含静态方法以外的任何内容，则编译将失败。由于Kotlin在类中既包含静态方法，也保留了静态伴生对象，因此无法以这种方式编写仅仅包含静态方法的Kotlin类。
- 但是不要那么快放弃! 这并不意味着你不能这样做，只是它需要一个稍微不同的处理方式：在这种特殊的情况下，你可以使用Kotlin单例(使用object对象表达式而不是class类)替换含有静态方法的Java类并在每个方法上使用@JvmStatic注解。如下例所示：在这种情况下，生成的字节代码不再显示任何伴生对象，静态方法会附加到类中。
#+BEGIN_SRC kotlin
@Module
object MyModule {
    @Provides
    @Singleton
    @JvmStatic
    fun provideSomething(anObject: MyObject): MyInterface {
        return myObject
    }
}
#+END_SRC
- 这又让你再一次明白了伴生对象仅仅是单例对象的一个特例。但它至少表明与许多人的认知是相反的，你不一定需要一个伴生对象来维护静态方法或静态变量。你甚至根本不需要一个对象来维护，只要考虑顶层函数或常量：它们将作为静态成员被包含在一个自动生成的类中(默认情况下，例如MyFileKt会作为MyFile.kt文件生成的类名，一般生成类名以Kt为后缀结尾)
- 我们有点偏离这篇文章的主题了，所以让我们继续回到伴生对象上来。现在你已经了解了伴生对象实质就是对象，也应该意识到它开放了更多的可能性，例如继承和多态。
- 这意味着你的伴生对象并不是没有类型或父类的匿名对象。它不仅可以拥有父类，而且它甚至可以实现接口以及含有对象名。它不需要被称为companion。这就是为什么你可以这样写一个Parcelable类：
#+BEGIN_SRC kotlin
class ParcelableClass() : Parcelable {
    constructor(parcel: Parcel) : this()
    override fun writeToParcel(parcel: Parcel, flags: Int) {}
    override fun describeContents() = 0
    companion object CREATOR : Parcelable.Creator<ParcelableClass> {
        override fun createFromParcel(parcel: Parcel): ParcelableClass = ParcelableClass(parcel)
        override fun newArray(size: Int): Array<ParcelableClass?> = arrayOfNulls(size)
    }
}
#+END_SRC
- 这里, 伴生对象名为CREATOR，它实现了Android中的Parcelable.Creator接口，允许遵守Parcelable约定，同时保持比使用@JvmField注释在伴随对象内添加Creator对象更直观。Kotlin中引入了@Parcelize注解，以便于可以获得所有样板代码，但是在这不是重点...
- 为了使它变得更简洁，如果你的伴生对象可以实现接口，它甚至可以使用Kotlin中的代理来执行此操作：
#+BEGIN_SRC kotlin
class MyObject {
    companion object : Runnable by MyRunnable()
}
#+END_SRC
- 这将允许您同时向多个对象中添加静态方法！请注意，伴生对象在这种情况下甚至不需要作用域体，因为它是由代理提供的。
- 最后但同样重要的是，你可以为伴生对象定义扩展函数! 这就意味着你可以在现有的类中添加静态方法或静态属性，如下例所示:
#+BEGIN_SRC kotlin
class MyObject {
    companion object
    fun useCompanionExtension() {
        someExtension()
    }
}
fun MyObject.Companion.someExtension() {}//定义扩展函数
#+END_SRC
- 这样做有什么意义？我真的不知道。虽然Marcin Moskala建议使用此操作将静态工厂方法以Companion的扩展函数的形式添加到类中。
- 总而言之，伴生对象不仅仅是为了给缺少static修饰符的使用场景提供解决方案:
- 它们是真正的Kotlin对象，包括名称和类型，以及一些额外的功能。
- 他们甚至可以不用于仅仅为了提供静态成员或方法场景。可以有更多其他选择，比如他们可以用作单例对象或替代顶层函数的功能。
- 与大多数场景一样，Kotlin意味着在你设计过程需要有一点点转变，但与Java相比，它并没有真正限制你的选择。如果有的话，也会通过提供一些新的、更简洁的方式让你去使用它。
- https://cloud.tencent.com/developer/article/1381584 这个某天上午的时候再读一遍就可以了
- http://www.4k8k.xyz/article/u013064109/89199478 这个没读，扫一眼

* Kotlin-查看Kotlin编译成class后代码的三种方式
** 在AndroidStudio中查看
- 第一步：选择你要查看你的kotlin文件，然后点击Tools-->Kotlin-->Show Kotlin Bytecode
- 第二步：点击左上角的 Decompile 按钮就会弹出你想要的class源码
** 方法二
- 利用命令行 javap [option] *.class 命令
|-------------+-----------------------------------------------------------------|
| 子命令      | 输出信息                                                        |
|-------------+-----------------------------------------------------------------|
| -l          | 输出行和变量的表                                                |
| -public     | 只输出公共的方法和成员                                          |
| -protected  | 只输出public和protected类和成员                                 |
| -package    | 只输出包，public和protected类和成员，这是默认情况               |
| -p -private | 输出所有类和成员                                                |
| -s          | 输出内部类型签名                                                |
| -c          | 对代码进行反汇编。 eg：类中每一个方法内，包含 java 字节码的指令 |
| -verbose    | 输出栈大小，方法参数的个数                                      |
| -costants   | 输出静态 final 常量                                             |
|-------------+-----------------------------------------------------------------|
- 样码
#+BEGIN_SRC kotlin
class TestMain {
    public val msg1 = "类中的变量"
    private val msg2 = "类中的变量"
    companion object {
        val msg3 = "伴生对象的变量"
    }
}
val msg4 = "Kotlin文件中的变量"
fun sayHello(msg: String) {
    println("msg=$msg")
}
fun main() {
    val msg5 = "我要看你的class文件"
    sayHello(msg5)
}
#+END_SRC
- Javap -public 输出结果
  -  Javap -public     输出公共的方法和成员 
- 输出的结果为
#+BEGIN_SRC java
// javap -public TestMainKt.class
// Compiled from "TestMain.kt"
public final class com.yobo.yobo_kotlin.TestMainKt {
  public static final java.lang.String getMsg2();
  public static final void sayHello(java.lang.String);
  public static final void main();
  public static void main(java.lang.String[]);
}
// javap -public TestMain.class
// Compiled from "TestMain.kt"
public final class com.yobo.yobo_kotlin.TestMain {
  public static final com.yobo.yobo_kotlin.TestMain$Companion Companion;
  public final java.lang.String getMsg1();
  public com.yobo.yobo_kotlin.TestMain();
  public static final java.lang.String access$getMsg3$cp();
}
#+END_SRC
- javap -p -private 
  - javap -p -private  显示所有的类和成员
- javap -p -private  TestMainKt.class
#+BEGIN_SRC java
public final class com.yobo.yobo_kotlin.TestMainKt {
  private static final java.lang.String msg4;
  public static final java.lang.String getMsg4();
  public static final void sayHello(java.lang.String);
  public static final void main();
  public static void main(java.lang.String[]);
  static {};
}
#+END_SRC 
- Javap -c 输出结果
  -  Javap -c    对代码进行反汇编。 eg：类中每一个方法内，包含 java 字节码的
- 可以看到虽然是把我们整个class文件进行了反编译，但是可读性不是很好，这时候我们就推荐第二种方法。
#+BEGIN_SRC java
public final class com.yobo.yobo_kotlin.TestMainKt {
  public static final java.lang.String getMsg2();
    Code:
       0: getstatic     #13                 // Field msg2:Ljava/lang/String;
       3: areturn

  public static final void sayHello(java.lang.String);
    Code:
       0: aload_0
       1: ldc           #17                 // String msg
       3: invokestatic  #23                 // Method kotlin/jvm/internal/Intrinsics.checkParameterIsNotNull:(Ljava/lang/Object;Ljava/lang/String;)V
       6: new           #25                 // class java/lang/StringBuilder
       9: dup
      10: invokespecial #29                 // Method java/lang/StringBuilder."<init>":()V
      13: ldc           #31                 // String msg=
      15: invokevirtual #35                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      18: aload_0
      19: invokevirtual #35                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      22: invokevirtual #38                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      25: astore_1
      26: iconst_0
      27: istore_2
      28: getstatic     #44                 // Field java/lang/System.out:Ljava/io/PrintStream;
      31: aload_1
      32: invokevirtual #50                 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
      35: return
 
  public static final void main();
    Code:
       0: ldc           #56                 // String 我要看你的class文件
       2: astore_0
       3: aload_0
       4: invokestatic  #58                 // Method sayHello:(Ljava/lang/String;)V
       7: return
 
  public static void main(java.lang.String[]);
    Code:
       0: invokestatic  #54                 // Method main:()V
       3: return
 
  static {};
    Code:
       0: ldc           #8                  // String Kotlin文件中的变量
       2: putstatic     #13                 // Field msg2:Ljava/lang/String;
       5: return
}
#+END_SRC
** Jadx反编译工具
- 先给出工具的GitHub地址，可以按照自己喜欢的方式安装并查看功能文档：
  - https://github.com/skylot/jadx

* Synchronized、Volatile
** 如何创建线程 Thread
在Kotlin 中，我们仍然可以使用 java 的语法创建一个线程
#+BEGIN_SRC kotlin
Thread(Runnable { 
}).start()
// 或者使用 Lambda 表达式
Thread {
}.start()  
#+END_SRC
事实上，kotlin 为我们提供了一个简单写法：
Kotlin中可以使用thread()方法创建新的线程，指定的语句块将在新线程中运行。语法简单，十分易用。
#+BEGIN_SRC kotlin
fun main() {
    thread {
        Log.d("yanjun", "开启一个线程")
    }
}
#+END_SRC
用法够简单吧。你会好奇thread {}到底是什么黑科技，其实很简单，语法糖而已。 其实是一个 thread() {} 函数
#+BEGIN_SRC kotlin
public fun thread(start: Boolean = true,
                  isDaemon: Boolean = false,
                  contextClassLoader: ClassLoader? = null,
                  name: String? = null,
                  priority: Int = -1,
                  block: () -> Unit
): Thread {
    val thread = object : Thread() {
        public override fun run() {
            block()
        }
    }
    if (isDaemon) thread.isDaemon = true
    if (priority > 0) thread.priority = priority
    if (name != null) thread.name = name
    if (contextClassLoader != null) thread.contextClassLoader = contextClassLoader
    if (start) thread.start()   
    return thread
}
#+END_SRC
- 可以看到 start 参数默认为 true ，自动执行线程。当然也可以通过 name 字段指定线程的名字：
#+BEGIN_SRC kotlin
fun main() {
    //指定线程的名字，是否自动执行
    thread(start = true, name = "my_thread") {
    }
}
#+END_SRC
** 如何使用 Synchronized 同步锁
- 在Java中，给一个方法加锁 ，需要给方法加 synchronized 关键字
#+BEGIN_SRC java
public synchronized void run() {
}
#+END_SRC
- kotlin 中没有 synchronized 关键之，取而代之的是 @Synchronized 注解
#+BEGIN_SRC kotlin
class Util {
    @Synchronized
    fun main() {
    }
}
#+END_SRC
- 我们把 kotlin 代码反编译一下看看，
#+BEGIN_SRC java
public final class Util {
    public final synchronized void main() {
    }
}
#+END_SRC
- 可以看到 @Synchronized 注解 可以达到 Java synchronized 关键字的作用。
- 除此之外，kotlin 在方法内，可以使用 block 块
*** 例子1
    #+BEGIN_SRC kotlin
class Util {
    val lock = Any()
    fun main() {
        synchronized(this) {
        }
    }
}
    #+END_SRC
- 编译成 java 如下
  #+BEGIN_SRC java
public static final class Util {
    @NotNull
        private final Object lock = new Object();
    @NotNull
        public final Object getLock() {
        return this.lock;
    }
    public final void main() {
        synchronized(this) {
            boolean var2 = false;
            Unit var4 = Unit.INSTANCE;
        }
    }
}
  #+END_SRC
*** 例子2
    #+BEGIN_SRC kotlin
class Util {
    val lock = Any()
    fun main() {
        synchronized(lock) {
        }
    }
}
    #+END_SRC
- 编译成 java 如下
  #+BEGIN_SRC java
public static final class Util {
    @NotNull
        private final Object lock = new Object();
    @NotNull
        public final Object getLock() {
        return this.lock;
    }
    public final void main() {
        Object var1 = this.lock;
        synchronized(var1) {
            boolean var2 = false;
            Unit var4 = Unit.INSTANCE;
        }
    }
}
  #+END_SRC
** Volatile 关键字
- 在kotlin中没有volatile关键字，但是有 @Volatile 注解
#+BEGIN_SRC kotlin
class Util {
    @Volatile
    var lock = Any()
}
#+END_SRC
- 编译成 java 如下
  #+BEGIN_SRC java
public static final class Util {
    @NotNull
        private volatile Object lock = new Object();
    @NotNull
        public final Object getLock() {
        return this.lock;
    }
    public final void setLock(@NotNull Object var1) {
        Intrinsics.checkNotNullParameter(var1, "<set-?>");
        this.lock = var1;
    }
}
  #+END_SRC

** 默认赋值
*** 默认不为空
    #+BEGIN_SRC kotlin
class A(val name: String, val age: Int)
    #+END_SRC
- 代表 name、age 不能为 null ， 转换成 java , 会看到在构造函数中会对 name 字段做 空校验。
  #+BEGIN_SRC java
public static final class A {
    @NotNull
        private final String name;
    private final int age;
    @NotNull
        public final String getName() {
        return this.name;
    }
    public final int getAge() {
        return this.age;
    }
    public A(@NotNull String name, int age) {
        Intrinsics.checkNotNullParameter(name, "name");
        super();
        this.name = name;
        this.age = age;
    }
}
  #+END_SRC 
- 函数 checkNotNullParameter()源码如下：

[[./pic/eg5.png]]

*** 可以为空
    #+BEGIN_SRC kotlin
class A(val name: String?, val age: Int)
    #+END_SRC
- 代表 name 可为 null ， 转换成 java , 会看到在构造函数中没有对 name 字段做 空校验。
  #+BEGIN_SRC java
public static final class A {
    @Nullable
        private final String name;
    private final int age;
    @Nullable
        public final String getName() {
        return this.name;
    }
    public final int getAge() {
        return this.age;
    }
    public A(@Nullable String name, int age) {
        this.name = name;
        this.age = age;
    }
}
  #+END_SRC 

*** 默认值
    #+BEGIN_SRC kotlin
class A(val name: String? = "zhaoyanjun", val age: Int)
    #+END_SRC
- name 可为空，如果name 为null， 使用默认值 “zhaoyanjun”
  #+BEGIN_SRC java
public static final class A {
    @Nullable
        private final String name;
    private final int age;
    @Nullable
        public final String getName() {
        return this.name;
    }
    public final int getAge() {
        return this.age;
    }
    public A(@Nullable String name, int age) {
        this.name = name;
        this.age = age;
    }
    // $FF: synthetic method
    public A(String var1, int var2, int var3, DefaultConstructorMarker var4) {
        if ((var3 & 1) != 0) {
            var1 = "zhaoyanjun";
        }
        this(var1, var2);
    }
}
  #+END_SRC 

*** 两个默认值
    #+BEGIN_SRC kotlin
class A(val name: String? = "zhaoyanjun", val age: Int ?= 10)
    #+END_SRC
- 出来的java码：
    #+BEGIN_SRC java
public static final class A {
    @Nullable
        private final String name;
    @Nullable
        private final Integer age;
    @Nullable
        public final String getName() {
        return this.name;
    }
    @Nullable
        public final Integer getAge() {
        return this.age;
    }
    public A(@Nullable String name, @Nullable Integer age) {
        this.name = name;
        this.age = age;
    }
    // $FF: synthetic method
    public A(String var1, Integer var2, int var3, DefaultConstructorMarker var4) {
        if ((var3 & 1) != 0) 
            var1 = "zhaoyanjun";
        if ((var3 & 2) != 0) 
            var2 = 10;
        this(var1, var2);
    }
}   
 #+END_SRC    
    
** 构造函数
   #+BEGIN_SRC kotlin
class A(val name: String, val age: Int)
var a1 =  A("zhaoyanjun",10)  //编译正常
var a =  A()  //编译失败，因为没有无参构造函数
   #+END_SRC
    #+BEGIN_SRC java
public static final class A {
    @NotNull
        private final String name;
    private final int age;
    @NotNull
        public final String getName() {
        return this.name;
    }
    public final int getAge() {
        return this.age;
    }
    public A(@NotNull String name, int age) {
        Intrinsics.checkNotNullParameter(name, "name");
        super();
        this.name = name;
        this.age = age;
    }
}
    #+END_SRC    
- 如何才能调用无参构造函数呢？其实很简单，给每个参数添加一个默认值就可以了
#+BEGIN_SRC kotlin
class A(val name: String? = "", val age: Int? = 0)
#+END_SRC
- 只要参数都有默认值，就会默认生成 无参构造函数
    #+BEGIN_SRC java
public static final class A {
    @Nullable
        private final String name;
    @Nullable
        private final Integer age;
    @Nullable
        public final String getName() {
        return this.name;
    }
    @Nullable
        public final Integer getAge() {
        return this.age;
    }
    public A(@Nullable String name, @Nullable Integer age) {
        this.name = name;
        this.age = age;
    }
    // $FF: synthetic method
    public A(String var1, Integer var2, int var3, DefaultConstructorMarker var4) {
        if ((var3 & 1) != 0) 
            var1 = "";
        if ((var3 & 2) != 0) 
            var2 = 0;
        this(var1, var2);
    }
}
    #+END_SRC    

** 重载函数 @JvmOverloads
   #+BEGIN_SRC kotlin
class A(val name: String, val age: Int)
var a1 =  A("zhaoyanjun",10)   //编译正常
var a2 =  A("123")    //编译失败，没有只有一个参数的构造函数
   #+END_SRC
- 如何才能自动生成重载函数呢？其实很简单
- 给每个参数添加默认值
- 标记 constructor 关键字
- 标记 @JvmOverloads 关键字
#+BEGIN_SRC kotlin
class A @JvmOverloads constructor(val name: String? = "", val age: Int? = 0)
#+END_SRC
- 生成的java码如下：
    #+BEGIN_SRC java
public static final class A {
    @Nullable
        private final String name;
    @Nullable
        private final Integer age;
    @Nullable
        public final String getName() {
        return this.name;
    }
    @Nullable
        public final Integer getAge() {
        return this.age;
    }
    @JvmOverloads
        public A(@Nullable String name, @Nullable Integer age) {
        this.name = name;
        this.age = age;
    }
    // $FF: synthetic method
    public A(String var1, Integer var2, int var3, DefaultConstructorMarker var4) {
        if ((var3 & 1) != 0) 
            var1 = "";
        if ((var3 & 2) != 0) 
            var2 = 0;
        this(var1, var2);
    }
    @JvmOverloads
        public A(@Nullable String name) {
        this(name, (Integer)null, 2, (DefaultConstructorMarker)null);
    }
    @JvmOverloads
        public A() {
        this((String)null, (Integer)null, 3, (DefaultConstructorMarker)null);
    }
}
    #+END_SRC    


* Kotlin compiler errors and corrections
** Function declaration must have a name
- 下文java代码因为在Android Studio里反编译，出来的都是scratch里的static类，但它们原本应该不是static的才对。特此标注。
- 下现这段代码完全没有问题,安卓中我们常这样
#+BEGIN_SRC java
public class CustomView extends View {
    public CustomView(Context context) {
        super(context);
        init();
    }
    public CustomView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init();
    }
    public CustomView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }
    public void init() {
        //do something
    }
}
#+END_SRC
- 然后照葫芦画飘
#+BEGIN_SRC kotlin
class CustomView : View {
    init {
        //do something
    }
    constructor(ctx: Context) : super(ctx)
    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
    constructor(ctx: Context, attrs: AttributeSet, defStyleAttr: Int) : super(ctx, attrs, defStyleAttr)
}
#+END_SRC
- 但是接下来这段，问题就来了：
   #+BEGIN_SRC kotlin
class Person {
    init () { // Function declaration must have a name
        print("Person initialized ${firstName}")
    }
    constructor(firstName: String) {
        print("constructor1: ${firstName}")    
    }
    constructor(firstName: String,secondName: String) {
        print("constructor2 ${firstName} ${secondName}")
    }
}
   #+END_SRC
- 怎么改正呢？
** This type (BaseActivity) has a constructor, and thus must be initialized here
- kotlin的继承是通过冒号:操作符来完成的，相当于java中的extends，所有被继承的类定义时需要加open操作符
   #+BEGIN_SRC kotlin
open class BaseActivity {
}
class LoginActivity : BaseActivity { // This type (BaseActivity) has a constructor, and thus must be initialized here
}
   #+END_SRC
- 改下的方法是： 
  - error agains: BaseActivity: Supertype initialization is impossible without primary constructor
#+BEGIN_SRC kotlin
open class BaseActivity {
}
class LoginActivity : BaseActivity() { // BaseActivity: Supertype initialization is impossible without primary constructor
    constructor() : super()
}
#+END_SRC
- 改下的方法是： 
#+BEGIN_SRC kotlin
open class BaseActivity {
}
class LoginActivity : BaseActivity { // BaseActivity
    constructor() : super()
}
#+END_SRC
- or 
#+BEGIN_SRC kotlin
open class BaseActivity {
}
class LoginActivity() : BaseActivity() {
    constructor() : this () { // this: Overload resolution ambiguity. All these functions match.
                              // public constructor LoginActivity() defined in Scratch.LoginActivity
                              // public constructor LoginActivity() defined in Scratch.LoginActivity
    }
}
#+END_SRC
- 不过上面的this仍然报错了
- 编译成的java文件版本为：
#+BEGIN_SRC java
public static class BaseActivity {
}
public static final class LoginActivity extends Scratch.BaseActivity {
}
#+END_SRC
** @override
- 在kotlin中只允许覆写父类中加了open描述符的方法，这一点与类继承比较相似(类定义时只有加了open操作符才允许被继承);
- java中覆写方法时一般会加@override注解不加也可以通过编译，
- 但是在kotlin中并且子类必须在覆写的方法上加上override，类似于java的@override
#+BEGIN_SRC kotlin
open class Base {
    open fun v() {}
    fun nv() {}
}
class Derived() : Base() {
    // 覆盖
    fun v() {} // v: 'v' hides member of supertype 'Base' and needs 'override' modifier
}
#+END_SRC
- 加上override就可以正常编译了
 #+BEGIN_SRC kotlin
open class Base {
    open fun v() {}
    fun nv() {}
}
class Derived() : Base() {
    override fun v() {} // 覆盖
}
#+END_SRC
- kotlinc =>
#+BEGIN_SRC java
public class Base {
    public void v() {
    }
    public final void nv() {
    }
}
public final class Derived extends Base {
    public void v() {
    }
}
#+END_SRC

** 类中var与val, set get幕后字段与field
- Kotlin的类中声明可变的属性使用var关键字， 如果声明java中final的属性使用val关键字，kotlin编译的时候会为带var关键字的属性自动生成get和set方法，带val关键字的属性只会生成get方法
#+BEGIN_SRC kotlin
class Address {
    val name: String = "typ0520"
    var phone: String? = null
    var city: String = "sh"

    fun copyAddress(address: Address): Address {
        val result = Address()       // Kotlin 中没有“new”关键字
        result.phone = address.phone // 将调用访问器
        result.city = address.city

        print("origin: ${this.name} current: ${address.name}")
        return result
    }
}
#+END_SRC
- kotlinc =>
#+BEGIN_SRC java
public final class Address {
    @NotNull
        private final String name = "typ0520";
    @Nullable
        private String phone;
    @NotNull
        private String city = "sh";

    @NotNull
        public final String getName() {
        return this.name;
    }

    @Nullable
        public final String getPhone() {
        return this.phone;
    }
    public final void setPhone(@Nullable String var1) {
        this.phone = var1;
    }

    @NotNull
        public final String getCity() {
        return this.city;
    }
    public final void setCity(@NotNull String var1) {
        Intrinsics.checkNotNullParameter(var1, "<set-?>");
        this.city = var1;
    }

    @NotNull
        public final Scratch.Address copyAddress(@NotNull Scratch.Address address) {
        Intrinsics.checkNotNullParameter(address, "address");
        Scratch.Address result = new Scratch.Address();
        result.phone = address.phone;
        result.city = address.city; // <<<======
        String var3 = "origin: " + this.name + " current: " + address.name;
        System.out.print(var3);
        return result;
    }
}
#+END_SRC
- 这里有两个细节
  - setCity方法里第一行里会检查city是否为null Intrinsics.checkParameterIsNotNull(<set-?>, "<set-?>");是因为kotlin的属性默认是不允许为null的，如果某个属性允许为null，定义属性的时候需要在类型后面加上问号? swift也有可选这个特性不知道它俩谁抄谁的
#+BEGIN_SRC kotlin
    var phone: String? = null
#+END_SRC    
  - copyAddress方法里对常量name的引用依然是this.name、address.name，如果在java中对常量的引用编译以后就会被优化成值copy，也就是说
  #+BEGIN_SRC java
String str = address.name + " " + this.name
  #+END_SRC
这段会被编译成
#+BEGIN_SRC java
String str = "typ0520" + " " + "typ0520";
#+END_SRC
- 如果对默认的get方法和set方法实现不满意，kotlin也提供了机制可以干预
#+BEGIN_SRC kotlin
class Address {
    var city: String = ""
        get() {
            return "city: ${field}"
        }
        set (_city) {
            field = _city // 先别管field是啥玩意，后面会介绍
            print("city: ${field}")
        }
    fun copyAddress(address: Address): Address {
        val result = Address()      // Kotlin 中没有“new”关键字
        result.city = address.city
        //print("origin: ${this.name} current: ${address.name}") // 会报错：两个name
        return result
    }
}
#+END_SRC
- kotlinc =>
#+BEGIN_SRC java
public static final class Address {
    @NotNull
        private String city = "";
    @NotNull
        public final String getCity() {
        return "city: " + this.city;
    }
    public final void setCity(@NotNull String _city) {
        Intrinsics.checkNotNullParameter(_city, "_city");
        this.city = _city;
        String var2 = "city: " + this.city;
        System.out.print(var2);
    }
    @NotNull
        public final Scratch.Address copyAddress(@NotNull Scratch.Address address) {
        Intrinsics.checkNotNullParameter(address, "address");
        Scratch.Address result = new Scratch.Address();
        result.setCity(address.getCity());  // <<<======
        return result;
    }
}
#+END_SRC
- 对比这两次编译出来的copyAddress方法中的内容，第一次对city的赋值使用的是
#+BEGIN_SRC java
    result.city = address.city;
#+END_SRC
-    第二次对city的赋值使用的是
#+BEGIN_SRC java
    result.setCity(address.getCity());
#+END_SRC
- 这点kotlin还是很严谨的，如果发现自定义了get和set的逻辑就会把直接引用属性的地方替换成调用get set方法,
- 但是如果set{}和get{}代码块中引用了对应的属性这个替换就会出问题，我们来看下如果在set{}和get{}直接使用city字段会被编译成什么
#+BEGIN_SRC kotlin
class Address {
    var city: String
        get() {
            return "city: ${city}"
        }
        set (_city) {
            city = _city
            print("city: ${city}")
        }
    fun copyAddress(address: Address): Address {
        val result = Address()      // Kotlin 中没有“new”关键字
        result.city = address.city
        //print("origin: ${this.name} current: ${address.name}") // 会报错：两个name
        return result
    }
}
#+END_SRC
- kotlinc =>
#+BEGIN_SRC java
public static final class Address {
    @NotNull
        public final String getCity() {
        return "city: " + this.getCity(); // <<==
    }
    public final void setCity(@NotNull String _city) {
        Intrinsics.checkNotNullParameter(_city, "_city");
        this.setCity(_city); // <<==
        String var2 = "city: " + this.getCity();
        System.out.print(var2);
    }
    @NotNull
        public final Scratch.Address copyAddress(@NotNull Scratch.Address address) {
        Intrinsics.checkNotNullParameter(address, "address");
        Scratch.Address result = new Scratch.Address();
        result.setCity(address.getCity());
        return result;
    }
}
#+END_SRC
- 很明显setCity和getCity中都出现了死循环，kotlin为了解决这个问题提供了一个叫做field的幕后字段,仅在set{} get{}代码块中代替当前的属性
** 幕后字段和field
*** 什么是幕后字段？
- 要理解这个概念，我们得再深一步探究：getter 和 setter 一定要与某个属性相关联吗？ 答案当然是否定的。getter 是从对象中获取特定的值，这个值完全可能是每次访问时临时计算的，也可能是从其他对象那里得到的；setter 也可能是在设置其他对象的属性。事实上，Kotlin 只会为满足特定条件的类属性添加 JVM 意义上的类属性。
- 我们为 Person 添加一个 nameHash 属性：
#+BEGIN_SRC kotlin
class Person(val name: String) {
  val nameHash get() = name.hashCode()
}
#+END_SRC
- 这个 nameHash 属性并没有初始化，只定义了一个 getter 方法。这个属性在编译之后就会消失，只留下一个 getNameHash() 方法：
#+BEGIN_SRC kotlin
public final int getNameHash() {
    return name.hashCode();
}
#+END_SRC
- 我们可以这样说：「nameHash 是一个没有幕后字段的属性」，它作为类属性只存在于 Kotlin 代码中，并没有一个真正的 JVM 类属性与之对应。怎么给 nameHash 添加一个幕后字段呢？Kotlin 并不允许我们手动添加，但会自动为满足条件的类属性添加幕后字段：
- 使用默认 getter / setter 的属性，一定有幕后字段。对于 var 属性来说，只要 getter / setter 中有一个使用默认实现，就会生成幕后字段；
- 在自定义 getter / setter 中使用了 field 的属性，一定有幕后字段。这个 field 就是我们访问幕后字段的「关键字」，它与 Lambda 表达式中的 it 类似，并不是一个真正的关键字，只在特定的语句内有特殊的意思，在其他语句内都不是关键字。
- 比如，我们可以写：
#+BEGIN_SRC kotlin
class Person(val name: String, val gender: Gender, age: Int) {
    val age = age
        get() = when (gender) {
            Gender.FEMALE -> (field * 0.8).toInt()
            Gender.MALE -> field
        }
}
enum class Gender {
    MALE, FEMALE
}
#+END_SRC
- 我们这里通过幕后字段实现了 age 属性根据性别的不同行为。(´･ω･`)
- 虽然我们为 age 属性自定义了 getter，但因为在 getter 中用了 field 关键字，Kotlin 就会为我们生成一个 private final int age 属性作为幕后字段。这个幕后字段同时需要初始化，我们就用主构造函数中传入的 age 来初始化它。
*** 幕后属性大用处
- 很多时候，我们希望定义这样的属性：
- 对外表现为 val 属性，只能读不能写；
- 在类内部表现为 var 属性，也就是说只能在类内部改变它的值。
- 这在 Kotlin 集合框架中应用十分广泛。比如 Collection 接口定义的 size 属性就是一个 val 属性，对外只读；但对于一个 MutableCollection 来说，size 的值在内部一定是能改变的，也只允许内部修改它。我们可以这样设计：
#+BEGIN_SRC kotlin
override val size get() = _size
private var _size: Int = 0
#+END_SRC
- 我们在内部增删元素时，改动的就是 _size 属性的值；外部只能访问到 size 属性，不能修改 _size 的值。这里的 _size 就叫做「幕后属性」。
- kotlin.collections.AbstractMap.kt 中也用到了幕后属性，我们看一下:
#+BEGIN_SRC kotlin
private @Volatile var _keys: Set<K>? = null
override val keys: Set<K> get() {
    if (_keys == null) {
        _keys = object : AbstractSet<K>() {
            override operator fun contains(element: K): Boolean = containsKey(element)
            override operator fun iterator(): Iterator<K> {
                val entryIterator = entries.iterator()
                return object : Iterator<K> {
                    override fun hasNext(): Boolean = entryIterator.hasNext()
                    override fun next(): K = entryIterator.next().key
                }
            }
            override val size: Int get() = this@AbstractMap.size
        }
    }
    return _keys!!
}
#+END_SRC
- keys 是对外的 API，只读且非空，每次访问都被委托到访问 _keys 属性上，_keys 属性在内部可以改动也可以为 null，给我们带来方便。
- 在设计类属性时，可以通过幕后属性灵活地实现功能。
** 接口
- kotlin中接口的方法是允许有默认实现的，但是java从1.8才开始支持接口默认实现，那么kotlin编译出来的class只能在1.8上运行？显然不太可能，我们来看下kotlin是怎么处理这个事情的
#+BEGIN_SRC kotlin
interface MyInterface {
    fun bar()
    fun foo() {
        // 可选的方法体
        print("MyInterface foo")
        this.bar()
    }
}
class Child : MyInterface {
    override fun bar() {
        // 方法体
    }
}
#+END_SRC
-  执行kotlinc以后会生成三个class文件
#+BEGIN_SRC java
 Child.class  'MyInterface$DefaultImpls.class'   MyInterface.class
#+END_SRC
- 编成java
#+BEGIN_SRC java
public interface MyInterface {
    void bar();
    void foo();
    public static final class DefaultImpls { // static
        public static void foo(@NotNull Scratch.MyInterface $this) {
            String var1 = "MyInterface foo";
            System.out.print(var1);
            $this.bar();
        }
    }
}
public static final class Child implements Scratch.MyInterface {
    public void bar() {
    }
    public void foo() {
        Scratch.MyInterface.DefaultImpls.foo(this);
    }
}
#+END_SRC
- kotlinc编译的时候如果发现接口中的某个方法有默认实现，就会生成一个以接口名+$+DefaultImpls方式命名的类，然后会创建一个同名的静态方法以容纳接口中对应方法的code，并且这个静态方法的参数列表中会多加一个名字叫$this类型是相应接口的变量，这样子类中这个方法的实现就可以直接调用这个静态方法了
- 如果一个类实现了多个接口，就有可能出现接口中方法冲突的问题，可以通过super<XXX>语法来选择对应父类的方法
#+BEGIN_SRC kotlin
interface A {
    fun foo() { print("A") }
    fun bar()
}
interface B {
    fun foo() { print("B") }
    fun bar() { print("bar") }
}
class D : A, B {
    override fun foo() {
        super<A>.foo()
        super<B>.foo()
    }
    override fun bar() {
        super<B>.bar()
    }
}
#+END_SRC
- kotlinc =>
#+BEGIN_SRC java
public interface A {
    void foo();
    void bar();
    public static final class DefaultImpls {
        public static void foo(@NotNull Scratch.A $this) {
            String var1 = "A";
            System.out.print(var1);
        }
    }
}
public interface B {
    void foo();
    void bar();
    public static final class DefaultImpls {
        public static void foo(@NotNull Scratch.B $this) {
            String var1 = "B";
            System.out.print(var1);
        }
        public static void bar(@NotNull Scratch.B $this) {
            String var1 = "bar";
            System.out.print(var1);
        }
    }
}
public static final class D implements Scratch.A, Scratch.B {
    public void foo() {
        Scratch.A.DefaultImpls.foo(this);
        Scratch.B.DefaultImpls.foo(this);
    }
    public void bar() {
        Scratch.B.DefaultImpls.bar(this);
    }
}
#+END_SRC    
** 扩展
- kotlin提供了一种类似于objective-c category的扩展功能,是继承的一个有力补充，作用主要有下面这两点
*** 1、代替一些在java中需要util类辅助来完成的操作举个例子我们需要对ArrayList中的元素按位置做交换，在java中通常我们会写一个静态方法放在某个util类中
    #+BEGIN_SRC java
//Utils.java
public class Utils {
    public static void swap(List<Integer> list,int index1,int index2) {
        int idx1Val = list.get(idx1);
        int idx2Val = list.get(idx2);
        list.remove(idx1);
        list.add(idx1, idx2Val);
        list.remove(idx2);
        list.add(idx2, idx1Val);
    }
}
    #+END_SRC
- 在kotlin中可以这样写
#+BEGIN_SRC kotlin
// extension.kt
fun MutableList<Int>.swap(idx1: Int, idx2: Int) {
    val tmp = this[idx1]
    this[idx1] = this[idx2]
    this[idx2] = tmp
}
fun hello() {
    val list = mutableListOf(1, 2, 3)
    list.swap(0, 2) // “swap()”内部的“this”得到“l”的值
}
#+END_SRC
- 可以当做MutableList直接有这个swap这个方法，这样比Util类用起来更加符合面向对象的思维
- 我们来编译下这段kotlin代码
#+BEGIN_SRC kotlin
public final void swap(@NotNull List $this$swap, int idx1, int idx2) {
    Intrinsics.checkNotNullParameter($this$swap, "$this$swap");
    int tmp = ((Number)$this$swap.get(idx1)).intValue();
    $this$swap.set(idx1, $this$swap.get(idx2));
    $this$swap.set(idx2, tmp);
}
public final void hello() {
    List list = CollectionsKt.mutableListOf(new Integer[]{1, 2, 3});
    ((Scratch)this).swap(list, 0, 2);
}
#+END_SRC
- 可以看出编译成class后还是使用静态方法实现的，并不是真正的改变了List的类结构(如果改变了类结构应该是list.swap(0, 2))
*** 2、给一些方法设置别名
- 玩过java的肯定都知道Object中的toString方法，如果你以前是玩objective-c的应该还是习惯叫description，那么你就可以通过扩展来给toString设置别名
#+BEGIN_SRC kotlin
fun Any.description() : String {
    return this.toString()
}
fun hello() {
    val str = "xxxx"
    str.description()
}
#+END_SRC
- 处于安全性的考虑扩展的方法是不允许和类中已有的方法冲突的，同时也不允许多个跟对同一个类的扩展中包含相同的方法，来看下两个例子
#+BEGIN_SRC java
class C {
    fun foo() { println("member") }
}
fun C.foo() { // foo: Extension is shadowed by a member: public final fun foo(): Unit
    println("extension") 
}
#+END_SRC
- kotlin =>
#+BEGIN_SRC java
tmp.kt:4:7: warning: extension is shadowed by a member: public final fun foo(): Unit
fun C.foo() { println("extension") }
#+END_SRC
#+BEGIN_SRC kotlin
class C {
    fun foo() { println("member") }
}
fun C.foo2() { println("foo2") }
fun C.foo2() { println("foo2-2") }
#+END_SRC
- kotlin =>
  #+BEGIN_SRC java
kotlinc -version
info: kotlinc-jvm 1.6.0 (JRE 16.0.2+7-67)
tmp.kt:4:1: error: conflicting overloads: public fun C.foo2(): Unit defined in root package in file tmp.kt, public fun C.foo2(): Unit defined in root package in file tmp.kt
fun C.foo2() { println("foo2") }
^
tmp.kt:5:1: error: conflicting overloads: public fun C.foo2(): Unit defined in root package in file tmp.kt, public fun C.foo2(): Unit defined in root package in file tmp.kt
fun C.foo2() { println("foo2-2") }
^
  #+END_SRC
- 上面应该是旧版上才会出现这种问题，比如我的ubuntu 18 kotlin -version 1.6.0
#+BEGIN_SRC java
#+END_SRC
- 用新版的Android studio 1.6.10就不会再报错
- kotlin允许在一个类内部为另一个类声明扩展
#+BEGIN_SRC kotlin
class D {
    fun bar() {
        println("D.bar")
    }
    fun hello() {
        println("D hello")
    }
}
class C {
    fun baz() {
        println("C.baz")    
    }
    fun hello() {
        println("C hello")
    }
    fun D.foo() {
        bar()   // 调用 D.bar
        baz()   // 调用 C.baz
        // 重点看这个这里
        hello()
    }
    fun caller(d: D) {
        d.foo()   // 调用扩展函数
    }
}
fun main() {
    val d = D()
    val c = C()
    c.caller(d)
}
#+END_SRC
- 在D.foo扩展方法的作用域里存在两个this，一个是扩展声明所在的类C、一个是被扩展类D的。调用bar方法和baz方法没什么问题，但是hello方法既存在于C又存在于D，那么kotlin会选择调用那个hello方法呢(这段代码是可以通过编译的)？我们来编译运行下看下输出
#+BEGIN_SRC java
kotlinc extension5.kt -include-runtime -d extension5.jar;java -jar extension5.jar=>
D.bar
C.baz
D hello // <<<====
#+END_SRC
- 从输出的日志上可以看出调用的是被扩展类D的hello方法，我们再看下extension5.jar里的class内容
#+BEGIN_SRC java
public static final class C {
    public final void baz() {
        String var1 = "C.baz";
        System.out.println(var1);
    }
    public final void hello() {
        String var1 = "C hello";
        System.out.println(var1);
    }
    public final void foo(@NotNull Scratch.D $this$foo) {
        Intrinsics.checkNotNullParameter($this$foo, "$this$foo");
        $this$foo.bar();
        this.baz();
        $this$foo.hello();
    }
    public final void caller(@NotNull Scratch.D d) {
        Intrinsics.checkNotNullParameter(d, "d");
        this.foo(d);
    }
}
#+END_SRC
- 如果想调用C类的hello方法，可以使用this@C.hello()
#+BEGIN_SRC kotlin
class D {
    fun hello() {
        println("D hello")
    }
}
class C {
    fun hello() { println("C hello") }
    fun D.foo() {
        this@C.hello() 
    }
    fun caller(d: D) { d.foo() }
}
fun main(args: Array<String>) {
    val d = D()
    val c = C()
    c.caller(d)
}
#+END_SRC
- =>
#+BEGIN_SRC java
public static final class C {
    public final void hello() {
        String var1 = "C hello";
        System.out.println(var1);
    }
    public final void foo(@NotNull Scratch.D $this$foo) {
        Intrinsics.checkNotNullParameter($this$foo, "$this$foo");
        this.hello();
    }
    public final void caller(@NotNull Scratch.D d) {
        Intrinsics.checkNotNullParameter(d, "d");
        this.foo(d);
    }
}
#+END_SRC
- 除了可以扩展方法，kotlin还允许扩展属性
#+BEGIN_SRC kotlin
val <T> List<T>.lastIndex: Int
    get() = size - 1
fun main(args: Array<String>) {
    val list = listOf(1,2,3,4)
    println(list.lastIndex)
}
#+END_SRC
- =>
#+BEGIN_SRC java
kotlinc extension7.kt -include-runtime -d extension7.jar;java -jar extension7.jar
3
public final int getLastIndex(@NotNull List $this$lastIndex) {
    Intrinsics.checkNotNullParameter($this$lastIndex, "$this$lastIndex");
    return $this$lastIndex.size() - 1;
}
public final void main(@NotNull String[] args) {
    Intrinsics.checkNotNullParameter(args, "args");
    List list = CollectionsKt.listOf(new Integer[]{1, 2, 3, 4});
    int var3 = ((Scratch)this).getLastIndex(list);
    System.out.println(var3);
}
#+END_SRC
- 可以看出所谓的属性扩展和方法扩展一样都是用静态方法实现的
** 数据类
- 在java开发中充斥着大量的model类，除了属性定义其它的基本上都是一些模板代码，虽然ide能帮我们生成这些代码，看着还是很不爽的，kotlin提供了一中叫数据类的玩意，编译器自动从主构造函数中声明的所有属性导出以下成员：
  - equals()/hashCode()
  - toString() 格式是 "User(name=John, age=42)"
  - componentN() 函数 按声明顺序对应于所有属性
  - copy() 函数
#+BEGIN_SRC kotlin
data class User(val name: String, val age: Int)
#+END_SRC
- kotlinc =>
#+BEGIN_SRC java
public static final class User {
    @NotNull
        private final String name;
    private final int age;
    @NotNull
        public final String getName() {
        return this.name;
    }
    public final int getAge() {
        return this.age;
    }
    public User(@NotNull String name, int age) {
        Intrinsics.checkNotNullParameter(name, "name");
        super();
        this.name = name;
        this.age = age;
    }
    @NotNull
        public final String component1() {
        return this.name;
    }
    public final int component2() {
        return this.age;
    }
    @NotNull
        public final Scratch.User copy(@NotNull String name, int age) {
        Intrinsics.checkNotNullParameter(name, "name");
        return new Scratch.User(name, age);
    }
    // $FF: synthetic method
    public static Scratch.User copy$default(Scratch.User var0, String var1, int var2, int var3, Object var4) {
        if ((var3 & 1) != 0) 
            var1 = var0.name;
        if ((var3 & 2) != 0) 
            var2 = var0.age;
        return var0.copy(var1, var2);
    }
    @NotNull
        public String toString() {
        return "User(name=" + this.name + ", age=" + this.age + ")";
    }
    public int hashCode() {
        String var10000 = this.name;
        return (var10000 != null ? var10000.hashCode() : 0) * 31 + Integer.hashCode(this.age);
    }
    public boolean equals(@Nullable Object var1) {
        if (this != var1) {
            if (var1 instanceof Scratch.User) {
                Scratch.User var2 = (Scratch.User)var1;
                if (Intrinsics.areEqual(this.name, var2.name) && this.age == var2.age) {
                    return true;
                }
            }
            return false;
        } else 
            return true;
    }
}
#+END_SRC
** 嵌套类
- 与java类似kotlin的类定义也是允许嵌套的，我们分别看下java中的静态内部类、内部类、匿名内部类对应kotlin的语法
*** 静态内部类
    #+BEGIN_SRC kotlin
class Outer {
    private val bar: Int = 1
    class Nested {
        fun foo() = 2
    }
}
val demo = Outer.Nested().foo() // == 2
    #+END_SRC
- java
#+BEGIN_SRC java
private final int demo = (new Scratch.Outer.Nested()).foo();
public final int getDemo() {
    return this.demo;
}
public final class Outer {
    private final int bar = 1;
    public static final class Nested {
        public final int foo() {
            return 2;
        }
    }
}
#+END_SRC
*** 内部类
    #+BEGIN_SRC kotlin
class Outer {
    private val bar: Int = 1
    fun hello() {
        print("hello")
    }
    inner class Inner {
        // fun foo() -> Int { // 这里lambda表达式不知道哪里出错了，报错
        fun foo(): Int {
            return bar
        }
        fun callHello() {
            hello()
        }
    }
}
val demo = Outer().Inner().foo() // == 1
    #+END_SRC
- kotlinc =>
#+BEGIN_SRC java
private final int demo = (new Scratch.Outer().new Inner()).foo();
public final int getDemo() {
    return this.demo;
}
public static final class Outer {
    private final int bar = 1;
    public final void hello() {
        String var1 = "hello";
        System.out.print(var1);
    }
    public final class Inner {
        public final int foo() {
            return Outer.this.bar;
        }
        public final void callHello() {
            Outer.this.hello();
        }
    }
}
#+END_SRC
*** 匿名内部类
    #+BEGIN_SRC kotlin
class View {
    fun setOnClickListener(listener: OnClickListener) {
        print("${listener}")
    }
    class OnClickListener {
        fun onClick(view: View) {
        }
    }
}
fun hello() {
    val v = View()
    v.setOnClickListener(object: View.OnClickListener() {
                             override fun onClick(view: View) {
                             }
    })
}
    #+END_SRC
- kotlinc => 这个应该是需要放到一个安卓项目环境里去反编，暂时抄一下版主的代码，改天再验证一下
#+BEGIN_SRC java
//View.class
public class View {
    public final void setOnClickListener(@NotNull View.OnClickListener listener) {
        Intrinsics.checkParameterIsNotNull(listener, "listener");
        String str = String.valueOf(listener);
        System.out.print(str);
    }
    public static class OnClickListener {
        public void onClick(@NotNull View view) {
            Intrinsics.checkParameterIsNotNull(view, "view");
        }
    }
}
public final class Nested_classes3Kt {
    public static final void hello() {
        View v = new View();
        v.setOnClickListener((View.OnClickListener)new View.OnClickListener() {
                public void onClick(@NotNull View view) {
                    Intrinsics.checkParameterIsNotNull(view, "view");
                }
            });
    }
}
public final class Nested_classes3Kt$hello$1 extends View.OnClickListener {
    public void onClick(@NotNull View view) {
        Intrinsics.checkParameterIsNotNull(view, "view");
    }
}
#+END_SRC
- 匿名类编译的时候会生成一个子类容纳被覆盖的方法以及增加的属性，因此类定义的时候必须要加上open。



* Delegate
- 委托属性算是 Kotlin 语言中的高级特性，初次接触可能毫无头绪，再次接触还是一脸懵逼。只有在深入理解其语言特性和实现原理之后，才能对这一甜之又甜的“语法糖”有所认识，从而极大提高代码效率。
- Kotlin 支持委托模式， 是允许对象组合实现与继承相同的代码复用，简单来说就是操作的对象不用自己去执行，而是将任务交给另一个对象去操作，这种模式叫委托模式，被操作的对象叫委托。
- 委托模式有两个对象参与处理同一请求，接受请求的对象将请求委托给另一个对象来处理。
** 基本使用
- 定义一个委托属性的基本语法为 val/var <属性名>: <类型> by <表达式>，在 by 后面的表达式即为委托， 属性对应的 get()与set()会被委托给它的 getValue() 与 setValue() 方法。
#+BEGIN_SRC kotlin
class Example {
    var p: String by Delegate()
    companion object {
        @JvmStatic
        fun main(args: Array<String>) {
            var e = Example()
            println(e.p)
            e.p = "newValue"
        }
    }
}
class Delegate {
    operator fun getValue(thisRef: Any?, property: Any): String {
        return "$thisRef, thank you for delegating '$property' to me!"
    }
    operator fun setValue(thisRef: Any?, property: Any, value: String) {
        println("$value has been assigned to '$property' in $thisRef.")
    }
}
#+END_SRC
- 上述代码中，Delegate 内方法的参数 property 原本为 KProperty<*> 接口类型，为了手动调用其方法，改成 Any 以实现传参。
- 控制台输出结果为
#+BEGIN_SRC kotlin
╰─ kotlin Example
Example@4b85612c, thank you for delegating 'var Example.p: kotlin.String' to me!
newValue has been assigned to 'var Example.p: kotlin.String' in Example@4b85612c.
#+END_SRC
- 可以看到属性 p 委托给了 Delegate() 对象实例，按照约定，该对象必须声明具有getValue、setValue方法，且方法参数个数必须大于2、3。
- 为了更清楚的了解这一过程，可以将代码改写成另一种形式
#+BEGIN_SRC kotlin
class Example {
    var delegate: Delegate = Delegate()
    var p: String
        set(value) {
            delegate.setValue(thisRef = this, property = delegate, value = value)
        }
        get() = delegate.getValue(thisRef = this, property = delegate)
}
#+END_SRC
- 当我们使用 p 时调用其get方法，给 p 赋值时调用其set方法，并且都是通过委托对象 delegate 实现。

** 类委托
- 类的委托即一个类中定义的方法实际是调用另一个类对象的方法来实现的。
- 以下实例中， 派生类 Derived 继承了接口 Base 的所有方法，并且委托一个传入的 Base 类的对象来执行这些方法。
#+BEGIN_SRC kotlin
// 接口
interface Base {
    fun share()
}
// 实现此接口的被委托的类
class BaseIMPL : Base {
    override fun share() {
        //  println("BaseIMPL:实现Base接口被委托的类")
        println("BaseIMPL: has implemented Base class d...")
    }
}
// 过关键字 by 创建委托类
class Derived(b: Base) : Base by b
fun main(args: Array<String>) {
	val baseImpl = BaseIMPL()
    Derived(baseImpl).share()
}
#+END_SRC
- 打印数据如下：
#+BEGIN_SRC kotlin
BaseIMPL:实现Base接口被委托的类
#+END_SRC
- Derived 类中实现 Base 接口的方法委托给另一个对象 b: Base 来处理。
- 在 Derived 声明中，by 字句表示：将 b 保存在 Derived 的对象实例内部，而且编译器会让 Derived 生成继承自 Base 接口的所有方法，并将调用转发给 b。
- 上面的例子中，我们已经委托到一个对象了，如果要修改接口里面的方法的时候，可以直接重写，而不需要重新去写新的方法。
#+BEGIN_SRC kotlin
// 接口
interface Base {
    fun share()
}
// 实现此接口的被委托的类
class BaseIMPL : Base {
    override fun share() {
        //  println("BaseIMPL:实现Base接口被委托的类")
        println("BaseIMPL: has implemented Base class d...")
    }
}
// 通过关键字 by 创建委托类
class Derived(b: Base) : Base by b {
    //重写接口的方法
    override fun share() {
        // println("Derived:委托类重写Base中的方法")
        println("Derived: has implemented overried base .....")
    }
}
fun main(args: Array<String>) {
	val baseImpl = BaseIMPL()
    Derived(baseImpl).share()
}
#+END_SRC
- 打印数据如下：
#+BEGIN_SRC kotlin
Derived:委托类重写Base中的方法
#+END_SRC
- 再看一个实践的例子：利用接口代理实现一个集成了 map 和 list 的超级集合
#+BEGIN_SRC kotlin
// 对象 list 和 map 代理 SupperArrayWithDelegate 实现 MutableList，MutableMap
class SupperArrayWithDelegate<E>(
    private val list: MutableList<E?> = mutableListOf(),
    private val map: MutableMap<String, E> = mutableMapOf()
) : MutableList<E?> by list, MutableMap<String, E> by map {
    // 两个接口中都有，编译器不知道执行哪个，所以这些方法必须得重写
    override fun clear() {
        list.clear()
        map.clear()
    }
    override fun isEmpty(): Boolean {
        return list.isEmpty() && map.isEmpty()
    }
    override val size: Int get() = list.size + map.size
    override fun set(index: Int, element: E?): E? {
        if (index <= list.size) {
            repeat(index - list.size - 1) {
                list.add(null)
            }
        }
        return list.set(index, element)
    }
    override fun toString(): String {
        return "list:$list,map:$map"
    }
}
#+END_SRC


** 属性委托(Delegated properties)
*** 属性引用(Property Reference)
- 通过属性引用我们可以更清楚的了解 property 背后的 get 和 set 以及代理信息等( _这里面还有些bug，没有弄通的地方_ )
#+BEGIN_SRC kotlin
import kotlin.reflect.KMutableProperty0
import kotlin.reflect.KMutableProperty1
import kotlin.reflect.KProperty0
import kotlin.reflect.jvm.isAccessible

class PersonKotlin {
    constructor(age: Int, name: String) {
        this.age = age
        this.name = name
    }
    var age: Int? = null
    var name: String? = null
    var sex: String? = null
}
fun main () {
    val ageRef: KMutableProperty1<PersonKotlin, Int?> = PersonKotlin::age
    // PersonKotlin::age 类名获取的属性引用不包含 receiver，操作时需要传递一个
    val personKotlin = PersonKotlin(18, "Jay")
    ageRef.set(personKotlin, 22)
    println(ageRef.get(personKotlin))
    // 22
    // public actual fun set(receiver: T, value: V)
    // public actual fun get(receiver: T): V
    // receiver - 用于获取属性值的接收器。 例如，如果这是该类的成员属性，则它应该是类实例，如果这是顶级扩展属性，则它应该是扩展接收器

    // 测试自定义属性委托后获取属性的委托信息
    val nameRef: KProperty0<String?> = personKotlin::name
    println("personKotlin: " + personKotlin.hashCode())
    println("nameRef: " + nameRef.hashCode())
    println("personKotlin.name: " + personKotlin.name.hashCode())

    // 取： is KMutableProperty -> javaField?.isAccessible ?: true && javaGetter?.isAccessible ?: true &&javaSetter?.isAccessible ?: true
    // 存： is KMutableProperty -> { javaField?.isAccessible = value javaGetter?.isAccessible = value javaSetter?.isAccessible = value }
    // 设置是否访问，只有设置为 true 才可以拿到 属性引用中的委托信息（如果被委托了）这个属性需要单独引入 kotlin-reflect 库
    nameRef.isAccessible = true
    // 如果这是一个委托属性，则返回委托的值，如果此属性未委托，则返回null
    val nameDelegate = nameRef.getDelegate()
    println("nameDelegate： $nameDelegate") // 返回委托信息
    println(nameRef.getter.invoke()) // 相当于调用 get 方法
    // personKotlin: 1751075886
    // nameRef: -954731934
    // thisRef:1751075886
    // property:-954731934
    // personKotlin.name: 88377
    // 可以看到属性引用类和它的 receiver 在委托类和这里的 hashCode 相同
    // com.jay.lib_kotlin.delegate.MyDelegate@5a63f509
    // YYY

    // 测试lazy 属性代理方式
    val sexRef: KProperty0<String?> = personKotlin::sex
    personKotlin.sex
    sexRef.isAccessible = true
    println(sexRef.getDelegate())
    // 获取的代理信息就是lazy代码块中的值：sex is male

    // 测试 属性引用的类型
    val kMutableProperty0: KMutableProperty0<String?> = ::sex // sex 是顶级属性, 这里也没有弄通
    // val s = kMutableProperty0 as CallableReference // BUG: CallableReference reference找不到，这里没有run通
    // println(s.owner) // file class com.jay.lib_kotlin.property.PersonKotlinKt
    // 属性引用的类型是 CallableReference
}
#+END_SRC
- receiver：属性值的接收器。 例如，如果这是该类的成员属性，则它应该是类实例，如果这是顶级扩展属性，则它应该是扩展接收器
- CallableReference：是 Kotlin 编译器为可调用引用类生成的所有类的超类
*** 属性委托实现原理
    #+BEGIN_SRC kotlin
import kotlin.reflect.KProperty

public open class FooBy {
    //只要在by关键字后面带有一个委托对象，这个对象不一定要实现特定的接口，只要包含了getValue/setValue方法、那它就能作为一个代理属性来使用。
    val y by MyDelegate()
    var w: String by MyDelegate()
}
class MyDelegate {
    var value: String = "YYY"
    //todo 委托类里面必须提供 getValue 方法，或者扩展这个方法也可
    operator fun getValue(thisRef: Any, property: KProperty<*>): String {
        return value
    }
    operator fun setValue(thisRef: Any, property: KProperty<*>, s: String) {
        value = s
    }
}
    #+END_SRC
- 编译Java后的代码
#+BEGIN_SRC java
public class FooBy {
    // $FF: synthetic field
    static final KProperty[] $$delegatedProperties = new KProperty[]{(KProperty)Reflection.property1(new PropertyReference1Impl(FooBy.class, "y", "getY()Ljava/lang/String;", 0)), (KProperty)Reflection.mutableProperty1(new MutablePropertyReference1Impl(FooBy.class, "w", "getW()Ljava/lang/String;", 0))};
    @NotNull
    private final MyDelegate y$delegate = new MyDelegate();
    @NotNull
    private final MyDelegate w$delegate = new MyDelegate();

    @NotNull
    public final String getY() {
        return this.y$delegate.getValue(this, $$delegatedProperties[0]);
    }

    @NotNull
    public final String getW() {
        return this.w$delegate.getValue(this, $$delegatedProperties[1]);
    }

    public final void setW(@NotNull String var1) {
        Intrinsics.checkNotNullParameter(var1, "<set-?>");
        this.w$delegate.setValue(this, $$delegatedProperties[1], var1);
    }
}
#+END_SRC
-基类
#+BEGIN_SRC java
public static final class MyDelegate {
    @NotNull
        private String value = "YYY";
    @NotNull
        public final String getValue() {
        return this.value;
    }
    public final void setValue(@NotNull String var1) {
        Intrinsics.checkNotNullParameter(var1, "<set-?>");
        this.value = var1;
    }
    @NotNull
        public final String getValue(@NotNull Object thisRef, @NotNull KProperty property) {
        Intrinsics.checkNotNullParameter(thisRef, "thisRef");
        Intrinsics.checkNotNullParameter(property, "property");
        return this.value;
    }
    public final void setValue(@NotNull Object thisRef, @NotNull KProperty property, @NotNull String s) {
        Intrinsics.checkNotNullParameter(thisRef, "thisRef");
        Intrinsics.checkNotNullParameter(property, "property");
        Intrinsics.checkNotNullParameter(s, "s");
        this.value = s;
    }
}
#+END_SRC
- 当调用下面的代码时，就会调用到 FooBy.y 的 get 方法
#+BEGIN_SRC kotlin
val foo = FooBy()
println(foo.y)
#+END_SRC
- 看一下反编译后的 getY 方法，
#+BEGIN_SRC java
@NotNull
public final String getY() {
   return this.y$delegate.getValue(this, $$delegatedProperties[0]);
}
#+END_SRC
- 看一下 y$delegate 是什么 ,其实就是我们的代理类并在 FooBy 类构建的时候已经初始化
#+BEGIN_SRC java
@NotNull
private final MyDelegate y$delegate = new MyDelegate();
#+END_SRC
- 再看看MyDelegate中的的 getValue 方法, 就是我们在代理类中必须提供的方法
#+BEGIN_SRC java
// Java code
@NotNull
public final String getValue(@NotNull Object thisRef, @NotNull KProperty property) {
   Intrinsics.checkNotNullParameter(thisRef, "thisRef");
   Intrinsics.checkNotNullParameter(property, "property");
   return this.value;
}
#+END_SRC
- 到这里我们就可以看清了整个委托流程了
  - 当类中有属性被委托时，Kotlin 会在当前类中添加委托类的实例并在实例化当前类时实例化委托类( y$delegate)，同时$$delegatedProperties 数组也是在类初始化时创建完成，里面方式所有属性的反射类信息
  - 当要获取委托属性时，会调用到它的 get 方法，而 get 方法返回的是代理类的 getValue 方法
  - getValue 方法是我们自己实现的，最终代理属性就会通过 getValue 方法赋上值了
  - setValue 时还会把 属性 的backing field 传过去
*** PropertyReferenceImpl
- 委托流程搞清楚了，我们再来看看 getValue 方法中 thisRef: Any， property: KProperty<*> 这两个参数是怎么来的，干什么用的
  - thisRef 这个参数是业务类本身可以看到就是在调用 getValue 方法时传递的 this
  - property 是委托属性的描述类 KProperty ,它是从这个数组里取的 $$delegatedProperties[0]，这个数组也是构建业务类时由Kotlin自动生成的，存放的是描述类属性的 KProperty 类型
  - Reflection.property1 是一个工厂函数，将传入的参数返回
  - PropertyReference1Impl 的父类也间接实现了 KProperty 接口，所以这里可以强转
#+BEGIN_SRC kotlin
// $$delegatedProperties
static final KProperty[] $$delegatedProperties =
    new KProperty[]{(KProperty)Reflection.property1(
                         new PropertyReference1Impl(FooBy.class, "y", "getY()Ljava/lang/String;", 0)),
                     (KProperty)Reflection.mutableProperty1(
                         new MutablePropertyReference1Impl(FooBy.class, "w", "getW()Ljava/lang/String;", 0))
    };
#+END_SRC
- 再看一下属性引用实现类 PropertyReference1Impl 的构造参数
- PropertyReference1Impl 类的构造器最终会调用到它的父类 CallableReference
- CallableReference：是 Kotlin 编译器为可调用引用类生成的所有类的超类。
#+BEGIN_SRC kotlin
@SinceKotlin(version = "1.4")
public PropertyReference1Impl(Class owner, String name, String signature, int flags) {
    super(NO_RECEIVER, owner, name, signature, flags);
}
// NO_RECEIVER 如果属性没有 receiver 构造时会缺省添加一个 NO_RECEIVER
@SinceKotlin(version = "1.1")
public static final Object NO_RECEIVER = NoReceiver.INSTANCE;
@SinceKotlin(version = "1.2")
private static class NoReceiver implements Serializable {
    private static final NoReceiver INSTANCE = new NoReceiver();

    private Object readResolve() throws ObjectStreamException {
        return INSTANCE;
    }
}
// CallableReference
@SinceKotlin(version = "1.4")
protected CallableReference(Object receiver, Class owner, String name, String signature, boolean isTopLevel) {
    this.receiver = receiver; // 可调用对象的属性值的接收器。 例如：类实例
    this.owner = owner; // 可调用对象所在的类或包
    this.name = name; // 可调用对象的 Kotlin 名称，即在源代码中声明的名
    this.signature = signature; // 可调用对象的 JVM 签名。如果这是一个属性引用，则返回其 getter 的 JVM 签名，例如“getFoo(LjavalangString;)I”。
    this.isTopLevel = isTopLevel; // 是否高等类型(文件中还是类中)，0 false; 1 true
}
#+END_SRC
- 利用Java的实现方式简单总结以下Kotlin 属性委托的背后原理
#+BEGIN_SRC java
class Person {
    static final Field[] delegatedProperties = Person.class.getFields();
    private final NameDelegate nameDelegate = new NameDelegate();
    public final String getName() {
        return this.nameDelegate.getValue(this, delegatedProperties[0]);
    }
}
class NameDelegate {
    String getValue(Person thisRef, Field property) {
        return "Jay";
    }
}
#+END_SRC
*** 简化属性委托的内置接口们
- Kotlin 内置的属性委托功能是属性委托类，不能像普通的委托模式一样通过接口或集成的方式来约束交互的方法和类型，做不了两方约束，但是可以通过泛型+接口约束一下委托类，也能达到一部分约束的效果。
- Kotlin 标准库中提供了三个接口来简化委托类的实现
#+BEGIN_SRC kotlin
// val 属性
public fun interface ReadOnlyProperty<in T, out V>
// var 属性
public interface ReadWriteProperty<in T, V> : ReadOnlyProperty<T, V>
// 创建委托类的工厂接口
public fun interface PropertyDelegateProvider<in T, out D>
// T：拥有委托属性的对象类型。 
// V：属性值的类型。
// D：委托类的类型
#+END_SRC
- 看一下三个接口的接口和方法签名
#+BEGIN_SRC kotlin
public fun interface ReadOnlyProperty<in T, out V> {
    public operator fun getValue(thisRef: T, property: KProperty<*>): V
}
public interface ReadWriteProperty<in T, V> : ReadOnlyProperty<T, V> {
    public override operator fun getValue(thisRef: T, property: KProperty<*>): V
    public operator fun setValue(thisRef: T, property: KProperty<*>, value: V)
}
@SinceKotlin("1.4")
public fun interface PropertyDelegateProvider<in T, out D> {
    public operator fun provideDelegate(thisRef: T, property: KProperty<*>): D
}
// 前两个直接用就行，看一个 PropertyDelegateProvider 的使用场景
private val provider = PropertyDelegateProvider<FooBy, MyDelegate> { thisRef, property ->
    if (thisRef.y == "YYY") {
        MyDelegate()
    } else {
        MyDelegate2() // MyDelegate2:MyDelegate
    }
}
#+END_SRC
- 看一下他们几个综合使用的情况，同时也可以看到kt语音的强大，同样的功能,代码可以从十几行到三行再到一行。yyds!!!
#+BEGIN_SRC kotlin
val provider1 = object : PropertyDelegateProvider<FooReadWrite, ReadWriteProperty<FooReadWrite, Int>> {
        override fun provideDelegate(
            thisRef: FooReadWrite,
            property: KProperty<*>
        ): ReadWriteProperty<FooReadWrite, Int> {
            return object : ReadWriteProperty<FooReadWrite, Int> {
                var result=1024
                override fun getValue(thisRef: FooReadWrite, property: KProperty<*>): Int {
                    return result
                }
                override fun setValue(thisRef: FooReadWrite, property: KProperty<*>, value: Int) {
                    result=value
                }
            }
        }
    }
// lambda 简化版本
val provider2: PropertyDelegateProvider<FooReadWrite, ReadOnlyProperty<FooReadWrite, Int>> =
    PropertyDelegateProvider<FooReadWrite, ReadOnlyProperty<FooReadWrite, Int>> { pThisRef: Any?, pProperty: KProperty<*> ->ReadOnlyProperty<Any?, Int> { thisRe f, property -> 1025 }
// 智能类型推导再简化版本
private val provider3 =PropertyDelegateProvider { _: Any?, _ -> ReadOnlyProperty<Any?, Int> { _, _ -> 1026 } }

val delegate1: Int by provider1
val delegate2: Int by provider2
val delegate3: Int by provider3
#+END_SRC

** 属性委托
- 我们先通过对比 Java field 和 kotlin property 来探究一下 kt 中 property 的内部实现方式
#+BEGIN_SRC kotlin
//PersonKotlin 尽量写的像Java好对比 Kotlin 属性背后做的事情
class PersonKotlin {
    constructor(age: Int, name: String) {
        this.age = age
        this.name = name
    }
    private var age: Int? = null
        //Redundant getter 属性的 get/set 方法由编译器自动生成
        get() {
            return field //这里的 field = backing field
        }
        set(value) {
            field = value
        }
    private var name: String? = null
        get() {
            return field
        }
        set(value) {
            field = value
        }
}
#+END_SRC
- kotlin
#+BEGIN_SRC kotlin
//反编译 Java 后的代码
public final class PersonKotlin {
   private Integer age; //field
   private String name; //field
   private final Integer getAge() {
      return this.age;
   }
   private final void setAge(Integer value) {
      this.age = value;
   }
   private final String getName() {
      return this.name;
   }
   private final void setName(String value) {
      this.name = value;
   }
   public PersonKotlin(int age, @NotNull String name) {
      Intrinsics.checkNotNullParameter(name, "name");
      super();
      this.setAge(age);
      this.setName(name);
   }
}
#+END_SRC
- property(kotlin)=field(java)+getField()+setField()
#+BEGIN_SRC kotlin
// age 属性背后包含了三个角色，backing field、get、set
private var age: Int? = null
#+END_SRC
- 等价于下面的代码
#+BEGIN_SRC java
@Nullable
private Integer age;
@Nullable
public final Integer getAge() {
   return this.age;
}
public final void setAge(@Nullable Integer var1) {
   this.age = var1;
}
#+END_SRC
- 属性委托是指一个类的某个属性值不是在类中直接定义的，而是将其托付给一个代理类，从而实现对该类的属性的统一管理。有一些常见的属性类型，尽管我们可以在每次需要时手动实现它们，但最好是只实现一次，放入库中一直使用。
- 属性委托包括：
  - 延迟属性（lazy properties）：数据只在第一次访问时计算；
  - 观察属性(observable properties)：监听器会得到这个属性变化的通知；
  - Map 委托属性（Storing Properties in a Map）：把多个属性值存储在一个 Map 中，而不是为每个属性存储单独的字段。
- 委托的语法格式：
  - val/var <属性名>: <类型> by <表达式>
    - val/var <property name>: <Type> by <expression>
    - val/var ：  属性类型；
    - 属性名 ：  属性名称；
    - 类型 ：   属性的数据类型；
    - 表达式 ：  委托代理类。
*** 委托的底层原理
- 在底层，Kotlin 编译器会为每个委托属性生成一个辅助属性并委托给它。
#+BEGIN_SRC kotlin
    class Person {
        var prop: Int by Delegate()
    }
#+END_SRC
- 对于属性prop，会生成隐藏属性 prop$delegate，访问器的代码会简单地委托给这个附加的属性：
#+BEGIN_SRC kotlin
// 以下代码有编译器生成
class Person  {
    private val prop$delegate = Delegate()
        
    var prop: Int
        set(value: Type) = prop$delegate.setValue(this, this::prop, value)
        get() = prop$delegate.getValue(this, this::prop)
}
#+END_SRC
- by 后面的表达式就是委托，属性 prop 的 get() 和 set() 方法将委托给 delegate 对象的 getValue() 和 setValue() 方法。
- Kotlin 编译器在参数中提供了关于 prop 的所有必要信息：第一个参数 this 引用了外部类 Person 的一个实例，这个 ::prop 是 KProperty 类型的一个反射对象，该对象描述了 prop 本身。
注意：直接引用代码中绑定可调用的 this::prop 语法只在 Kotlin1.1之后才可以用。
- 属性委托不必实现任何接口，但必须提供一个 getValue() 函数（对于 var 属性，还需要setValue()函数）。这两个函数都需要使用 operator 关键字进行标记，意味着委托属性依赖于约定的公能，像其他约定的函数一样， getValue() 和setValue()可以是成员函数，也可以是扩展函数。

*** 定义一个被委托的类
- 定义一个被委托的类，该类包含 getValue() 和 setValue() 方法，且参数 thisRef 为进行委托的类的对象，property 为进行委托的属性的对象，两个函数都要使用 operator 关键字标记。
#+BEGIN_SRC kotlin
import kotlin.reflect.KProperty

// 定义包含属性委托的类
class School {
    var str: String by Delegate()
}
// 委托的类
class Delegate {
	// 方法使用operator 修饰，thisRef 为进行委托的类的对象，property 为进行委托的属性的对象。
    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        return "$thisRef, 这里委托了${property.name}属性!"
    }
	// value：表示当前属性值，必须和属性同类型或者是它的超类型。
    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        println("$thisRef 的属性${property.name}赋值为$value ")
    }
}
fun main(args: Array<String>) {
    val school = School()
    println(school.str) // 访问该属性，调用了getValue()函数
    school.str = "Android" // 调用 setValue() 函数
}
#+END_SRC
- 属性 str 委托给 Delegate 的实例时，当我们从 str 中读取（调用str的get()方法），Delegate 的 getValue() 函数会被调用，它的第一个参数 thisRef 就是我们从 str 中读取的对象，第二个参数 property 包含 str 本身的描述。
- 同理，当我们给 str 赋值时（调用str的set()方法），会调用 Delegate 的setValue() 函数。前两个参数是相同的，第三个保存被分配的值：
- 打印数据如下：
#+BEGIN_SRC kotlin
DelegatedActivity$School@758e189, 这里委托了str属性!
DelegatedActivity$School@758e189 的属性str赋值为 Android 
#+END_SRC
*** 属性委托规则
- 这里我们总结了委托对象的需求：
  - （1）对于只读属性（val），委托必须提供具有以下参数的操作函数 getValue()。
    - thisRef：   进行委托的类的对象，必须是属性所有者的相同或超类型（对于扩展属性-被扩展的类型）；
    - property：  为进行委托的属性的对象，property.name 表示属性名称，必须是 KProperty<*> 类型或是其超类型。
    - 这个函数必须返回与属性相同的类型（或其子类型）。
  - （2）对于可变属性（var），除了 getValue() 函数之外，它的委托必须另外提供一个名为 setValue() 的函数，带有以下参数：
    - thisRef：   进行委托的类的对象，必须是属性所有者的相同或超类型（对于扩展属性-被扩展的类型）；
    - property：  为进行委托的属性的对象，property.name 表示属性名称，必须是 KProperty<*> 类型或是其超类型。
    - value：   表示当前属性值，必须和属性同类型或者是它的超类型。
- 注意：由于 Kotlin1.1 你可以在函数或代码块中声明委托属性，它不应该是类的成员。

** 标准委托
*** lazy
- 函数lazy接收一个 lambda 表达式并返回一个 Lazy 实例，默认情况下其线程安全
#+BEGIN_SRC kotlin
// 方法签名
public actual fun  lazy(initializer: () -> T): Lazy = SynchronizedLazyImpl(initializer)
#+END_SRC
- 应用一下
#+BEGIN_SRC kotlin
val s: String by lazy {
	println("get")
	"hello"
}
fun main() {
    println(s)
    println(s)    
}
#+END_SRC
- 只有在第一次调用 s 时才会执行传递给 lazy() 的 lambda 表达式并返回一个记录下来的结果， 后续调用 get() 只会返回记录的结果。底层原理在于函数签名中的SynchronizedLazyImpl方法，其中会检查变量的值，判断其是否为默认值，如果是则执行初始化函数，否则直接返回结果，具体代码可以查阅LazyJVM.kt文件。
- 控制台输出为
#+BEGIN_SRC kotlin
get
hello
hello
#+END_SRC
- LazyThreadSafetyMode 有三种模式作用是指定 [Lazy] 实例如何在多个线程之间同步初始化。
  - SYNCHRONIZED: 锁用于确保只有一个线程可以初始化[Lazy]实例。
  - PUBLICATION: 并发访问未初始化的[Lazy]实例值时，可以多次调用Initializer函数，但是只有第一个返回的值将用作[Lazy]实例的值。
  - NONE: 不使用锁来同步对 [Lazy] 实例值的访问；如果从多个线程访问该实例，可能会发生线程安全问题。除非保证 [Lazy] 实例永远不会从多个线程初始化，否则不应使用此模式。
**** lazy 原理解析
- 受托对象是Lazy
#+BEGIN_SRC kotlin
@NotNull
private final Lazy x$delegate;
#+END_SRC
- 受托对象在委托者构造方法中实例化
#+BEGIN_SRC kotlin
public FooLazy() {
   this.x$delegate = LazyKt.lazy(LazyThreadSafetyMode.SYNCHRONIZED, (Function0)(new Function0() {
      // $FF: synthetic method
      // $FF: bridge method
      public Object invoke() {
         return this.invoke();
      }
      @NotNull
      public final String invoke() {
         String var1 = "xxx——lazy";
         boolean var2 = false;
         System.out.println(var1);
         StringBuilder var10000 = (new StringBuilder()).append("xxx——");
         FooLazy var10001 = FooLazy.this;
         int var3;
         var10001.index = (var3 = var10001.index) + 1;
         return var10000.append(var3).toString();
      }
   }));
}
#+END_SRC
- 可以看到 x$delegate 是通过 LazyKt.lazy() 方法实例化的，两个参数分别是线程安全模式类型和一个接口回调
- 当调用x 的 get 方法时 反回了受托者的 getValue 方法 并没有调用 lazy 的扩展方法：LazyKt.getValue(thisRef: Any?, property: KProperty<*>)
#+BEGIN_SRC java
public final String getX() {
   Lazy var1 = this.x$delegate;
   return (String)var1.getValue();
}
#+END_SRC
- 再看一下 lazy 是如何定义委托方法 getValue 的
#+BEGIN_SRC kotlin
@kotlin.internal.InlineOnly
public inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value
#+END_SRC
- 这里有没有注意到 lazy 利用属性委托的方式是不同的
  - 没有自动生成属性数组 KProperty[] $$delegatedProperties
  - getX 时最终返回时调用的也不是 getValue(thisRef: Any?, property: KProperty<*>)
  - lazy 的 getValue(thisRef: Any?, property: KProperty<*>) 方法是用 inline 修饰的 并且添加了@kotlin.internal.InlineOnly 注解，map 委托 也是这样的操作
- 其实这里是Kotlin 1.4 做的优化，当某些委托属性不会使用 KProperty。对于他们来说，在 $$delegatedProperties 中生成一个KProperty对象是多余的。Kotlin 1.4 版本将优化此类情况。如果委托的属性运算符是内联的，并且没有使用 KProperty 参数，则不会生成相应的反射对象。如果委托属性中有没有采用 inline 修饰的 ， 最终生成的$$delegatedProperties 数组中也之会单独生成它自己的反射对象，详细说明可以看官方的这篇博客: What to Expect in Kotlin 1.4 and Beyond | Optimized delegated properties https://blog.jetbrains.com/kotlin/2019/12/what-to-expect-in-kotlin-1-4-and-beyond/ 
- 内联实际上是如何工作的？
  - 粗略地说，内联采用被内联的函数的字节码，并将其插入到调用处，因此内联函数声明不必在调用处可见。
- @kotlin.internal.InlineOnly 注解的作用？
  - InlineOnly 意味着与此 Kotlin 函数对应的 Java 方法被标记为私有，因此 Java 代码无法访问它（这是调用内联函数而不实际内联它的唯一方法）。这个注释还没有得到很好的验证，官方目前只在内部使用，很有可能稍后将其公之于众。
- 所以 lazy 和 map 的属性委托在 Kotlin 4.1 都是做了优化的，lazy 属性在调用 getter 时实际上是调用的的是 Lazy<T> 中 value 的 getter，map 属性在调用 getter/setter 时 实际上最终调用的也是 map 的 get/put 方法。
- 看一下 lazy 函数签名
#+BEGIN_SRC kotlin
public actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> =
    when (mode) {
        LazyThreadSafetyMode.SYNCHRONIZED -> SynchronizedLazyImpl(initializer)
        LazyThreadSafetyMode.PUBLICATION -> SafePublicationLazyImpl(initializer)
        LazyThreadSafetyMode.NONE -> UnsafeLazyImpl(initializer)
    }
#+END_SRC
***** SynchronizedLazyImpl
- SynchronizedLazyImpl 采用 DCL 方式确保线程安全
#+BEGIN_SRC kotlin
private class SynchronizedLazyImpl<out T>(initializer: () -> T, lock: Any? = null) : Lazy<T>, Serializable {
    private var initializer: (() -> T)? = initializer
    @Volatile // 用内存可见性来检查是否在其他线程初始化过，同时也会禁止指令重排序防止_value拿到不完整的实例
    private var _value: Any? = UNINITIALIZED_VALUE
    //实例使用自身进行同步
    private val lock = lock ?: this
    //Lazy 接口的 value 属性用于获取当前 Lazy 实例的延迟初始化值。一旦初始化后，它不得在此 Lazy 实例的剩余生命周期内更改。
    val value: T
        // 重写 get 来保证懒加载，只在使用的时候才执行函数
        get() {
            //局部变量可以将性能提高25%以上
            val _v1 = _value
            //检查单例实例是否已初始化。如果它被初始化就返回实例。
            if (_v1 !== UNINITIALIZED_VALUE) {
                @Suppress("UNCHECKED_CAST")
                return _v1 as T
            }
            //到这里还没有初始化，但我们不能确定，因为可能有多个其他线程可能同时初始化了它。
            //所以为了以防万一，这里需要添加一把互斥锁来保证只有一个线程去实例化实例对象。
            return synchronized(lock) {
                //再次将实例分配给局部变量以检查它是否被其他线程初始化，而当前线程被阻止进入锁定区域。
                val _v2 = _value
                //如果它已经被其它线程初始化了，当前线程也能感知他的存在了，直接返回实例
                if (_v2 !== UNINITIALIZED_VALUE) {
                    @Suppress("UNCHECKED_CAST")
                    (_v2 as T)
                } else {
                    //到这里该实例仍未初始化，因此我们可以安全地（没有其他线程可以进入该区域）创建一个实例了。
                    val typedValue = initializer!!() //执行 Function 对象的 invoke 并将函数的返回值缓存起来
                    _value = typedValue //_value赋值通知其它线程别进来了，拿走用吧
                    initializer = null //initializer在当前类实例已经没用了
                    typedValue // 返回最终的结果给 value
                }
            }
        }
}
#+END_SRC
- 看不惯这种DCL也可以恢复成传统方式看一下
#+BEGIN_SRC kotlin
val value: T
    get() {
        //局部变量将性能提高了 25% Joshua Bloch “Effective Java, Second Edition”，第 3 页。 283-284
        var _v1 = _value
        if (_v1 == UNINITIALIZED_VALUE) {
            synchronized(lock) {
                // 再次将实例分配给局部变量以检查它是否被其他线程初始化，而当前线程被阻止进入锁定区域。
                // 如果它被初始化，当前线程也能感知他的存在了。
                _v1 = _value
                if (_v1 == UNINITIALIZED_VALUE) {
                    // 该实例仍未初始化，因此我们可以安全地（没有其他线程可以进入该区域）创建一个实例并将其赋值给我们的单例引用。
                    _v1 = initializer!!()
                    initializer = null
                }
            }
        }
        @Suppress("UNCHECKED_CAST")
        return _v1 as T
    }
#+END_SRC
***** SafePublicationLazyImpl
- AtomicReferenceFieldUpdater ：原子更新器是基于反射的工具类，用来对某个类中，被volatile修饰的字段进行原子更新。
- 通过调用AtomicReferenceFieldUpdater的静态方法newUpdater就能创建它的实例，该方法要接收三个参数：包含该字段所在的类、将被更新的对象的类型、将被更新的字段的名称
  - compareAndSet 如果期望值和字段当前值相等，说明目前是最新的值可以进行更新返回 true 同时原子地将字段设置为给定的更新值。
  - getAndSet原子地将此更新程序管理的给定对象的字段设置为给定值并返回旧值。
- 原子更新器的使用存在比较苛刻的条件如下
  - 操作的字段不能是static类型。
  - 操作的字段不能是final类型的，因为final根本没法修改。
  - 字段必须是volatile修饰的，也就是数据本身是读一致的。
  - 属性必须对当前的Updater所在的区域是可见的，如果不是当前类内部进行原子更新器操作不能使用private，protected子类操作父类时修饰符必须是protect权限及以上，如果在同一个package下则必须是default权限及以上，也就是说无论何时都应该保证操作类与被操作类间的可见性。
- CAS，Compare and Swap即比较并交换，设计并发算法时常用到的一种技术，java.util.concurrent包全完建立在CAS之上，没有CAS也就没有此包，可见CAS的重要性。当前的处理器基本都支持CAS，只不过不同的厂家的实现不一样罢了。CAS有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。
- Unsafe，JDK中的一个类，它提供了硬件级别的原子操作。
- compareAndSet 方法调用流程
#+BEGIN_SRC java
private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe();
public final boolean compareAndSet(T obj, V expect, V update) {
    accessCheck(obj);
    valueCheck(update);
    return U.compareAndSwapObject(obj, offset, expect, update);
}
public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);
#+END_SRC
- 看一个例子了解 AtomicReferenceFieldUpdater 的使用方式
#+BEGIN_SRC java
public class AtomicReferenceFieldUpdaterTest {
  public static void main(String[] args) throws Exception {
    // T:持有可更新字段的对象的类型
    // V:字段的类型
    AtomicReferenceFieldUpdater<Dog, String> updater =
        // 包含该字段所在的类、将被更新的对象的类、将被更新的字段的名称
        AtomicReferenceFieldUpdater.newUpdater(Dog.class, String.class, "name");
    Dog dog = new Dog();
    // 如果期望值和字段当前值相等，说明目前是最新的值可以进行更新，则原子地将字段设置为给定的更新值。
    // 参数：
    // obj: 字段所在对象
    // expect - 期望值
    // update - 新值
    // 返回：如果成功则为true
    System.out.println(dog.name); // dog1 默认值
    boolean result = updater.compareAndSet(dog, "dog1", "dog2");
    System.out.println(result); // true 修改成功
    System.out.println(dog.name); // dog2 修改后的的值
    boolean result2 = updater.compareAndSet(dog, "dog1", "dog3");
    System.out.println(result2); // false 修改失败
    System.out.println(dog.name); // dog2 还是原来的值
    // 原子地将此更新程序管理的给定对象的字段设置为给定值并返回旧值。
    // 参数：
    // obj – 更新字段的对象
    // newValue – 新值
    // 返回：之前的的值
    String result3 = updater.getAndSet(dog, "dog4");
    System.out.println(result3); // dog2  原来的值
    System.out.println(dog.name); // dog4 修改后的值
  }
}
class Dog {
  volatile String name = "dog1";
}
#+END_SRC
- SafePublicationLazyImpl 使用 AtomicReferenceFieldUpdater 来保证 _value 属性的原子操作。支持同时多个线程调用，并且可以在全部或部分线程上同时进行初始化。如果某个值已由另一个线程初始化，则将返回该值而不执行初始化。
#+BEGIN_SRC kotlin
private class SafePublicationLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {
    @Volatile private var initializer: (() -> T)? = initializer
    @Volatile private var _value: Any? = UNINITIALIZED_VALUE
    private val final: Any = UNINITIALIZED_VALUE
    override val value: T
        get() {
            val value = _value
            if (value !== UNINITIALIZED_VALUE) {
                @Suppress("UNCHECKED_CAST")
                return value as T
            }
            val initializerValue = initializer
            //如果在这里看到初始值已经为 null，则表示该值已被另一个线程设置过了，直接返回 _value ，否则就初始化
            if (initializerValue != null) {
                val newValue = initializerValue() //执行 Function 对象的 invoke 并将函数返回值原子化赋值给 _value
                //如果_value的值是UNINITIALIZED_VALUE说明还没有线程初始化它，此时可以将newValue设置给_value
                if (valueUpdater.compareAndSet(this, UNINITIALIZED_VALUE, newValue)) {
                    initializer = null
                    return newValue //只有唯一的线程会从这里返回，其它都走下面的返回了
                }
              //如果_value的值不是UNINITIALIZED_VALUE，说明其它线程已经初始化完了，当前线程直接返回_value就行了
            }
            @Suppress("UNCHECKED_CAST")
            return _value as T
        }
        //如果一个序列化类中含有Object writeReplace()方法，那么实际序列化的对象将是作为writeReplace方法返回值的对象，
    private fun writeReplace(): Any = InitializedLazyImpl(value)
    companion object {
        //初始化一个原子更新器：保证原子操作的字段是 _value
        private val valueUpdater = java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater(
            SafePublicationLazyImpl::class.java,
            Any::class.java,
            "_value"
        )
    }
}
#+END_SRC
***** UnsafeLazyImpl
      #+BEGIN_SRC kotlin
internal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {
    private var initializer: (() -> T)? = initializer
    private var _value: Any? = UNINITIALIZED_VALUE
    override val value: T
        get() {
            //普通的懒加载，只初始化一次，但是在多线程环境下不能保证只执行一次
            if (_value === UNINITIALIZED_VALUE) {
                _value = initializer!!() //多线程并发情况下可能出现空指针异常
                initializer = null
            }
            @Suppress("UNCHECKED_CAST")
            return _value as T
        }
    //如果一个序列化类中含有Object writeReplace()方法，那么实际序列化的对象将是作为writeReplace方法返回值的对象，
    private fun writeReplace(): Any = InitializedLazyImpl(value)
      #+END_SRC

*** observable: 被观察者observable
- 字面意思，用委托的方式来定义一个可观察属性。该函数的方法签名为
- observable 可以用于实现观察者模式。Delegates.observable() 有两个参数：第一个是初始化值；第二个是属性值变化事件的响应器（handler）。
#+BEGIN_SRC kotlin
public inline fun  observable(initialValue: T, crossinline onChange: (property: KProperty<*>, oldValue: T, newValue: T) -> Unit): ReadWriteProperty
#+END_SRC
- 其接收两个参数，第一个为默认值，第二个为 lambda 表达式，位于Delegates.kt，具体使用
- 在执行了赋值之后都会执行属性值变化事件的响应器（handler）。它有三个参数：一个被分配的属性，旧值和新值：
#+BEGIN_SRC kotlin
// import kotlin.reflect.KProperty
import kotlin.properties.Delegates
var name: String by Delegates.observable("initialValue") {
	property, oldValue, newValue ->
	    println("$oldValue -> $newValue")
}
fun main() {
    name = "newValue0"
    name = "newValue1"
}
#+END_SRC
- 控制台输出
#+BEGIN_SRC kotlin
initialValue -> newValue0
newValue0 -> newValue1
#+END_SRC
- 如果你想拦截修改属性动作并禁止修改它们，请使用 vetoable() 取代 observable()。handler 需要返回一个 Boolean 值，true 表示同意修改，false 表示禁止修改。该回调会在修改属性值之前调用。
#+BEGIN_SRC kotlin
import kotlin.properties.Delegates
class User {
    var name: String by Delegates.vetoable("Initial Value") {
        property, oldValue, newValue ->
            println("observable: prev value == $oldValue | new value == $newValue")
        return@vetoable false
    }
}
fun main(args: Array<String>) {
    val user = User()
    user.name = "first" //第一次赋值
    user.name = "second" //第二次赋值
}
#+END_SRC
- ObservableProperty
#+BEGIN_SRC kotlin
public abstract class ObservableProperty<V>(initialValue: V) : ReadWriteProperty<Any?, V> {
    private var value = initialValue
    protected open fun beforeChange(property: KProperty<*>, oldValue: V, newValue: V): Boolean = true
    protected open fun afterChange(property: KProperty<*>, oldValue: V, newValue: V): Unit {}
    public override fun getValue(thisRef: Any?, property: KProperty<*>): V {
        return value
    }
    public override fun setValue(thisRef: Any?, property: KProperty<*>, value: V) {
        val oldValue = this.value
    //beforeChange: 在尝试更改属性值之前调用的回调。 调用此回调时，该属性的值尚未更改。 如果回调返回true ，则属性的值被设置为新值，如果回调返回false ，则丢弃新值，属性保持其旧值
        if (!beforeChange(property, oldValue, value)) {
            return
        }
        this.value = value
    //afterChange: 进行属性更改后调用的回调。 调用此回调时，该属性的值已更改。
        afterChange(property, oldValue, value)
    }
}
#+END_SRC
- observable 变量值更新后的监听
#+BEGIN_SRC kotlin
public inline fun <T> observable(initialValue: T, crossinline onChange: (property: KProperty<*>, oldValue: T, newValue: T) -> Unit): ReadWriteProperty<Any?, T> =
    object : ObservableProperty<T>(initialValue) {
        override fun afterChange(property: KProperty<*>, oldValue: T, newValue: T) = onChange(property, oldValue, newValue)
    }
#+END_SRC
- vetoable变量值更新前的拦截
#+BEGIN_SRC kotlin
public inline fun <T> vetoable(initialValue: T, crossinline onChange: (property: KProperty<*>, oldValue: T, newValue: T) -> Boolean): ReadWriteProperty<Any?, T> =
    object : ObservableProperty<T>(initialValue) {
        override fun beforeChange(property: KProperty<*>, oldValue: T, newValue: T): Boolean = onChange(property, oldValue, newValue)
    }
#+END_SRC
- 测试代码
#+BEGIN_SRC kotlin
var items: List<String> by Delegates.observable(mutableListOf()) { property, oldValue, newValue ->
    println("${property.name} : $oldValue -> $newValue")
}
var nameAfter: String by Delegates.observable("no") { prop, old, new ->
    println("$old -> $new")
}
var nameBefore: String by Delegates.vetoable("no") { prop, old, new ->
    println("$old -> $new")
    true //返回true 表示 setValue 成功，否则不能覆盖原值
}
private fun <T> onChange(property: KProperty<*>, oldValue: T, newValue: T) {
    println("${property.name} : $oldValue -> $newValue")
}
var age: Int by Delegates.observable(18, ::onChange)
//运行结果
no -> first
first -> second
no -> 11111
11111 -> 2222
age : 18 -> 33
age : 33 -> 55
items : [] -> [new val]
items : [new val] -> [new val, new 111]
#+END_SRC

*** Storing: 在Map中存储属性
- 一个常见的用法是在 Map 中存储属性值。这经常出现在解析 JSON 或做其他动态事情的应用程序中。在这种情况下，您可以使用 Map 实例本身作为委托属性的委托。
#+BEGIN_SRC kotlin
class Student(val map: Map<String, Any?>) {
    val name: String by map
    val age: Int by map
}
fun main(args: Array<String>) {
    // 构造函数接收一个Map参数
	val student: Student = Student(mapOf("name" to "Kotlin", "age" to 20))
	// 读取Map值
	println("Student: name == ${student.name}, age == ${student.age}")
}
#+END_SRC
- 委托属性从这个 Map 中获取值，打印数据如下：
#+BEGIN_SRC kotlin
Student: name == Kotlin, age == 20
#+END_SRC
- 如果你使用 var 的属性，需要把 Map 换成 MutableMap。
#+BEGIN_SRC kotlin
class MutlStudent(val map: MutableMap<String, Any?>) {
    val name: String by map
    val age: Int by map
}
fun main(args: Array<String>) {
    val map = mutableMapOf<String, Any?>(
        "name" to "Android",
        "age" to 100)
    val studentMutl: MutlStudent = MutlStudent(map)
    println("MutlStudent: name == ${studentMutl.name}, age == ${studentMutl.age}")
    map["name"] = "Java"
    map["age"] = 2000
    println("MutlStudent: name == ${studentMutl.name}, age == ${studentMutl.age}")
}
#+END_SRC
- 打印数据如下：
#+BEGIN_SRC kotlin
MutlStudent: name == Android, age == 100
MutlStudent: name == Java, age == 2000
#+END_SRC
**** 再来窥探一下 Map delegation 的委托原理
     #+BEGIN_SRC kotlin
// $FF: synthetic field
static final KProperty[] $$delegatedProperties = new KProperty[]{(KProperty)Reflection.property1(new PropertyReference1Impl(User.class, "name", "getName()Ljava/lang/String;", 0)), (KProperty)Reflection.mutableProperty1(new MutablePropertyReference1Impl(User.class, "age", "getAge()Ljava/lang/Integer;", 0))};
@Nullable
private final Map age$delegate;
@Nullable
public final Integer getAge() {
   Map var1 = (Map)this.age$delegate;
   KProperty var3 = $$delegatedProperties[1];
   boolean var4 = false;
   return (Integer)MapsKt.getOrImplicitDefaultNullable(var1, var3.getName());
}
public final void setAge(@Nullable Integer var1) {
   Map var2 = (Map)this.age$delegate;
   KProperty var4 = $$delegatedProperties[1];
   boolean var5 = false;
   var2.put(var4.getName(), var1);
}
     #+END_SRC
- 可以看到，Kotlin 编译器 也生成了KProperty[] 类型的 $$delegatedProperties 和 Map 类型 agedelegate
- Map相关的委托必要方法在MapAccessors 这个类里面
#+BEGIN_SRC kotlin
//Map
@kotlin.internal.InlineOnly
public inline operator fun <V, V1 : V> Map<in String, @Exact V>.getValue(thisRef: Any?, property: KProperty<*>): V1 =@Suppress("UNCHECKED_CAST") (getOrImplicitDefault(property.name) as V1)
//MutableMap
@kotlin.jvm.JvmName("getVar")
@kotlin.internal.InlineOnly
public inline operator fun <V, V1 : V> MutableMap<in String, out @Exact V>.getValue(thisRef: Any?, property: KProperty<*>): V1 = @Suppress("UNCHECKED_CAST") (getOrImplicitDefault(property.name) as V1)
//MutableMap
@kotlin.internal.InlineOnly
public inline operator fun <V> MutableMap<in String, in V>.setValue(thisRef: Any?, property: KProperty<*>, value: V) {
    this.put(property.name, value)
}
#+END_SRC
- 在访问 age 的 get 时会调用委托 Map 的 (Integer)MapsKt.getOrImplicitDefaultNullable(var1, var3.getName());
- 在访问 age 的 set 时直接调用委托 Map 的put方法
- 下面是 getOrImplicitDefaultNullable 函数
#+BEGIN_SRC kotlin
//JvmName 这个注解是指定从此元素生成的 Java 类或方法的名称。
//扩展方法编译后会将方法的 reciver 作为第一个参数传入
@kotlin.jvm.JvmName("getOrImplicitDefaultNullable")
@PublishedApi
internal fun <K, V> Map<K, V>.getOrImplicitDefault(key: K): V {
    if (this is MapWithDefault)return this.getOrImplicitDefault(key)
    return getOrElseNullable(key, { throw NoSuchElementException("Key $key is missing in the map.") })
}
#+END_SRC
- 关于 map 的 put 和 get 操作是如何与委托的 getValue 和 setValue 如何联系在一起的 以及map 的 getValue(thisRef: Any?, property: KProperty<*>)方法为什么用 inline 修饰了，这里涉及到Kotlin 1.4 对委托属性的一个优化，稍后再解析 lazy 原理时会详细解释。
- Map delegation 的一个实践，将推送消息封装并通知APP
#+BEGIN_SRC kotlin
override fun onNotificationReceivedInApp(
    context: Context,
    title: String,
    summary: String,
    extraMap: Map<String, String>,
) {
    val data = extraMap.withDefault { "" }
    val params = NotificationParams(data)
    EventBus.getDefault().post(params)
}

class NotificationParams(val map: Map<String, String>) {
    val title: String by map
    val content: String by map
}
#+END_SRC
*** Not Null
- Not Null 适合那些无法在初始化阶段就确定属性值的场合。
#+BEGIN_SRC kotlin
import kotlin.properties.Delegates
class Foo {
	var notNullName: String by Delegates.notNull<String>()
}
fun main(args: Array<String>) {
    Foo().notNullName = "Initial value"
    println(Foo().notNullName)
}
#+END_SRC
- 注意：如果属性值在赋值前就被访问，则会抛出异常。
#+BEGIN_SRC kotlin
Exception in thread "main" java.lang.IllegalStateException: Property notNullName should be initialized before get.
        at kotlin.properties.NotNullVar.getValue(Delegates.kt:62)
        at Foo.getNotNullName(tmp.kt:4)
        at TmpKt.main(tmp.kt:9)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:78)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:567)
        at org.jetbrains.kotlin.runner.AbstractRunner.run(runners.kt:64)
        at org.jetbrains.kotlin.runner.Main.run(Main.kt:176)
        at org.jetbrains.kotlin.runner.Main.main(Main.kt:186)
#+END_SRC
- notNull 可以返回一个经过非空校验的属性值但是该属性值并没有初始化需要人为稍后setValue
- 在分配初始值之前尝试读取属性会导致异常，这也是返回非空属性的原理所在
- 非空属性应用场景分析
  - 通常，声明为非空类型的属性必须在构造函数中初始化。然而，这通常并不方便。 例如，可以通过依赖注入或在单元测试的 setup 方法中初始化属性。在这种情况下，您不能在构造函数中提供非 null 初始值设定项，但您仍然希望在引用类体内的属性时避免空检查。
- notNull VS lateinit
  - lateinit 不支持原始类型、只能用在可变属性var
  - notNull 会为每个属性创建委托类 NotNullVar
- notNull 的使用与原理
#+BEGIN_SRC kotlin
    var name2: String by Delegates.notNull()
    val age2: Int by Delegates.notNull() // notNull 会为每个属性创建委托类 NotNullVar
//    lateinit var age3: Int //lateinit 不支持原始类型
    lateinit var name3: String //lateinit 只能用在 var
public fun <T : Any> notNull(): ReadWriteProperty<Any?, T> = NotNullVar()
private class NotNullVar<T : Any>() : ReadWriteProperty<Any?, T> {
    private var value: T? = null
    public override fun getValue(thisRef: Any?, property: KProperty<*>): T {
        return value ?: throw IllegalStateException("Property ${property.name} should be initialized before get.")
    }
    public override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {
        this.value = value
    }
}
#+END_SRC

** 本地委托属性
- 你可以将局部变量声明为委托属性。例如，你可以使一个局部变量惰性初始化：
#+BEGIN_SRC kotlin
fun example(computeFoo: () -> Foo) {
    val memoizedFoo by lazy(computeFoo)
    if (someCondition && memoizedFoo.isValid()) 
        memoizedFoo.doSomething()
}
#+END_SRC
- 变量 memoizedFoo 只在第一次访问时计算。如果 someCondition 失败，则根本不会计算该变量。
** 委托给另一个属性
- 自 Kotlin1.4 以来，一个属性可以将它的 getter 和 setter 委托给另一个属性。这种委托可用于顶级属性和类属性（成员和扩展）。delegate 属性可以是：
  - 一个顶级属性；
  - 同一个类的成员或扩展属性；
  - 另一类的成员或扩展属性。
- 要将一个属性委托给另一个属性，请在委托名称中使用正确的限定符 :: ，例如 this::delegate 或者 MyClass::delegate。
#+BEGIN_SRC kotlin
var topLevelInt: Int = 0
class WithDelegate(val numA: Int)
class MyClass(var memberInt: Int, val instance: WithDelegate) {
    var delegatedToMember: Int by this::memberInt
    var delegatedToTopLevel: Int by ::topLevelInt
    val delegatedToAnotherClass: Int by instance::numA
}
var MyClass.extDelegated: Int by ::topLevelInt
#+END_SRC
- 这可是非常有用的，例如，当你希望以后兼容的方式重命名属性时：引入一个新属性，用 @Deprecated 注释旧属性，并委托其实现。
#+BEGIN_SRC kotlin
class MyClass {
    var newName: Int = 0
    @Deprecated("Use 'newName' instead", ReplaceWith("newName"))
    var oldName: Int by this::newName
}
fun main() {
    val myClass = MyClass()
    // 注意: 'oldName: Int' 已经弃用，使用'newName'替代
    myClass.oldName = 42
    println(myClass.newName) // 42
}
#+END_SRC
** 提供委托
- 通过定义 provideDelegate 操作符，你可以扩展创建属性实现被委托到对象的逻辑。如果 by 右侧使用的对象将 provideDelegate 定义为成员或扩展函数，则将调用该函数来创建属性委托实例。
- provideDelegate 的一个最可能的用法是在创建属性（而不仅在 getter 或者 setter 中）时检查属性的一致性。例如，你想在绑定之前检查属性名，你可以这样写：
#+BEGIN_SRC kotlin
class ResourceLoader<T>(id: ResourceID<T>) {
    operator fun provideDelegate(
        thisRef: MyUI,
        prop: KProperty<*>
    ): ReadOnlyProperty<MyUI, T> {
        checkProperty(thisRef, prop.name)
        return ResourceDelegate() // 创建委托
    }
    private fun checkProperty(thisRef: MyUI, name: String) { ... }
}
fun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }
class MyUI {
    fun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }
    val image by bindResource(ResourceID.image_id)
    val text by bindResource(ResourceID.text_id)
}
#+END_SRC
- provideDelegate 的参数和 getValue 相同：
  - thisRef：   必须是属性所有者的相同或超类型（对于扩展性—被扩展的类型）；
  - property：  必须是KProperty<*>或其超类型。
- 在创建 MyUI 实例期间，会为每个属性调用 provideDelegate 方法，它会立即执行必要的验证。如果没有这种拦截属性与其委托之间的绑定的能力，要实现同样的功能，你必须显式地传递属性名，这不是很方便：
#+BEGIN_SRC kotlin
// 检查属性名称而没有 "provideDelegate" 功能
class MyUI {
    val image by bindResource(ResourceID.image_id, "image")
    val text by bindResource(ResourceID.text_id, "text")
}
fun <T> MyUI.bindResource(
        id: ResourceID<T>,
        propertyName: String
): ReadOnlyProperty<MyUI, T> {
   checkProperty(this, propertyName)
   // 创建委托
}
#+END_SRC
- 在生成的代码中，将调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与上面（当 provideDelegate方法不存在时）生成的代码：
#+BEGIN_SRC kotlin
class User {
    var prop: Type by MyDelegate()
}
// 此代码由编译器生成
// 当'provideDelegate'函数可用时：
class User  {
    // 调用 "provideDelegate" 创建附加的 "delegate" 属性
    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)
    var prop: Type
        get() = prop$delegate.getValue(this, this::prop)
    set(value: Type) = prop$delegate.setValue(this, this::prop, value)
}
#+END_SRC
- 请注意，provideDelegate 方法只影响辅助属性的创建，而不影响为getter或setter生成的代码。
** 自定义代理属性
- 你已经知道如何使用标准代理属性了，下面将展示如何创建一个自定义代理属性。
- 例子：假设我们要为类C创建一个代理类CDelegate，如果C中的属性使用了代理，则该属性的get()方法将会代理到代理类中
  - 首先需要让代理类 CDelegate 继承自 ReadOnlyProperty，同时实现其中的 getValue() 方法，后面被代理对象的 get() 方法执行时将会被转发到 getValue() 中执行。
  - 同时声明一个用 operator 修饰符修饰的 provideDelegate 方法，在后面创建 CDelegate 的实例对象时，provideDelegate 方法会被立即调用，并为被代理对象创建代理对象。
#+BEGIN_SRC kotlin
// NOTE: 在本例中，代理对象只是 CDelegate，你可以通过返回不同的代理类对象从而代理到不同的代理中。
class CDelegate : ReadOnlyProperty<C, String> {
    operator fun provideDelegate (thisRef: C, property: KProperty<*>) :ReadOnlyProperty<C, kotlin.String> {
        Log.d(Const.TAG, "Calling providerDelegate()")
        //可以在创建前进行一些检查
        return CDelegate()
    }
 
    override fun getValue(thisRef: C, property: KProperty<*>): String {
        //在这里进行代理 get() 的计算和处理
        Log.d(Const.TAG, "Calling getValue()")
        return "End"
    }
}
#+END_SRC
- 然后在使用时，只需要简单在需要被代理的属性后使用 by 修饰符来声明代理类对象即可：
#+BEGIN_SRC kotlin
class C {
    val c by CDelegate()
    fun call() {
        Log.d(Const.TAG, "c value is: $c")
    }
}
#+END_SRC
- 在创建完 c 之后，所有对其 get() 方法的调用都会被代理到 CDelegate 的 getValue() 方法当中。
** 典型应用
- 封装一个 SharedPreferences（简称 SP） 是 Android 开发中经常要做的事，因为直接调用 SP 足够繁琐。如果是 Java 代码，则代码基本如下
#+BEGIN_SRC java
public final class PreferencesUtil {
    private static PreferencesUtil sInstance;
    public static void init(Context context) {
        if (sInstance == null) 
            sInstance = new PreferencesUtil(context);
    }
    public static PreferencesUtil getInstance() {
        if (sInstance == null) throw new RuntimeException("Uninitialized.");
        return sInstance;
    }
    private final SharedPreferences mSp;
    private PreferencesUtil(Context context) {
        mSp = PreferenceManager.getDefaultSharedPreferences(context);
    }
    public String getString(String key, String defValue) {
        return mSp.getString(key, defValue);
    }
    public void putString(String key, String value) {
        mSp.edit().putString(key, value).apply();
    }
    public int getInt(String key, int defValue) {
        return mSp.getInt(key, defValue);
    }
    public void putInt(String key, int value) {
        mSp.edit().putInt(key, value).apply();
    }
    public long getLong(String key, long defValue) {
        return mSp.getLong(key, defValue);
    }
    public void putLong(String key, long value) {
        mSp.edit().putLong(key, value).apply();
    }
    public float getFloat(String key, float defValue) {
        return mSp.getFloat(key, defValue);
    }
    public void putFloat(String key, float value) {
        mSp.edit().putFloat(key, value).apply();
    }
    public boolean getBoolean(String key, boolean defValue) {
        return mSp.getBoolean(key, defValue);
    }
    public void putBoolean(String key, boolean value) {
        mSp.edit().putBoolean(key, value).apply();
    }
}
#+END_SRC
- 外部调用
#+BEGIN_SRC java
if (PreferencesUtil.getInstance().getBoolean(Constant.IS_FIRST_LAUNCH, Constant.DEF_IS_FIRST_LAUNCH)) {
    // Do something first launch, like showing Welcome.
    PreferencesUtil.getInstance().putBoolean(Constant.IS_FIRST_LAUNCH, false);
}
#+END_SRC
- 使用 Kotlin 的委托属性之后实现就简洁很多
#+BEGIN_SRC kotlin
class PreferenceUtils<T>(val context: Context, val name: String, val default: T): ReadWriteProperty {
    val prefs: SharedPreferences by lazy { context.defaultSharedPreferences }
    override fun getValue(thisRef: Any?, property: KProperty<*>): T {
        return findPreference(name, default)
    }
    override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {
        putPreference(name, value)
    }
    private fun findPreference(name: String, default: T): T = with(prefs) {
        val res: Any = when (default) {
            is Long -> getLong(name, default)
            is Int -> getInt(name, default)
            is String -> getString(name, default)
            is Boolean -> getBoolean(name, default)
            is Float -> getFloat(name, default)
            else -> throw IllegalArgumentException("This type can't be saved into Preferences")
        }
        return@with res as T
    }
    private fun  putPreference(name: String, value: T) = with(prefs.edit()) {
        when (value) {
            is Long -> putLong(name, value)
            is Int -> putInt(name, value)
            is String -> putString(name, value)
            is Boolean -> putBoolean(name, value)
            is Float -> putFloat(name, value)
            else -> throw IllegalArgumentException("This type can't be saved into Preferences")
        }.apply()
    }
}
#+END_SRC
- 其中接口ReadWriteProperty为系统提供的规范接口，其中定义了getValue/setValue方法。外部调用如下
#+BEGIN_SRC kotlin
var themeCode by PreferenceUtils(context, Constant.theme_code, default = 1)
themeCode = 9527
#+END_SRC
** 属性委托在 Android 上的应用
*** ViewBinding
    #+BEGIN_SRC kotlin
//1. 借助 lazy 属性委托  + 反射 VB 的 inflate 方法 https://github.com/jaydroid1024/anyby
private val binding: ActivityMainBinding by vb() 
//2. 借助 lazy 属性委托  + 传递 inflate 方法引用
private val binding: ActivityMainBinding by vb(ActivityMainBinding::inflate)
    #+END_SRC
- VBHelper
#+BEGIN_SRC kotlin
@MainThread
inline fun <reified T : ViewBinding> ComponentActivity.vb(noinline inflateMethodRef: ((LayoutInflater) -> T)? = null): Lazy<T> =
    ActivityVBLazy(this, T::class, inflateMethodRef)
class ActivityVBLazy<T : ViewBinding>(
    private val activity: ComponentActivity,
    private val kClass: KClass<*>,
    private val inflateMethodRef: ((LayoutInflater) -> T)?
) : Lazy<T> {
    private var cachedBinding: T? = null
    override val value: T
        get() {
            var viewBinding = cachedBinding
            if (viewBinding == null) {
                viewBinding = if (inflateMethodRef != null) {
                    //借助 lazy 属性委托 + 传递 inflate 方法引用
                    inflateMethodRef.invoke(activity.layoutInflater)
                } else {
                    //借助 lazy 属性委托  + 反射绑定类的 inflate 方法
                    @Suppress("UNCHECKED_CAST")
                    kClass.java.getMethod(METHOD_INFLATE, LayoutInflater::class.java)
                        .invoke(null, activity.layoutInflater) as T
                }
                activity.setContentView(viewBinding.root)
                cachedBinding = viewBinding
            }
            return viewBinding
        }
    override fun isInitialized() = cachedBinding != null
}
#+END_SRC
*** ViewModel
    #+BEGIN_SRC kotlin
//借助 lazy 属性委托  + ViewModelProvider
val model: MyViewModel by viewModels()
#+END_SRC
- ActivityViewModelLazy
#+BEGIN_SRC kotlin
@MainThread
inline fun <reified VM : ViewModel> ComponentActivity.viewModels(
    factory: ViewModelProvider.Factory? = null
): Lazy<VM> = ActivityViewModelLazy(this, VM::class, factory)

/**
 * An implementation of [Lazy] used by [ComponentActivity.viewModels] tied to the given [activity],
 * [viewModelClass], [factory]
 */
class ActivityViewModelLazy<VM : ViewModel>(
    private val activity: ComponentActivity,
    private val viewModelClass: KClass<VM>,
    private val factory: ViewModelProvider.Factory?
) : Lazy<VM> {
    private var cached: VM? = null
    override val value: VM
        get() {
            var viewModel = cached
            if (viewModel == null) {
                val application = activity.application
                    ?: throw IllegalArgumentException(
                        "ViewModel can be accessed " +
                                "only when Activity is attached"
                    )
                val resolvedFactory = factory ?: AndroidViewModelFactory.getInstance(application)
                viewModel = ViewModelProvider(activity, resolvedFactory).get(viewModelClass.java)
                cached = viewModel
            }
            return viewModel
        }

    override fun isInitialized() = cached != null
}
    #+END_SRC
- FragmentViewModelLazy
#+BEGIN_SRC kotlin
@MainThread
inline fun <reified VM : ViewModel> Fragment.viewModels(factory: Factory? = null): Lazy<VM> =
    FragmentViewModelLazy(this, VM::class, factory)

/**
 * An implementation of [Lazy] used by [Fragment.viewModels] tied to the given [fragment],
 * [viewModelClass], [factory]
 */
class FragmentViewModelLazy<VM : ViewModel>(
    private val fragment: Fragment,
    private val viewModelClass: KClass<VM>,
    private val factory: Factory?
) : Lazy<VM> {
    private var cached: VM? = null
    override val value: VM
        get() {
            var viewModel = cached
            if (viewModel == null) {
                val application = fragment.activity?.application
                    ?: throw IllegalArgumentException(
                        "ViewModel can be accessed " +
                                "only when Fragment is attached"
                    )
                val resolvedFactory = factory ?: AndroidViewModelFactory.getInstance(application)
                viewModel = ViewModelProvider(fragment, resolvedFactory).get(viewModelClass.java)
                cached = viewModel
            }
            return viewModel
        }

    override fun isInitialized() = cached != null
}
#+END_SRC
*** SP delegates
    #+BEGIN_SRC kotlin
fun SharedPreferences.int(def: Int = 0, key: String? = null) =
    delegate(def, key, SharedPreferences::getInt, SharedPreferences.Editor::putInt)

fun SharedPreferences.long(def: Long = 0, key: String? = null) =
    delegate(def, key, SharedPreferences::getLong, SharedPreferences.Editor::putLong)

fun SharedPreferences.string(def: String = "", key: String? = null) =
    delegate(def, key, SharedPreferences::getString, SharedPreferences.Editor::putString)

private inline fun <T> SharedPreferences.delegate(
    defaultValue: T,
    key: String?,
    crossinline getter: SharedPreferences.(String, T) -> T,
    crossinline setter: SharedPreferences.Editor.(String, T) -> SharedPreferences.Editor
) = object : ReadWriteProperty<Any, T> {
    override fun getValue(thisRef: Any, property: KProperty<*>) =
        getter(key ?: property.name, defaultValue)

    @SuppressLint("CommitPrefEdits")
    override fun setValue(thisRef: Any, property: KProperty<*>, value: T) =
        edit().setter(key ?: property.name, value).apply()
}
    #+END_SRC
- 测试代码
#+BEGIN_SRC kotlin
class TokenHolder(prefs: SharedPreferences) {
    var token: String by prefs.string()
        private set
    var count by prefs.int()
        private set
    fun saveToken(newToken: String) {
        token = newToken
        count++
    }
    override fun toString(): String {
        return "TokenHolder(token='$token', count=$count)"
    }
}
class UserHolder(prefs: SharedPreferences) {
    var name: String by prefs.string()
        private set
    var pwd: String by prefs.string()
        private set
    fun saveUserAccount(name: String, pwd: String) {
        this.name = name
        this.pwd = pwd
    }
    override fun toString(): String {
        return "UserHolder(name='$name', pwd='$pwd')"
    }
}
val prefs = getSharedPreferences("sp_app_jay", Context.MODE_PRIVATE)
//缓存Token的场景
val tokenHolder = TokenHolder(prefs)
Log.d("Jay", "tokenHolder:$tokenHolder")
tokenHolder.saveToken("token_one")
tokenHolder.saveToken("token_second")
//缓存登录信息的场景
val userHolder = UserHolder(prefs)
Log.d("Jay", "userHolder:$userHolder")
userHolder.saveUserAccount("jay", "123456")
#+END_SRC
- 本篇文章围绕 Kotlin 的内置委托(Delegation) 特性并结合代码实践分别阐述了 Kotlin 委托的原理(包括属性委托和接口委托)，尤其是属性委托从属性到委托详细阐述了其实现原理，
- 然后是实践部分，首先是Kotlin 标准库中利用属性委托为我们封装了很多简洁的API，比如：map、lazy、notNull、Observable 等；然后是Kotlin 属性委托在 Android 上的一些实践，包括 VB、VM、SP 等利用属性委托基本上都能完成一行代码实现set/get。Kotlin 委托显然在消除样板代码方面能发挥出强大的作用。但是这每个属性的背后却对应这一个委托类，所以在大量使用时也需要兼顾性能。

* suspend coroutine 
- suspend官方解释：
  - suspend用于暂停执行当前协程，并保存所有局部变量。如需调用suspend函数，只能从其他suspend函数进行调用，或通过使用协程构建器（例如 launch）来启动新的协程。
#+BEGIN_SRC kotlin
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        Log.d("LogUtils", "onCreate执行开始")
        var job = GlobalScope.launch(Dispatchers.Main) {
            Log.d("LogUtils", "主线程： " + Thread.currentThread())
            val asyncs = async(Dispatchers.IO) {
                Thread.sleep(50000)
                Log.d("LogUtils","子线程： " + Thread.currentThread())
                "耗时执行完毕"
            }
            Log.d("LogUtils", "执行于此")
            Log.d("LogUtils", asyncs.await())
            Log.d("LogUtils", "launch执行结束")
        }
        Log.d("LogUtils", "onCreate执行结束")
    }
#+END_SRC
- 打印出来的结果是：（来想一下代码段执行的先后顺序） 
#+BEGIN_SRC kotlin
D/LogUtils: onCreate执行开始
D/LogUtils: onCreate执行结束
D/LogUtils: 主线程： Thread[main,5,main]
D/LogUtils: 执行于此
D/LogUtils: 子线程： Thread[DefaultDispatcher-worker-1,5,main]
D/LogUtils: 耗时执行完毕
D/LogUtils: launch执行结束
#+END_SRC
- 上述例子结果可以看出主线程没有被阻塞，launch{···}代码块被暂停挂起最后执行在主线程中，async{···}代码块暂停被挂起执行在子线程中，asyncs.await()之后的代码被挂起最后执行
- 如：launch{···}源代码：
#+BEGIN_SRC kotlin
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
): Job {
    val newContext = newCoroutineContext(context)
    val coroutine = if (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) else
        StandaloneCoroutine(newContext, active = true)
    coroutine.start(start, coroutine, block)
    return coroutine
}
#+END_SRC
- block: suspend CoroutineScope.() -> Unit接收的是launck{···}代码块并且被suspend关键字修饰，也就是{···}的代码块被定义为暂停的模块。
- 看到 例 1，将协程launch{···}设置为主线程操作，在执行示例代码根据log打印结果，发现launch{···}虽然设置为主线程，但是代码块并没有按照主线程顺序执行，launch{···}代码块就像是暂停，而是之后才执行并且是在主线程执行，这个过程就像是launch{···}代码块被挂起，某个时机又切回了主线程继续执行代码块的代码逻辑
- 难道采用suspend关键字修饰的方法或者代码块不需要而外的设定就可以实现代码挂起或者暂停，然后在某个时机再执行？ （答案显然是否定的）
- 通过协程源码与kotlin源码看问题
#+BEGIN_SRC kotlin
// kotlinx.coroutines.intrinsics.Cancellable.kt
internal fun <R, T> (suspend (R) -> T).startCoroutineCancellable(
    receiver: R,                
    completion: Continuation<T> 
) =
    runSafely(completion) {
        createCoroutineUnintercepted(receiver, completion).intercepted()
            .resumeCancellableWith(Result.success(Unit))
    }

// kotlin.coroutines.intrinsics.IntrinsicsJvm.kt (kotlin源码类)
public actual fun <R, T> (suspend R.() -> T).createCoroutineUnintercepted( // suspend 修饰过的方法
    receiver: R,
    completion: Continuation<T>
): Continuation<Unit> {
    val probeCompletion = probeCoroutineCreated(completion)
    return if (this is BaseContinuationImpl)
        create(receiver, probeCompletion)
    else {
        createCoroutineFromSuspendFunction(probeCompletion) {
            (this as Function2<R, Continuation<T>, Any?>).invoke(receiver, it) // 1 <<<======
        }
    }
}
private inline fun <T> createCoroutineFromSuspendFunction(
    completion: Continuation<T>,
    crossinline block: (Continuation<T>) -> Any?
): Continuation<Unit> {
    val context = completion.context
    // label == 0 when coroutine is not started yet (initially) or label == 1 when it was
    return if (context === EmptyCoroutineContext)
        object : RestrictedContinuationImpl(completion as Continuation<Any?>) {
            private var label = 0
            override fun invokeSuspend(result: Result<Any?>): Any? =
                when (label) {
                    0 -> {
                        label = 1
                        result.getOrThrow() // Rethrow exception if trying to start with exception (will be caught by BaseContinuationImpl.resumeWith
                        block(this) // run the block, may return or suspend
                    }
                    1 -> {
                        label = 2
                        result.getOrThrow() // this is the result if the block had suspended
                    }
                    else -> error("This coroutine had already completed")
                }
        }
    else
        object : ContinuationImpl(completion as Continuation<Any?>, context) {
            private var label = 0
            override fun invokeSuspend(result: Result<Any?>): Any? =
                when (label) {
                    0 -> {
                        label = 1
                        result.getOrThrow() // Rethrow exception if trying to start with exception (will be caught by BaseContinuationImpl.resumeWith
                        block(this) // run the block, may return or suspend
                    }
                    1 -> {
                        label = 2
                        result.getOrThrow() // this is the result if the block had suspended
                    }
                    else -> error("This coroutine had already completed")
                }
        }
}
#+END_SRC
- 这里不研究协程源码，只拿协程源码说事，看到createCoroutineUnintercepted(receiver, completion)方法，该方法在kotlin源码中是通过suspend关键字修饰的扩展方法，看到kotlin源码的实现，在代码 // 1 处代码块中，
#+BEGIN_SRC kotlin
(this as Function2<R, Continuation<T>, Any?>).invoke(receiver, it)
#+END_SRC
  - (this是(suspend R.() -> T)对象，也就是被suspend关键字修饰的代码块)将suspend关键字修饰的对象转化为一个Function2<R, Continuation<T>, Any?>接口对象，到这里大概明白，suspend关键字修饰(suspend R.() -> T)对象实际被编译成为一个Function2<R, Continuation<T>, Any?>接口对象，而关键字suspend实际编译成了Continuation接口
- 这边举例来解释
  #+BEGIN_SRC kotlin
class SuspendTest {
    fun test(){
        GlobalScope.launch(Dispatchers.Main) {
            Log.d("LogUtils","--------------------")
        }
    }
}
  #+END_SRC
- 通过反编译 例 2 代码
#+BEGIN_SRC java
public final class Test {
    public final void test() {
        BuildersKt.launch$default((CoroutineScope)GlobalScope.INSTANCE,
                                  (CoroutineContext)Dispatchers.getMain(),
                                  (CoroutineStart)null,
                                  (Function2)(new Function2((Continuation)null) {
                    int label;

                    @Nullable
                    public final Object invokeSuspend(@NotNull Object var1) {
                        Object var2 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
                        switch(this.label) {
                            case 0:
                                ResultKt.throwOnFailure(var1);
                                Log.d("LogUtils", "--------------------");
                                return Unit.INSTANCE;
                            default:
                                throw new IllegalStateException("call to 'resume' before 'invoke' with coroutine");
                        }
                    }
                    @NotNull
                    public final Continuation create(@Nullable Object value, @NotNull Continuation completion) {
                        Intrinsics.checkNotNullParameter(completion, "completion");
                        Function2 var3 = new <anonymous constructor>(completion);
                        return var3;
                    }
                    public final Object invoke(Object var1, Object var2) {
                        return ((<undefinedtype>)this.create(var1, (Continuation)var2)).invokeSuspend(Unit.INSTANCE);
                    }
                }), 2, (Object)null);
    }
}
#+END_SRC
- 看到Function2接口
#+BEGIN_SRC java
public interface Function2<P1, P2, R> extends Function<R> {
  R invoke(P1 paramP1, P2 paramP2);
}
#+END_SRC
- 看到反编译的后的代码，在代码 //1 处，suspend关键字修饰的代码块转化为Function2接口类，并且调用invoke(P1 paramP1, P2 paramP2)重载方法最终调用代码块逻辑
- 疑问: 是不是通过suspend关键字修饰的代码块或者函数都能起到暂停、被挂起代码？
- 举个例子来说明
#+BEGIN_SRC kotlin
class SuspendTest {
    fun test(){
        GlobalScope.launch(Dispatchers.Main) {
            Log.d("LogUtils","launch开始")
            suspendTest()
            Log.d("LogUtils","launch结束")
        }
    }
    private suspend fun suspendTest() {
        Log.d("LogUtils","执行一个自定义suspend修饰方法")
    }
}
#+END_SRC
- 执行结果：
#+BEGIN_SRC kotlin
D/LogUtils: launch开始
D/LogUtils: 执行一个自定义suspend修饰方法
D/LogUtils: launch结束
#+END_SRC
- 通过 例3 与 例1 执行结果对比，自定义的suspend关键字修饰方法并没有暂停、挂起的效果，也就是suspend关键字并不具备暂停、挂起代码块或者函数方法功能，而暂停、挂起代码块或者函数方法要而外逻辑实现，kotlin协程框架中是有暂停、挂起代码块或者函数方法需要而外逻辑实现的
- 打个比方：suspend关键字就像钓鱼场的提供的渔具，显然渔具不是鱼，你拿到渔具不进行垂钓显然没有鱼，同理，suspend是kotlin的关键字，就像一个现成的工具，虽然被定义暂停或是挂起的意义，但是本身不具备真正的逻辑操作，而协程框架就是一个对suspend关键字具体操作过程来实现真正意义上的暂停与挂起，切换线程等等
- 看到这里大概明白了一点，suspend关键字本质是一个接口，持有上下文引用，具有一个回调方法，并且kotlin官方定义了一些针对suspend关键字的使用方法，通过suspend关键字修饰，自己实现具体逻辑，可采用内设的接口以及方法来实现暂停协程或者挂起协程，切换线程等等操作（也就是说只使用suspend关键字并没有暂停、挂起功能）
- 总结1：
 - Job类：启动协程的两种方式即launch和async。launch是启动直接执行，async是启动后需要await触发执行。启动协程返回的结果就是一个Job，可以通过job取消协程等等操作。
 - withContext方法：线程切换，注意是切换执行协程的线程，也就是说指定在哪个线程执行协程代码块。
 - CoroutineDispatcher类：协程分发器，将协程分发到哪个线程去执行，配合withContext方法使用。
 - CoroutineContext类：协程上下文，用于暂停或者恢复协程时，保存和恢复现场等场景。
 - CoroutineScheduler类：协程执行器，内部实现就是使用的我们熟悉的线程池Executor。
 - CoroutineScope类：跟踪使用 launch 或 async 创建的所有协程。可以调用 scope.cancel() 以取消正在进行的同一Scope的工作Job（即正在运行的协程），简单来说就是管理一组Job的。
- 总结2：
  - 协程执行耗时操作时也是依靠子线程去完成的，从子线程切换回UI线程也是依靠我们平时接触的Android Handler类完成的。
  - 我们写的协程代码看起来是同步形式的，其实也是异步回调的，只是编译器帮我们自动生成了回调代码而已。编译器将suspend形式的同步代码，生成带有Continuation回调形式的代码。
- 总结3：
 - 虽然说协程内部也是协助线程池和Android Handler完成子线程和UI线程的切换。但是为了充分利用线程资源和减少线程切换，内部也维护着自己的调用栈，所以出现CoroutineContext、CoroutineScope等新的概念。
 - 
